import {
  ALIGN,
  AnchorPoint,
  AnimatingState,
  AxesController,
  BoundCameraMode,
  CIRCULAR_FALLBACK,
  CLASS,
  CODE,
  Camera,
  CircularCameraMode,
  Control,
  DIRECTION,
  DisabledState,
  DraggingState,
  EVENTS,
  ExternalRenderer,
  Flicking,
  FlickingError,
  FreeControl,
  HoldingState,
  IdleState,
  LinearCameraMode,
  MOVE_TYPE,
  NormalRenderingStrategy,
  Panel,
  Renderer,
  SnapControl,
  State,
  StateMachine,
  StrictControl,
  VanillaElementProvider,
  VanillaRenderer,
  Viewport,
  VirtualElementProvider,
  VirtualManager,
  VirtualPanel,
  VirtualRenderingStrategy,
  checkExistence,
  circulateIndex,
  circulatePosition,
  clamp,
  component_esm_default,
  find,
  findIndex,
  findRight,
  getDefaultCameraTransform,
  getDirection,
  getElement,
  getElementSize,
  getFlickingAttached,
  getMinusCompensatedIndex,
  getProgress,
  getRenderingPanels,
  getStyle,
  includes,
  isBetween,
  isString,
  merge,
  parseAlign$1,
  parseArithmeticExpression,
  parseArithmeticSize,
  parseBounce,
  parseCSSSizeValue,
  parseElement,
  parsePanelAlign,
  range,
  setPrototypeOf,
  setSize,
  sync,
  toArray,
  withFlickingMethods
} from "./chunk-GIIKNBMA.js";
import {
  require_react_dom
} from "./chunk-7PKFJE5B.js";
import {
  require_react
} from "./chunk-JFTBQ7A7.js";
import {
  __toESM
} from "./chunk-AC2VUBZ6.js";

// node_modules/@egjs/react-flicking/dist/flicking.esm.js
var React = __toESM(require_react());
var import_react = __toESM(require_react());

// node_modules/@egjs/list-differ/dist/list-differ.esm.js
var PolyMap = function() {
  function PolyMap2() {
    this.keys = [];
    this.values = [];
  }
  var __proto = PolyMap2.prototype;
  __proto.get = function(key) {
    return this.values[this.keys.indexOf(key)];
  };
  __proto.set = function(key, value) {
    var keys = this.keys;
    var values = this.values;
    var prevIndex = keys.indexOf(key);
    var index = prevIndex === -1 ? keys.length : prevIndex;
    keys[index] = key;
    values[index] = value;
  };
  return PolyMap2;
}();
var HashMap = function() {
  function HashMap2() {
    this.object = {};
  }
  var __proto = HashMap2.prototype;
  __proto.get = function(key) {
    return this.object[key];
  };
  __proto.set = function(key, value) {
    this.object[key] = value;
  };
  return HashMap2;
}();
var SUPPORT_MAP = typeof Map === "function";
var Link = function() {
  function Link2() {
  }
  var __proto = Link2.prototype;
  __proto.connect = function(prevLink, nextLink) {
    this.prev = prevLink;
    this.next = nextLink;
    prevLink && (prevLink.next = this);
    nextLink && (nextLink.prev = this);
  };
  __proto.disconnect = function() {
    var prevLink = this.prev;
    var nextLink = this.next;
    prevLink && (prevLink.next = nextLink);
    nextLink && (nextLink.prev = prevLink);
  };
  __proto.getIndex = function() {
    var link = this;
    var index = -1;
    while (link) {
      link = link.prev;
      ++index;
    }
    return index;
  };
  return Link2;
}();
function orderChanged(changed, fixed) {
  var fromLinks = [];
  var toLinks = [];
  changed.forEach(function(_a) {
    var from = _a[0], to = _a[1];
    var link = new Link();
    fromLinks[from] = link;
    toLinks[to] = link;
  });
  fromLinks.forEach(function(link, i) {
    link.connect(fromLinks[i - 1]);
  });
  return changed.filter(function(_, i) {
    return !fixed[i];
  }).map(function(_a, i) {
    var from = _a[0], to = _a[1];
    if (from === to) {
      return [0, 0];
    }
    var fromLink = fromLinks[from];
    var toLink = toLinks[to - 1];
    var fromIndex = fromLink.getIndex();
    fromLink.disconnect();
    if (!toLink) {
      fromLink.connect(void 0, fromLinks[0]);
    } else {
      fromLink.connect(toLink, toLink.next);
    }
    var toIndex = fromLink.getIndex();
    return [fromIndex, toIndex];
  });
}
var Result = function() {
  function Result2(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed) {
    this.prevList = prevList;
    this.list = list;
    this.added = added;
    this.removed = removed;
    this.changed = changed;
    this.maintained = maintained;
    this.changedBeforeAdded = changedBeforeAdded;
    this.fixed = fixed;
  }
  var __proto = Result2.prototype;
  Object.defineProperty(__proto, "ordered", {
    get: function() {
      if (!this.cacheOrdered) {
        this.caculateOrdered();
      }
      return this.cacheOrdered;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(__proto, "pureChanged", {
    get: function() {
      if (!this.cachePureChanged) {
        this.caculateOrdered();
      }
      return this.cachePureChanged;
    },
    enumerable: true,
    configurable: true
  });
  __proto.caculateOrdered = function() {
    var ordered = orderChanged(this.changedBeforeAdded, this.fixed);
    var changed = this.changed;
    var pureChanged = [];
    this.cacheOrdered = ordered.filter(function(_a, i) {
      var from = _a[0], to = _a[1];
      var _b = changed[i], fromBefore = _b[0], toBefore = _b[1];
      if (from !== to) {
        pureChanged.push([fromBefore, toBefore]);
        return true;
      }
    });
    this.cachePureChanged = pureChanged;
  };
  return Result2;
}();
function diff(prevList, list, findKeyCallback) {
  var mapClass = SUPPORT_MAP ? Map : findKeyCallback ? HashMap : PolyMap;
  var callback = findKeyCallback || function(e) {
    return e;
  };
  var added = [];
  var removed = [];
  var maintained = [];
  var prevKeys = prevList.map(callback);
  var keys = list.map(callback);
  var prevKeyMap = new mapClass();
  var keyMap = new mapClass();
  var changedBeforeAdded = [];
  var fixed = [];
  var removedMap = {};
  var changed = [];
  var addedCount = 0;
  var removedCount = 0;
  prevKeys.forEach(function(key, prevListIndex) {
    prevKeyMap.set(key, prevListIndex);
  });
  keys.forEach(function(key, listIndex) {
    keyMap.set(key, listIndex);
  });
  prevKeys.forEach(function(key, prevListIndex) {
    var listIndex = keyMap.get(key);
    if (typeof listIndex === "undefined") {
      ++removedCount;
      removed.push(prevListIndex);
    } else {
      removedMap[listIndex] = removedCount;
    }
  });
  keys.forEach(function(key, listIndex) {
    var prevListIndex = prevKeyMap.get(key);
    if (typeof prevListIndex === "undefined") {
      added.push(listIndex);
      ++addedCount;
    } else {
      maintained.push([prevListIndex, listIndex]);
      removedCount = removedMap[listIndex] || 0;
      changedBeforeAdded.push([prevListIndex - removedCount, listIndex - addedCount]);
      fixed.push(listIndex === prevListIndex);
      if (prevListIndex !== listIndex) {
        changed.push([prevListIndex, listIndex]);
      }
    }
  });
  removed.reverse();
  return new Result(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed);
}
var ListDiffer = function() {
  function ListDiffer2(list, findKeyCallback) {
    if (list === void 0) {
      list = [];
    }
    this.findKeyCallback = findKeyCallback;
    this.list = [].slice.call(list);
  }
  var __proto = ListDiffer2.prototype;
  __proto.update = function(list) {
    var newData = [].slice.call(list);
    var result = diff(this.list, newData, this.findKeyCallback);
    this.list = newData;
    return result;
  };
  return ListDiffer2;
}();
var list_differ_esm_default = ListDiffer;

// node_modules/@egjs/react-flicking/dist/flicking.esm.js
var import_react_dom = __toESM(require_react_dom());
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  }, f, y, t, g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
var DEFAULT_PROPS = {
  viewportTag: "div",
  cameraTag: "div",
  cameraClass: "",
  renderOnSameKey: false,
  plugins: [],
  useFindDOMNode: false,
  hideBeforeInit: false,
  onReady: function(e) {
  },
  onBeforeResize: function(e) {
  },
  onAfterResize: function(e) {
  },
  onHoldStart: function(e) {
  },
  onHoldEnd: function(e) {
  },
  onMoveStart: function(e) {
  },
  onMove: function(e) {
  },
  onMoveEnd: function(e) {
  },
  onWillChange: function(e) {
  },
  onChanged: function(e) {
  },
  onWillRestore: function(e) {
  },
  onRestored: function(e) {
  },
  onSelect: function(e) {
  },
  onNeedPanel: function(e) {
  },
  onVisibleChange: function(e) {
  },
  onReachEdge: function(e) {
  },
  onPanelChange: function(e) {
  }
};
var ReactRenderer = function(_super) {
  __extends(ReactRenderer2, _super);
  function ReactRenderer2(options) {
    var _this = _super.call(this, options) || this;
    _this._reactFlicking = options.reactFlicking;
    return _this;
  }
  var __proto = ReactRenderer2.prototype;
  __proto.render = function() {
    return __awaiter(this, void 0, void 0, function() {
      var flicking, reactFlicking, strategy;
      var _this = this;
      return __generator(this, function(_a) {
        flicking = getFlickingAttached(this._flicking);
        reactFlicking = this._reactFlicking;
        strategy = this._strategy;
        this._rendering = true;
        strategy.updateRenderingPanels(flicking);
        strategy.renderPanels(flicking);
        return [
          2,
          new Promise(function(resolve) {
            reactFlicking.renderEmitter.once("render", function() {
              _this._rendering = false;
              resolve();
            });
            reactFlicking.forceUpdate();
          })
        ];
      });
    });
  };
  __proto.forceRenderAllPanels = function() {
    return __awaiter(this, void 0, void 0, function() {
      var reactFlicking;
      var _this = this;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            reactFlicking = this._reactFlicking;
            this._rendering = true;
            return [
              4,
              _super.prototype.forceRenderAllPanels.call(this)
            ];
          case 1:
            _a.sent();
            return [
              2,
              new Promise(function(resolve) {
                reactFlicking.renderEmitter.once("render", function() {
                  _this._rendering = false;
                  resolve();
                });
                reactFlicking.forceUpdate();
              })
            ];
        }
      });
    });
  };
  __proto._collectPanels = function() {
    var flicking = getFlickingAttached(this._flicking);
    var reactFlicking = this._reactFlicking;
    var reactPanels = reactFlicking.reactPanels;
    this._panels = this._strategy.collectPanels(flicking, reactPanels);
  };
  __proto._createPanel = function(externalComponent, options) {
    return this._strategy.createPanel(externalComponent, options);
  };
  return ReactRenderer2;
}(ExternalRenderer);
var StrictPanel = function(_super) {
  __extends(StrictPanel2, _super);
  function StrictPanel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._hide = false;
    _this._elRef = React.createRef();
    return _this;
  }
  var __proto = StrictPanel2.prototype;
  Object.defineProperty(__proto, "nativeElement", {
    get: function() {
      return this._elRef.current;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "rendered", {
    get: function() {
      return !this._hide;
    },
    enumerable: false,
    configurable: true
  });
  __proto.render = function() {
    return this._hide ? React.createElement(React.Fragment, null) : this._getElement();
  };
  __proto.show = function() {
    this._hide = false;
  };
  __proto.hide = function() {
    this._hide = true;
  };
  __proto._getElement = function() {
    return React.cloneElement(React.Children.only(this.props.children), {
      ref: this._elRef
    });
  };
  return StrictPanel2;
}(React.Component);
var NonStrictPanel = function(_super) {
  __extends(NonStrictPanel2, _super);
  function NonStrictPanel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._hide = false;
    return _this;
  }
  var __proto = NonStrictPanel2.prototype;
  Object.defineProperty(__proto, "nativeElement", {
    get: function() {
      return (0, import_react_dom.findDOMNode)(this);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "rendered", {
    get: function() {
      return !this._hide;
    },
    enumerable: false,
    configurable: true
  });
  __proto.render = function() {
    return this._hide ? React.createElement(React.Fragment, null) : this.props.children;
  };
  __proto.show = function() {
    this._hide = false;
  };
  __proto.hide = function() {
    this._hide = true;
  };
  return NonStrictPanel2;
}(React.Component);
var ViewportSlot = import_react.default.memo(function(props) {
  return import_react.default.createElement(import_react.default.Fragment, null, props.children);
});
var ReactElementProvider = function() {
  function ReactElementProvider2(el) {
    this._el = el;
  }
  var __proto = ReactElementProvider2.prototype;
  Object.defineProperty(__proto, "element", {
    get: function() {
      return this._el.nativeElement;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "rendered", {
    get: function() {
      return this._el.rendered;
    },
    enumerable: false,
    configurable: true
  });
  __proto.show = function() {
    this._el.show();
  };
  __proto.hide = function() {
    this._el.hide();
  };
  return ReactElementProvider2;
}();
var Flicking2 = function(_super) {
  __extends(Flicking3, _super);
  function Flicking3(props) {
    var _this = _super.call(this, props) || this;
    _this._panels = [];
    _this._renderEmitter = new component_esm_default();
    var children = _this._getChildren();
    _this._panels = _this._createPanelRefs(props, children);
    _this._prevChildren = children;
    return _this;
  }
  var __proto = Flicking3.prototype;
  Object.defineProperty(__proto, "reactPanels", {
    get: function() {
      return this._panels.map(function(panel) {
        return panel.current;
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "renderEmitter", {
    get: function() {
      return this._renderEmitter;
    },
    enumerable: false,
    configurable: true
  });
  __proto.componentDidMount = function() {
    var props = this.props;
    var rendererOptions = {
      reactFlicking: this,
      align: props.align,
      strategy: props.virtual && props.panelsPerView > 0 ? new VirtualRenderingStrategy() : new NormalRenderingStrategy({
        providerCtor: ReactElementProvider
      })
    };
    var flicking = new Flicking(this._viewportElement, __assign(__assign({}, props), {
      externalRenderer: new ReactRenderer(rendererOptions)
    }));
    this._vanillaFlicking = flicking;
    var children = this._getChildren();
    this._jsxDiffer = new list_differ_esm_default(children, function(panel) {
      return panel.key;
    });
    this._pluginsDiffer = new list_differ_esm_default();
    this._prevChildren = children;
    this._bindEvents();
    this._checkPlugins();
    if (props.status) {
      flicking.setStatus(props.status);
    }
  };
  __proto.componentWillUnmount = function() {
    var _a;
    (_a = this._vanillaFlicking) === null || _a === void 0 ? void 0 : _a.destroy();
  };
  __proto.shouldComponentUpdate = function(nextProps) {
    var vanillaFlicking = this._vanillaFlicking;
    var prevProps = this.props;
    if (!vanillaFlicking || !vanillaFlicking.initialized)
      return false;
    var children = nextProps.children, restProps = __rest(nextProps, ["children"]);
    for (var key in restProps) {
      if (prevProps[key] !== nextProps[key]) {
        return true;
      }
    }
    var prevChildren = this._prevChildren;
    var nextChildren = this._getChildren(children);
    if (nextProps.renderOnSameKey || !this._hasSameChildren(prevChildren, nextChildren))
      return true;
    return false;
  };
  __proto.beforeRender = function() {
    var vanillaFlicking = this._vanillaFlicking;
    var props = this.props;
    var prevChildren = this._prevChildren;
    if (!vanillaFlicking || !vanillaFlicking.initialized || this._diffResult)
      return;
    var nextChildren = this._getChildren(props.children);
    if (props.renderOnSameKey || !this._hasSameChildren(prevChildren, nextChildren)) {
      this._panels = this._createPanelRefs(props, nextChildren);
      this._diffResult = this._jsxDiffer.update(nextChildren);
      this._prevChildren = nextChildren;
    }
  };
  __proto.componentDidUpdate = function() {
    var flicking = this._vanillaFlicking;
    var renderEmitter = this._renderEmitter;
    var diffResult = this._diffResult;
    this._checkPlugins();
    renderEmitter.trigger("render");
    flicking.camera.updateOffset();
    var _a = this.props;
    _a.virtual;
    var props = __rest(_a, ["virtual"]);
    for (var key in props) {
      if (key in flicking && flicking[key] !== props[key]) {
        flicking[key] = props[key];
      }
    }
    if (!diffResult || !flicking.initialized)
      return;
    sync(flicking, diffResult, this.reactPanels);
    this._diffResult = null;
  };
  __proto.render = function() {
    var _this = this;
    var _a, _b;
    var props = this.props;
    var Viewport2 = props.viewportTag;
    var Camera2 = props.cameraTag;
    var attributes = {};
    var flicking = this._vanillaFlicking;
    this.beforeRender();
    for (var name in props) {
      if (!(name in DEFAULT_PROPS) && !(name in Flicking.prototype)) {
        attributes[name] = props[name];
      }
    }
    var initialized = flicking && flicking.initialized;
    var viewportClasses = ["flicking-viewport"];
    var cameraClasses = ["flicking-camera"];
    var isHorizontal = flicking ? flicking.horizontal : (_a = props.horizontal) !== null && _a !== void 0 ? _a : true;
    if (!isHorizontal) {
      viewportClasses.push("vertical");
    }
    if (props.hideBeforeInit && !initialized) {
      viewportClasses.push("flicking-hidden");
    }
    if (attributes.className) {
      viewportClasses.push(attributes.className);
    }
    if (props.cameraClass) {
      cameraClasses.push(props.cameraClass);
    }
    var cameraProps = !initialized && props.firstPanelSize ? {
      style: {
        transform: getDefaultCameraTransform(this.props.align, this.props.horizontal, this.props.firstPanelSize)
      }
    } : {};
    var panels = !!props.virtual && ((_b = props.panelsPerView) !== null && _b !== void 0 ? _b : -1) > 0 ? this._getVirtualPanels() : this._getPanels();
    return React.createElement(Viewport2, __assign({}, attributes, {
      className: viewportClasses.join(" "),
      ref: function(e) {
        e && (_this._viewportElement = e);
      }
    }), React.createElement(Camera2, __assign({
      className: cameraClasses.join(" ")
    }, cameraProps), panels), this._getViewportSlot());
  };
  __proto._createPanelRefs = function(props, children) {
    var _a;
    var panelsPerView = (_a = props.panelsPerView) !== null && _a !== void 0 ? _a : -1;
    return panelsPerView > 0 && !!props.virtual ? range(panelsPerView + 1).map(function() {
      return React.createRef();
    }) : children.map(function() {
      return React.createRef();
    });
  };
  __proto._bindEvents = function() {
    var _this = this;
    var flicking = this._vanillaFlicking;
    Object.keys(EVENTS).forEach(function(eventKey) {
      var eventName = EVENTS[eventKey];
      var propName = "on".concat(eventName.charAt(0).toUpperCase() + eventName.slice(1));
      flicking.on(eventName, function(e) {
        e.currentTarget = _this;
        var evtHandler = _this.props[propName];
        evtHandler(e);
      });
    });
    flicking.once(EVENTS.READY, function() {
      _this.forceUpdate();
    });
  };
  __proto._checkPlugins = function() {
    var flicking = this._vanillaFlicking;
    var _a = this._pluginsDiffer.update(this.props.plugins), list = _a.list, added = _a.added, removed = _a.removed, prevList = _a.prevList;
    flicking.addPlugins.apply(flicking, added.map(function(index) {
      return list[index];
    }));
    flicking.removePlugins.apply(flicking, removed.map(function(index) {
      return prevList[index];
    }));
  };
  __proto._hasSameChildren = function(prevChildren, nextChildren) {
    if (prevChildren.length !== nextChildren.length || prevChildren.length === 0)
      return false;
    var same = prevChildren.every(function(child, idx) {
      var nextChild = nextChildren[idx];
      if (child.key && nextChild.key) {
        return child.key === nextChild.key;
      } else {
        return child === nextChild;
      }
    });
    return same;
  };
  __proto._getChildren = function(children) {
    var _this = this;
    if (children === void 0) {
      children = this.props.children;
    }
    return React.Children.toArray(children).filter(function(child) {
      return child.type !== ViewportSlot;
    }).reduce(function(all, child) {
      return __spreadArray(__spreadArray([], all, true), _this._unpackFragment(child), true);
    }, []);
  };
  __proto._getViewportSlot = function() {
    return React.Children.toArray(this.props.children).filter(function(child) {
      return child.type === ViewportSlot;
    });
  };
  __proto._unpackFragment = function(child) {
    var _this = this;
    return this._isFragment(child) ? React.Children.toArray(child.props.children).reduce(function(allChilds, fragChild) {
      return __spreadArray(__spreadArray([], allChilds, true), _this._unpackFragment(fragChild), true);
    }, []) : [child];
  };
  __proto._getVirtualPanels = function() {
    var _this = this;
    var _a = this.props.virtual.panelClass, panelClass = _a === void 0 ? "flicking-panel" : _a;
    var panelsPerView = this.props.panelsPerView;
    var flicking = this._vanillaFlicking;
    var initialized = flicking && flicking.initialized;
    var renderingIndexes = initialized ? flicking.renderer.strategy.getRenderingIndexesByOrder(flicking) : range(panelsPerView + 1);
    var firstPanel = flicking && flicking.panels[0];
    var size = firstPanel ? flicking.horizontal ? {
      width: firstPanel.size
    } : {
      height: firstPanel.size
    } : {};
    return renderingIndexes.map(function(idx) {
      return React.createElement("div", {
        key: idx,
        "data-element-index": idx,
        ref: _this._panels[idx],
        className: panelClass,
        style: size
      });
    });
  };
  __proto._getPanels = function() {
    var _this = this;
    var origChildren = this._getChildren();
    var vanillaFlicking = this._vanillaFlicking;
    var diffResult = this._diffResult;
    var children = vanillaFlicking && vanillaFlicking.initialized ? diffResult ? getRenderingPanels(vanillaFlicking, diffResult) : getRenderingPanels(vanillaFlicking, diff(origChildren, origChildren)) : origChildren;
    return this.props.useFindDOMNode ? children.map(function(child, idx) {
      return React.createElement(NonStrictPanel, {
        key: child.key,
        ref: _this._panels[idx]
      }, child);
    }) : children.map(function(child, idx) {
      return React.createElement(StrictPanel, {
        key: child.key,
        ref: _this._panels[idx]
      }, child);
    });
  };
  __proto._isFragment = function(child) {
    if (child.type) {
      return child.type === React.Fragment;
    }
    return child === React.Fragment;
  };
  Flicking3.defaultProps = DEFAULT_PROPS;
  __decorate([withFlickingMethods], Flicking3.prototype, "_vanillaFlicking", void 0);
  return Flicking3;
}(React.Component);
export {
  ALIGN,
  AnchorPoint,
  AnimatingState,
  AxesController,
  BoundCameraMode,
  CIRCULAR_FALLBACK,
  CLASS,
  Camera,
  CircularCameraMode,
  Control,
  DIRECTION,
  DisabledState,
  DraggingState,
  CODE as ERROR_CODE,
  EVENTS,
  ExternalRenderer,
  FlickingError,
  FreeControl,
  HoldingState,
  IdleState,
  LinearCameraMode,
  MOVE_TYPE,
  NormalRenderingStrategy,
  Panel,
  Renderer,
  SnapControl,
  State,
  StateMachine,
  StrictControl,
  VanillaElementProvider,
  VanillaRenderer,
  Viewport,
  ViewportSlot,
  VirtualElementProvider,
  VirtualManager,
  VirtualPanel,
  VirtualRenderingStrategy,
  checkExistence,
  circulateIndex,
  circulatePosition,
  clamp,
  Flicking2 as default,
  find,
  findIndex,
  findRight,
  getDefaultCameraTransform,
  getDirection,
  getElement,
  getElementSize,
  getFlickingAttached,
  getMinusCompensatedIndex,
  getProgress,
  getRenderingPanels,
  getStyle,
  includes,
  isBetween,
  isString,
  merge,
  parseAlign$1 as parseAlign,
  parseArithmeticExpression,
  parseArithmeticSize,
  parseBounce,
  parseCSSSizeValue,
  parseElement,
  parsePanelAlign,
  range,
  setPrototypeOf,
  setSize,
  sync,
  toArray,
  withFlickingMethods
};
/*! Bundled license information:

@egjs/react-flicking/dist/flicking.esm.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=@egjs_react-flicking.js.map
