import {
  require_react_dom
} from "./chunk-YUI5J7UL.js";
import {
  require_prop_types,
  require_react_is
} from "./chunk-NT73QBRE.js";
import {
  require_react
} from "./chunk-JFTBQ7A7.js";
import {
  __commonJS,
  __toESM
} from "./chunk-AC2VUBZ6.js";

// node_modules/exenv/index.js
var require_exenv = __commonJS({
  "node_modules/exenv/index.js"(exports, module) {
    (function() {
      "use strict";
      var canUseDOM3 = !!(typeof window !== "undefined" && window.document && window.document.createElement);
      var ExecutionEnvironment3 = {
        canUseDOM: canUseDOM3,
        canUseWorkers: typeof Worker !== "undefined",
        canUseEventListeners: canUseDOM3 && !!(window.addEventListener || window.attachEvent),
        canUseViewport: canUseDOM3 && !!window.screen
      };
      if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define(function() {
          return ExecutionEnvironment3;
        });
      } else if (typeof module !== "undefined" && module.exports) {
        module.exports = ExecutionEnvironment3;
      } else {
        window.ExecutionEnvironment = ExecutionEnvironment3;
      }
    })();
  }
});

// node_modules/scroll/index.js
var require_scroll = __commonJS({
  "node_modules/scroll/index.js"(exports, module) {
    var E_NOSCROLL = new Error("Element already at target scroll position");
    var E_CANCELLED = new Error("Scroll cancelled");
    var min = Math.min;
    var ms = Date.now;
    module.exports = {
      left: make("scrollLeft"),
      top: make("scrollTop")
    };
    function make(prop) {
      return function scroll2(el, to, opts, cb) {
        opts = opts || {};
        if (typeof opts == "function")
          cb = opts, opts = {};
        if (typeof cb != "function")
          cb = noop2;
        var start = ms();
        var from = el[prop];
        var ease = opts.ease || inOutSine;
        var duration = !isNaN(opts.duration) ? +opts.duration : 350;
        var cancelled = false;
        return from === to ? cb(E_NOSCROLL, el[prop]) : requestAnimationFrame(animate), cancel;
        function cancel() {
          cancelled = true;
        }
        function animate(timestamp) {
          if (cancelled)
            return cb(E_CANCELLED, el[prop]);
          var now = ms();
          var time = min(1, (now - start) / duration);
          var eased = ease(time);
          el[prop] = eased * (to - from) + from;
          time < 1 ? requestAnimationFrame(animate) : requestAnimationFrame(function() {
            cb(null, el[prop]);
          });
        }
      };
    }
    function inOutSine(n) {
      return 0.5 * (1 - Math.cos(Math.PI * n));
    }
    function noop2() {
    }
  }
});

// node_modules/scrollparent/scrollparent.js
var require_scrollparent = __commonJS({
  "node_modules/scrollparent/scrollparent.js"(exports, module) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else {
        root.Scrollparent = factory();
      }
    })(exports, function() {
      var regex = /(auto|scroll)/;
      var parents = function(node, ps) {
        if (node.parentNode === null) {
          return ps;
        }
        return parents(node.parentNode, ps.concat([node]));
      };
      var style = function(node, prop) {
        return getComputedStyle(node, null).getPropertyValue(prop);
      };
      var overflow = function(node) {
        return style(node, "overflow") + style(node, "overflow-y") + style(node, "overflow-x");
      };
      var scroll2 = function(node) {
        return regex.test(overflow(node));
      };
      var scrollParent2 = function(node) {
        if (!(node instanceof HTMLElement || node instanceof SVGElement)) {
          return;
        }
        var ps = parents(node.parentNode, []);
        for (var i = 0; i < ps.length; i += 1) {
          if (scroll2(ps[i])) {
            return ps[i];
          }
        }
        return document.scrollingElement || document.documentElement;
      };
      return scrollParent2;
    });
  }
});

// node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "node_modules/deepmerge/dist/cjs.js"(exports, module) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge3(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge3;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge3;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge3(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge3.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge3(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge3;
    module.exports = deepmerge_1;
  }
});

// node_modules/react-proptype-conditional-require/dist/isRequiredIf.js
var require_isRequiredIf = __commonJS({
  "node_modules/react-proptype-conditional-require/dist/isRequiredIf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var VALIDATOR_ARG_ERROR_MESSAGE = "The typeValidator argument must be a function with the signature function(props, propName, componentName).";
    var MESSAGE_ARG_ERROR_MESSAGE = "The error message is optional, but must be a string if provided.";
    var propIsRequired = function propIsRequired2(a, b, c, d) {
      if ("boolean" == typeof a)
        return a;
      return "function" == typeof a ? a(b, c, d) : !(true !== !!a) && !!a;
    };
    var propExists = function propExists2(a, b) {
      return Object.hasOwnProperty.call(a, b);
    };
    var missingPropError = function missingPropError2(a, b, c, d) {
      return d ? new Error(d) : new Error("Required " + a[b] + " `" + b + "`" + (" was not specified in `" + c + "`."));
    };
    var guardAgainstInvalidArgTypes = function guardAgainstInvalidArgTypes2(a, b) {
      if ("function" != typeof a)
        throw new TypeError(VALIDATOR_ARG_ERROR_MESSAGE);
      if (!!b && "string" != typeof b)
        throw new TypeError(MESSAGE_ARG_ERROR_MESSAGE);
    };
    var isRequiredIf2 = function isRequiredIf3(a, b, c) {
      return guardAgainstInvalidArgTypes(a, c), function(d, e, f) {
        for (var _len = arguments.length, g = Array(3 < _len ? _len - 3 : 0), _key = 3; _key < _len; _key++)
          g[_key - 3] = arguments[_key];
        return propIsRequired(b, d, e, f) ? propExists(d, e) ? a.apply(void 0, [d, e, f].concat(g)) : missingPropError(d, e, f, c) : a.apply(void 0, [d, e, f].concat(g));
      };
    };
    exports.default = isRequiredIf2;
  }
});

// node_modules/react-joyride/es/index.js
var import_react2 = __toESM(require_react());
var import_prop_types2 = __toESM(require_prop_types());

// node_modules/@gilbarbara/deep-equal/esm/helpers.js
function isOfType(type) {
  return function(value) {
    return typeof value === type;
  };
}
var isFunction = isOfType("function");
var isNull = function(value) {
  return value === null;
};
var isRegex = function(value) {
  return Object.prototype.toString.call(value).slice(8, -1) === "RegExp";
};
var isObject = function(value) {
  return !isUndefined(value) && !isNull(value) && (isFunction(value) || typeof value === "object");
};
var isUndefined = isOfType("undefined");

// node_modules/@gilbarbara/deep-equal/esm/index.js
var __values = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function equalArray(left, right) {
  var length = left.length;
  if (length !== right.length) {
    return false;
  }
  for (var index = length; index-- !== 0; ) {
    if (!equal(left[index], right[index])) {
      return false;
    }
  }
  return true;
}
function equalArrayBuffer(left, right) {
  if (left.byteLength !== right.byteLength) {
    return false;
  }
  var view1 = new DataView(left.buffer);
  var view2 = new DataView(right.buffer);
  var index = left.byteLength;
  while (index--) {
    if (view1.getUint8(index) !== view2.getUint8(index)) {
      return false;
    }
  }
  return true;
}
function equalMap(left, right) {
  var e_1, _a, e_2, _b;
  if (left.size !== right.size) {
    return false;
  }
  try {
    for (var _c = __values(left.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {
      var index = _d.value;
      if (!right.has(index[0])) {
        return false;
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_d && !_d.done && (_a = _c.return))
        _a.call(_c);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  try {
    for (var _e = __values(left.entries()), _f = _e.next(); !_f.done; _f = _e.next()) {
      var index = _f.value;
      if (!equal(index[1], right.get(index[0]))) {
        return false;
      }
    }
  } catch (e_2_1) {
    e_2 = { error: e_2_1 };
  } finally {
    try {
      if (_f && !_f.done && (_b = _e.return))
        _b.call(_e);
    } finally {
      if (e_2)
        throw e_2.error;
    }
  }
  return true;
}
function equalSet(left, right) {
  var e_3, _a;
  if (left.size !== right.size) {
    return false;
  }
  try {
    for (var _b = __values(left.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
      var index = _c.value;
      if (!right.has(index[0])) {
        return false;
      }
    }
  } catch (e_3_1) {
    e_3 = { error: e_3_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a = _b.return))
        _a.call(_b);
    } finally {
      if (e_3)
        throw e_3.error;
    }
  }
  return true;
}
function equal(left, right) {
  if (left === right) {
    return true;
  }
  if (left && isObject(left) && right && isObject(right)) {
    if (left.constructor !== right.constructor) {
      return false;
    }
    if (Array.isArray(left) && Array.isArray(right)) {
      return equalArray(left, right);
    }
    if (left instanceof Map && right instanceof Map) {
      return equalMap(left, right);
    }
    if (left instanceof Set && right instanceof Set) {
      return equalSet(left, right);
    }
    if (ArrayBuffer.isView(left) && ArrayBuffer.isView(right)) {
      return equalArrayBuffer(left, right);
    }
    if (isRegex(left) && isRegex(right)) {
      return left.source === right.source && left.flags === right.flags;
    }
    if (left.valueOf !== Object.prototype.valueOf) {
      return left.valueOf() === right.valueOf();
    }
    if (left.toString !== Object.prototype.toString) {
      return left.toString() === right.toString();
    }
    var leftKeys = Object.keys(left);
    var rightKeys = Object.keys(right);
    if (leftKeys.length !== rightKeys.length) {
      return false;
    }
    for (var index = leftKeys.length; index-- !== 0; ) {
      if (!Object.prototype.hasOwnProperty.call(right, leftKeys[index])) {
        return false;
      }
    }
    for (var index = leftKeys.length; index-- !== 0; ) {
      var key = leftKeys[index];
      if (key === "_owner" && left.$$typeof) {
        continue;
      }
      if (!equal(left[key], right[key])) {
        return false;
      }
    }
    return true;
  }
  if (Number.isNaN(left) && Number.isNaN(right)) {
    return true;
  }
  return left === right;
}

// node_modules/is-lite/esm/index.js
var DOM_PROPERTIES_TO_CHECK = [
  "innerHTML",
  "ownerDocument",
  "style",
  "attributes",
  "nodeValue"
];
var objectTypes = [
  "Array",
  "ArrayBuffer",
  "AsyncFunction",
  "AsyncGenerator",
  "AsyncGeneratorFunction",
  "Date",
  "Error",
  "Function",
  "Generator",
  "GeneratorFunction",
  "HTMLElement",
  "Map",
  "Object",
  "Promise",
  "RegExp",
  "Set",
  "WeakMap",
  "WeakSet"
];
var primitiveTypes = [
  "bigint",
  "boolean",
  "null",
  "number",
  "string",
  "symbol",
  "undefined"
];
function getObjectType(value) {
  var objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (/HTML\w+Element/.test(objectTypeName)) {
    return "HTMLElement";
  }
  if (isObjectType(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}
function isObjectOfType(type) {
  return function(value) {
    return getObjectType(value) === type;
  };
}
function isObjectType(name) {
  return objectTypes.includes(name);
}
function isOfType2(type) {
  return function(value) {
    return typeof value === type;
  };
}
function isPrimitiveType(name) {
  return primitiveTypes.includes(name);
}
function is(value) {
  if (value === null) {
    return "null";
  }
  switch (typeof value) {
    case "bigint":
      return "bigint";
    case "boolean":
      return "boolean";
    case "number":
      return "number";
    case "string":
      return "string";
    case "symbol":
      return "symbol";
    case "undefined":
      return "undefined";
    default:
  }
  if (is.array(value)) {
    return "Array";
  }
  if (is.plainFunction(value)) {
    return "Function";
  }
  var tagType = getObjectType(value);
  if (tagType) {
    return tagType;
  }
  return "Object";
}
is.array = Array.isArray;
is.arrayOf = function(target, predicate) {
  if (!is.array(target) && !is.function(predicate)) {
    return false;
  }
  return target.every(function(d) {
    return predicate(d);
  });
};
is.asyncGeneratorFunction = function(value) {
  return getObjectType(value) === "AsyncGeneratorFunction";
};
is.asyncFunction = isObjectOfType("AsyncFunction");
is.bigint = isOfType2("bigint");
is.boolean = function(value) {
  return value === true || value === false;
};
is.date = isObjectOfType("Date");
is.defined = function(value) {
  return !is.undefined(value);
};
is.domElement = function(value) {
  return is.object(value) && !is.plainObject(value) && value.nodeType === 1 && is.string(value.nodeName) && DOM_PROPERTIES_TO_CHECK.every(function(property) {
    return property in value;
  });
};
is.empty = function(value) {
  return is.string(value) && value.length === 0 || is.array(value) && value.length === 0 || is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length === 0 || is.set(value) && value.size === 0 || is.map(value) && value.size === 0;
};
is.error = isObjectOfType("Error");
is.function = isOfType2("function");
is.generator = function(value) {
  return is.iterable(value) && is.function(value.next) && is.function(value.throw);
};
is.generatorFunction = isObjectOfType("GeneratorFunction");
is.instanceOf = function(instance, class_) {
  if (!instance || !class_) {
    return false;
  }
  return Object.getPrototypeOf(instance) === class_.prototype;
};
is.iterable = function(value) {
  return !is.nullOrUndefined(value) && is.function(value[Symbol.iterator]);
};
is.map = isObjectOfType("Map");
is.nan = function(value) {
  return Number.isNaN(value);
};
is.null = function(value) {
  return value === null;
};
is.nullOrUndefined = function(value) {
  return is.null(value) || is.undefined(value);
};
is.number = function(value) {
  return isOfType2("number")(value) && !is.nan(value);
};
is.numericString = function(value) {
  return is.string(value) && value.length > 0 && !Number.isNaN(Number(value));
};
is.object = function(value) {
  return !is.nullOrUndefined(value) && (is.function(value) || typeof value === "object");
};
is.oneOf = function(target, value) {
  if (!is.array(target)) {
    return false;
  }
  return target.indexOf(value) > -1;
};
is.plainFunction = isObjectOfType("Function");
is.plainObject = function(value) {
  if (getObjectType(value) !== "Object") {
    return false;
  }
  var prototype = Object.getPrototypeOf(value);
  return prototype === null || prototype === Object.getPrototypeOf({});
};
is.primitive = function(value) {
  return is.null(value) || isPrimitiveType(typeof value);
};
is.promise = isObjectOfType("Promise");
is.propertyOf = function(target, key, predicate) {
  if (!is.object(target) || !key) {
    return false;
  }
  var value = target[key];
  if (is.function(predicate)) {
    return predicate(value);
  }
  return is.defined(value);
};
is.regexp = isObjectOfType("RegExp");
is.set = isObjectOfType("Set");
is.string = isOfType2("string");
is.symbol = isOfType2("symbol");
is.undefined = isOfType2("undefined");
is.weakMap = isObjectOfType("WeakMap");
is.weakSet = isObjectOfType("WeakSet");
var esm_default = is;

// node_modules/tree-changes/esm/helpers.js
function canHaveLength() {
  var arguments_ = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    arguments_[_i] = arguments[_i];
  }
  return arguments_.every(function(d) {
    return esm_default.string(d) || esm_default.array(d) || esm_default.plainObject(d);
  });
}
function checkEquality(left, right, value) {
  if (!isSameType(left, right)) {
    return false;
  }
  if ([left, right].every(esm_default.array)) {
    return !left.some(hasValue(value)) && right.some(hasValue(value));
  }
  if ([left, right].every(esm_default.plainObject)) {
    return !Object.entries(left).some(hasEntry(value)) && Object.entries(right).some(hasEntry(value));
  }
  return right === value;
}
function compareNumbers(previousData, data, options) {
  var actual = options.actual, key = options.key, previous = options.previous, type = options.type;
  var left = nested(previousData, key);
  var right = nested(data, key);
  var changed = [left, right].every(esm_default.number) && (type === "increased" ? left < right : left > right);
  if (!esm_default.undefined(actual)) {
    changed = changed && right === actual;
  }
  if (!esm_default.undefined(previous)) {
    changed = changed && left === previous;
  }
  return changed;
}
function compareValues(previousData, data, options) {
  var key = options.key, type = options.type, value = options.value;
  var left = nested(previousData, key);
  var right = nested(data, key);
  var primary = type === "added" ? left : right;
  var secondary = type === "added" ? right : left;
  if (!esm_default.nullOrUndefined(value)) {
    if (esm_default.defined(primary)) {
      if (esm_default.array(primary) || esm_default.plainObject(primary)) {
        return checkEquality(primary, secondary, value);
      }
    } else {
      return equal(secondary, value);
    }
    return false;
  }
  if ([left, right].every(esm_default.array)) {
    return !secondary.every(isEqualPredicate(primary));
  }
  if ([left, right].every(esm_default.plainObject)) {
    return hasExtraKeys(Object.keys(primary), Object.keys(secondary));
  }
  return ![left, right].every(function(d) {
    return esm_default.primitive(d) && esm_default.defined(d);
  }) && (type === "added" ? !esm_default.defined(left) && esm_default.defined(right) : esm_default.defined(left) && !esm_default.defined(right));
}
function getIterables(previousData, data, _a) {
  var _b = _a === void 0 ? {} : _a, key = _b.key;
  var left = nested(previousData, key);
  var right = nested(data, key);
  if (!isSameType(left, right)) {
    throw new TypeError("Inputs have different types");
  }
  if (!canHaveLength(left, right)) {
    throw new TypeError("Inputs don't have length");
  }
  if ([left, right].every(esm_default.plainObject)) {
    left = Object.keys(left);
    right = Object.keys(right);
  }
  return [left, right];
}
function hasEntry(input) {
  return function(_a) {
    var key = _a[0], value = _a[1];
    if (esm_default.array(input)) {
      return equal(input, value) || input.some(function(d) {
        return equal(d, value) || esm_default.array(value) && isEqualPredicate(value)(d);
      });
    }
    if (esm_default.plainObject(input) && input[key]) {
      return !!input[key] && equal(input[key], value);
    }
    return equal(input, value);
  };
}
function hasExtraKeys(left, right) {
  return right.some(function(d) {
    return !left.includes(d);
  });
}
function hasValue(input) {
  return function(value) {
    if (esm_default.array(input)) {
      return input.some(function(d) {
        return equal(d, value) || esm_default.array(value) && isEqualPredicate(value)(d);
      });
    }
    return equal(input, value);
  };
}
function includesOrEqualsTo(previousValue, value) {
  return esm_default.array(previousValue) ? previousValue.some(function(d) {
    return equal(d, value);
  }) : equal(previousValue, value);
}
function isEqualPredicate(data) {
  return function(value) {
    return data.some(function(d) {
      return equal(d, value);
    });
  };
}
function isSameType() {
  var arguments_ = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    arguments_[_i] = arguments[_i];
  }
  return arguments_.every(esm_default.array) || arguments_.every(esm_default.number) || arguments_.every(esm_default.plainObject) || arguments_.every(esm_default.string);
}
function nested(data, property) {
  if (esm_default.plainObject(data) || esm_default.array(data)) {
    if (esm_default.string(property)) {
      var props = property.split(".");
      return props.reduce(function(acc, d) {
        return acc && acc[d];
      }, data);
    }
    if (esm_default.number(property)) {
      return data[property];
    }
    return data;
  }
  return data;
}

// node_modules/tree-changes/esm/index.js
function treeChanges(previousData, data) {
  if ([previousData, data].some(esm_default.nullOrUndefined)) {
    throw new Error("Missing required parameters");
  }
  if (![previousData, data].every(function(d) {
    return esm_default.plainObject(d) || esm_default.array(d);
  })) {
    throw new Error("Expected plain objects or array");
  }
  var added = function(key, value) {
    try {
      return compareValues(previousData, data, { key, type: "added", value });
    } catch (_a) {
      return false;
    }
  };
  var changed = function(key, actual, previous) {
    try {
      var left = nested(previousData, key);
      var right = nested(data, key);
      var hasActual = esm_default.defined(actual);
      var hasPrevious = esm_default.defined(previous);
      if (hasActual || hasPrevious) {
        var leftComparator = hasPrevious ? includesOrEqualsTo(previous, left) : !includesOrEqualsTo(actual, left);
        var rightComparator = includesOrEqualsTo(actual, right);
        return leftComparator && rightComparator;
      }
      if ([left, right].every(esm_default.array) || [left, right].every(esm_default.plainObject)) {
        return !equal(left, right);
      }
      return left !== right;
    } catch (_a) {
      return false;
    }
  };
  var changedFrom = function(key, previous, actual) {
    if (!esm_default.defined(key)) {
      return false;
    }
    try {
      var left = nested(previousData, key);
      var right = nested(data, key);
      var hasActual = esm_default.defined(actual);
      return includesOrEqualsTo(previous, left) && (hasActual ? includesOrEqualsTo(actual, right) : !hasActual);
    } catch (_a) {
      return false;
    }
  };
  var changedTo = function(key, actual) {
    if (!esm_default.defined(key)) {
      return false;
    }
    if (true) {
      console.warn("`changedTo` is deprecated! Replace it with `change`");
    }
    return changed(key, actual);
  };
  var decreased = function(key, actual, previous) {
    if (!esm_default.defined(key)) {
      return false;
    }
    try {
      return compareNumbers(previousData, data, { key, actual, previous, type: "decreased" });
    } catch (_a) {
      return false;
    }
  };
  var emptied = function(key) {
    try {
      var _a = getIterables(previousData, data, { key }), left = _a[0], right = _a[1];
      return !!left.length && !right.length;
    } catch (_b) {
      return false;
    }
  };
  var filled = function(key) {
    try {
      var _a = getIterables(previousData, data, { key }), left = _a[0], right = _a[1];
      return !left.length && !!right.length;
    } catch (_b) {
      return false;
    }
  };
  var increased = function(key, actual, previous) {
    if (!esm_default.defined(key)) {
      return false;
    }
    try {
      return compareNumbers(previousData, data, { key, actual, previous, type: "increased" });
    } catch (_a) {
      return false;
    }
  };
  var removed = function(key, value) {
    try {
      return compareValues(previousData, data, { key, type: "removed", value });
    } catch (_a) {
      return false;
    }
  };
  return { added, changed, changedFrom, changedTo, decreased, emptied, filled, increased, removed };
}

// node_modules/react-joyride/node_modules/is-lite/dist/index.mjs
var DOM_PROPERTIES_TO_CHECK2 = [
  "innerHTML",
  "ownerDocument",
  "style",
  "attributes",
  "nodeValue"
];
var objectTypes2 = [
  "Array",
  "ArrayBuffer",
  "AsyncFunction",
  "AsyncGenerator",
  "AsyncGeneratorFunction",
  "Date",
  "Error",
  "Function",
  "Generator",
  "GeneratorFunction",
  "HTMLElement",
  "Map",
  "Object",
  "Promise",
  "RegExp",
  "Set",
  "WeakMap",
  "WeakSet"
];
var primitiveTypes2 = [
  "bigint",
  "boolean",
  "null",
  "number",
  "string",
  "symbol",
  "undefined"
];
function getObjectType2(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (/HTML\w+Element/.test(objectTypeName)) {
    return "HTMLElement";
  }
  if (isObjectType2(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}
function isObjectOfType2(type) {
  return (value) => getObjectType2(value) === type;
}
function isObjectType2(name) {
  return objectTypes2.includes(name);
}
function isOfType3(type) {
  return (value) => typeof value === type;
}
function isPrimitiveType2(name) {
  return primitiveTypes2.includes(name);
}
function is2(value) {
  if (value === null) {
    return "null";
  }
  switch (typeof value) {
    case "bigint":
      return "bigint";
    case "boolean":
      return "boolean";
    case "number":
      return "number";
    case "string":
      return "string";
    case "symbol":
      return "symbol";
    case "undefined":
      return "undefined";
    default:
  }
  if (is2.array(value)) {
    return "Array";
  }
  if (is2.plainFunction(value)) {
    return "Function";
  }
  const tagType = getObjectType2(value);
  if (tagType) {
    return tagType;
  }
  return "Object";
}
is2.array = Array.isArray;
is2.arrayOf = (target, predicate) => {
  if (!is2.array(target) && !is2.function(predicate)) {
    return false;
  }
  return target.every((d) => predicate(d));
};
is2.asyncGeneratorFunction = (value) => getObjectType2(value) === "AsyncGeneratorFunction";
is2.asyncFunction = isObjectOfType2("AsyncFunction");
is2.bigint = isOfType3("bigint");
is2.boolean = (value) => {
  return value === true || value === false;
};
is2.date = isObjectOfType2("Date");
is2.defined = (value) => !is2.undefined(value);
is2.domElement = (value) => {
  return is2.object(value) && !is2.plainObject(value) && value.nodeType === 1 && is2.string(value.nodeName) && DOM_PROPERTIES_TO_CHECK2.every((property) => property in value);
};
is2.empty = (value) => {
  return is2.string(value) && value.length === 0 || is2.array(value) && value.length === 0 || is2.object(value) && !is2.map(value) && !is2.set(value) && Object.keys(value).length === 0 || is2.set(value) && value.size === 0 || is2.map(value) && value.size === 0;
};
is2.error = isObjectOfType2("Error");
is2.function = isOfType3("function");
is2.generator = (value) => {
  return is2.iterable(value) && is2.function(value.next) && is2.function(value.throw);
};
is2.generatorFunction = isObjectOfType2("GeneratorFunction");
is2.instanceOf = (instance, class_) => {
  if (!instance || !class_) {
    return false;
  }
  return Object.getPrototypeOf(instance) === class_.prototype;
};
is2.iterable = (value) => {
  return !is2.nullOrUndefined(value) && is2.function(value[Symbol.iterator]);
};
is2.map = isObjectOfType2("Map");
is2.nan = (value) => {
  return Number.isNaN(value);
};
is2.null = (value) => {
  return value === null;
};
is2.nullOrUndefined = (value) => {
  return is2.null(value) || is2.undefined(value);
};
is2.number = (value) => {
  return isOfType3("number")(value) && !is2.nan(value);
};
is2.numericString = (value) => {
  return is2.string(value) && value.length > 0 && !Number.isNaN(Number(value));
};
is2.object = (value) => {
  return !is2.nullOrUndefined(value) && (is2.function(value) || typeof value === "object");
};
is2.oneOf = (target, value) => {
  if (!is2.array(target)) {
    return false;
  }
  return target.indexOf(value) > -1;
};
is2.plainFunction = isObjectOfType2("Function");
is2.plainObject = (value) => {
  if (getObjectType2(value) !== "Object") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return prototype === null || prototype === Object.getPrototypeOf({});
};
is2.primitive = (value) => is2.null(value) || isPrimitiveType2(typeof value);
is2.promise = isObjectOfType2("Promise");
is2.propertyOf = (target, key, predicate) => {
  if (!is2.object(target) || !key) {
    return false;
  }
  const value = target[key];
  if (is2.function(predicate)) {
    return predicate(value);
  }
  return is2.defined(value);
};
is2.regexp = isObjectOfType2("RegExp");
is2.set = isObjectOfType2("Set");
is2.string = isOfType3("string");
is2.symbol = isOfType3("symbol");
is2.undefined = isOfType3("undefined");
is2.weakMap = isObjectOfType2("WeakMap");
is2.weakSet = isObjectOfType2("WeakSet");
var src_default = is2;

// node_modules/react-joyride/es/index.js
var import_react_dom2 = __toESM(require_react_dom());
var import_exenv2 = __toESM(require_exenv());
var import_scroll = __toESM(require_scroll());
var import_scrollparent = __toESM(require_scrollparent());
var import_react_is = __toESM(require_react_is());
var import_deepmerge2 = __toESM(require_cjs());

// node_modules/react-floater/es/index.js
var import_react = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
var import_react_proptype_conditional_require = __toESM(require_isRequiredIf());

// node_modules/react-floater/node_modules/popper.js/dist/esm/popper.js
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && typeof navigator !== "undefined";
var timeoutDuration = function() {
  var longerTimeoutBrowsers = ["Edge", "Trident", "Firefox"];
  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      return 1;
    }
  }
  return 0;
}();
function microtaskDebounce(fn) {
  var called = false;
  return function() {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function() {
      called = false;
      fn();
    });
  };
}
function taskDebounce(fn) {
  var scheduled = false;
  return function() {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function() {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}
var supportsMicroTasks = isBrowser && window.Promise;
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;
function isFunction2(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === "[object Function]";
}
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  var window2 = element.ownerDocument.defaultView;
  var css = window2.getComputedStyle(element, null);
  return property ? css[property] : css;
}
function getParentNode(element) {
  if (element.nodeName === "HTML") {
    return element;
  }
  return element.parentNode || element.host;
}
function getScrollParent(element) {
  if (!element) {
    return document.body;
  }
  switch (element.nodeName) {
    case "HTML":
    case "BODY":
      return element.ownerDocument.body;
    case "#document":
      return element.body;
  }
  var _getStyleComputedProp = getStyleComputedProperty(element), overflow = _getStyleComputedProp.overflow, overflowX = _getStyleComputedProp.overflowX, overflowY = _getStyleComputedProp.overflowY;
  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }
  return getScrollParent(getParentNode(element));
}
function getReferenceNode(reference) {
  return reference && reference.referenceNode ? reference.referenceNode : reference;
}
var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);
function isIE(version) {
  if (version === 11) {
    return isIE11;
  }
  if (version === 10) {
    return isIE10;
  }
  return isIE11 || isIE10;
}
function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }
  var noOffsetParent = isIE(10) ? document.body : null;
  var offsetParent = element.offsetParent || null;
  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }
  var nodeName = offsetParent && offsetParent.nodeName;
  if (!nodeName || nodeName === "BODY" || nodeName === "HTML") {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  }
  if (["TH", "TD", "TABLE"].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, "position") === "static") {
    return getOffsetParent(offsetParent);
  }
  return offsetParent;
}
function isOffsetContainer(element) {
  var nodeName = element.nodeName;
  if (nodeName === "BODY") {
    return false;
  }
  return nodeName === "HTML" || getOffsetParent(element.firstElementChild) === element;
}
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }
  return node;
}
function findCommonOffsetParent(element1, element2) {
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;
  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }
    return getOffsetParent(commonAncestorContainer);
  }
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "top";
  var upperSide = side === "top" ? "scrollTop" : "scrollLeft";
  var nodeName = element.nodeName;
  if (nodeName === "BODY" || nodeName === "HTML") {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }
  return element[upperSide];
}
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var scrollTop = getScroll(element, "top");
  var scrollLeft = getScroll(element, "left");
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}
function getBordersSize(styles, axis) {
  var sideA = axis === "x" ? "Left" : "Top";
  var sideB = sideA === "Left" ? "Right" : "Bottom";
  return parseFloat(styles["border" + sideA + "Width"]) + parseFloat(styles["border" + sideB + "Width"]);
}
function getSize(axis, body, html, computedStyle) {
  return Math.max(body["offset" + axis], body["scroll" + axis], html["client" + axis], html["offset" + axis], html["scroll" + axis], isIE(10) ? parseInt(html["offset" + axis]) + parseInt(computedStyle["margin" + (axis === "Height" ? "Top" : "Left")]) + parseInt(computedStyle["margin" + (axis === "Height" ? "Bottom" : "Right")]) : 0);
}
function getWindowSizes(document2) {
  var body = document2.body;
  var html = document2.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);
  return {
    height: getSize("Height", body, html, computedStyle),
    width: getSize("Width", body, html, computedStyle)
  };
}
var classCallCheck = function(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
var createClass = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
var defineProperty = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _extends = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}
function getBoundingClientRect(element) {
  var rect = {};
  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, "top");
      var scrollLeft = getScroll(element, "left");
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {
  }
  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };
  var sizes = element.nodeName === "HTML" ? getWindowSizes(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.width;
  var height = sizes.height || element.clientHeight || result.height;
  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, "x");
    vertScrollbar -= getBordersSize(styles, "y");
    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }
  return getClientRect(result);
}
function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var isIE102 = isIE(10);
  var isHTML = parent.nodeName === "HTML";
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent2 = getScrollParent(children);
  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth);
  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }
  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;
  if (!isIE102 && isHTML) {
    var marginTop = parseFloat(styles.marginTop);
    var marginLeft = parseFloat(styles.marginLeft);
    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }
  if (isIE102 && !fixedPosition ? parent.contains(scrollParent2) : parent === scrollParent2 && scrollParent2.nodeName !== "BODY") {
    offsets = includeScroll(offsets, parent);
  }
  return offsets;
}
function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);
  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, "left") : 0;
  var offset2 = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width,
    height
  };
  return getClientRect(offset2);
}
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === "BODY" || nodeName === "HTML") {
    return false;
  }
  if (getStyleComputedProperty(element, "position") === "fixed") {
    return true;
  }
  var parentNode = getParentNode(element);
  if (!parentNode) {
    return false;
  }
  return isFixed(parentNode);
}
function getFixedPositionOffsetParent(element) {
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }
  var el = element.parentElement;
  while (el && getStyleComputedProperty(el, "transform") === "none") {
    el = el.parentElement;
  }
  return el || document.documentElement;
}
function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  var boundaries = { top: 0, left: 0 };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
  if (boundariesElement === "viewport") {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    var boundariesNode = void 0;
    if (boundariesElement === "scrollParent") {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === "BODY") {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === "window") {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }
    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);
    if (boundariesNode.nodeName === "HTML" && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper.ownerDocument), height = _getWindowSizes.height, width = _getWindowSizes.width;
      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      boundaries = offsets;
    }
  }
  padding = padding || 0;
  var isPaddingNumber = typeof padding === "number";
  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
  return boundaries;
}
function getArea(_ref) {
  var width = _ref.width, height = _ref.height;
  return width * height;
}
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
  if (placement.indexOf("auto") === -1) {
    return placement;
  }
  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };
  var sortedAreas = Object.keys(rects).map(function(key) {
    return _extends({
      key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function(a, b) {
    return b.area - a.area;
  });
  var filteredAreas = sortedAreas.filter(function(_ref2) {
    var width = _ref2.width, height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });
  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
  var variation = placement.split("-")[1];
  return computedPlacement + (variation ? "-" + variation : "");
}
function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}
function getOuterSizes(element) {
  var window2 = element.ownerDocument.defaultView;
  var styles = window2.getComputedStyle(element);
  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}
function getOppositePlacement(placement) {
  var hash = { left: "right", right: "left", bottom: "top", top: "bottom" };
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split("-")[0];
  var popperRect = getOuterSizes(popper);
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };
  var isHoriz = ["right", "left"].indexOf(placement) !== -1;
  var mainSide = isHoriz ? "top" : "left";
  var secondarySide = isHoriz ? "left" : "top";
  var measurement = isHoriz ? "height" : "width";
  var secondaryMeasurement = !isHoriz ? "height" : "width";
  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }
  return popperOffsets;
}
function find(arr, check) {
  if (Array.prototype.find) {
    return arr.find(check);
  }
  return arr.filter(check)[0];
}
function findIndex(arr, prop, value) {
  if (Array.prototype.findIndex) {
    return arr.findIndex(function(cur) {
      return cur[prop] === value;
    });
  }
  var match = find(arr, function(obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}
function runModifiers(modifiers2, data, ends) {
  var modifiersToRun = ends === void 0 ? modifiers2 : modifiers2.slice(0, findIndex(modifiers2, "name", ends));
  modifiersToRun.forEach(function(modifier) {
    if (modifier["function"]) {
      console.warn("`modifier.function` is deprecated, use `modifier.fn`!");
    }
    var fn = modifier["function"] || modifier.fn;
    if (modifier.enabled && isFunction2(fn)) {
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);
      data = fn(data, modifier);
    }
  });
  return data;
}
function update() {
  if (this.state.isDestroyed) {
    return;
  }
  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);
  data.originalPlacement = data.placement;
  data.positionFixed = this.options.positionFixed;
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
  data.offsets.popper.position = this.options.positionFixed ? "fixed" : "absolute";
  data = runModifiers(this.modifiers, data);
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}
function isModifierEnabled(modifiers2, modifierName) {
  return modifiers2.some(function(_ref) {
    var name = _ref.name, enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}
function getSupportedPropertyName(property) {
  var prefixes = [false, "ms", "Webkit", "Moz", "O"];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);
  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? "" + prefix + upperProp : property;
    if (typeof document.body.style[toCheck] !== "undefined") {
      return toCheck;
    }
  }
  return null;
}
function destroy() {
  this.state.isDestroyed = true;
  if (isModifierEnabled(this.modifiers, "applyStyle")) {
    this.popper.removeAttribute("x-placement");
    this.popper.style.position = "";
    this.popper.style.top = "";
    this.popper.style.left = "";
    this.popper.style.right = "";
    this.popper.style.bottom = "";
    this.popper.style.willChange = "";
    this.popper.style[getSupportedPropertyName("transform")] = "";
  }
  this.disableEventListeners();
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}
function attachToScrollParents(scrollParent2, event, callback, scrollParents) {
  var isBody = scrollParent2.nodeName === "BODY";
  var target = isBody ? scrollParent2.ownerDocument.defaultView : scrollParent2;
  target.addEventListener(event, callback, { passive: true });
  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}
function setupEventListeners(reference, options, state, updateBound) {
  state.updateBound = updateBound;
  getWindow(reference).addEventListener("resize", state.updateBound, { passive: true });
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, "scroll", state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;
  return state;
}
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}
function removeEventListeners(reference, state) {
  getWindow(reference).removeEventListener("resize", state.updateBound);
  state.scrollParents.forEach(function(target) {
    target.removeEventListener("scroll", state.updateBound);
  });
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}
function isNumeric(n) {
  return n !== "" && !isNaN(parseFloat(n)) && isFinite(n);
}
function setStyles(element, styles) {
  Object.keys(styles).forEach(function(prop) {
    var unit = "";
    if (["width", "height", "top", "right", "bottom", "left"].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = "px";
    }
    element.style[prop] = styles[prop] + unit;
  });
}
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function(prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}
function applyStyle(data) {
  setStyles(data.instance.popper, data.styles);
  setAttributes(data.instance.popper, data.attributes);
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }
  return data;
}
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
  popper.setAttribute("x-placement", placement);
  setStyles(popper, { position: options.positionFixed ? "fixed" : "absolute" });
  return options;
}
function getRoundedOffsets(data, shouldRound) {
  var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
  var round = Math.round, floor = Math.floor;
  var noRound = function noRound2(v) {
    return v;
  };
  var referenceWidth = round(reference.width);
  var popperWidth = round(popper.width);
  var isVertical = ["left", "right"].indexOf(data.placement) !== -1;
  var isVariation = data.placement.indexOf("-") !== -1;
  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
  var verticalToInteger = !shouldRound ? noRound : round;
  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
    top: verticalToInteger(popper.top),
    bottom: verticalToInteger(popper.bottom),
    right: horizontalToInteger(popper.right)
  };
}
var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);
function computeStyle(data, options) {
  var x = options.x, y = options.y;
  var popper = data.offsets.popper;
  var legacyGpuAccelerationOption = find(data.instance.modifiers, function(modifier) {
    return modifier.name === "applyStyle";
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== void 0) {
    console.warn("WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!");
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== void 0 ? legacyGpuAccelerationOption : options.gpuAcceleration;
  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);
  var styles = {
    position: popper.position
  };
  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);
  var sideA = x === "bottom" ? "top" : "bottom";
  var sideB = y === "right" ? "left" : "right";
  var prefixedProperty = getSupportedPropertyName("transform");
  var left = void 0, top = void 0;
  if (sideA === "bottom") {
    if (offsetParent.nodeName === "HTML") {
      top = -offsetParent.clientHeight + offsets.bottom;
    } else {
      top = -offsetParentRect.height + offsets.bottom;
    }
  } else {
    top = offsets.top;
  }
  if (sideB === "right") {
    if (offsetParent.nodeName === "HTML") {
      left = -offsetParent.clientWidth + offsets.right;
    } else {
      left = -offsetParentRect.width + offsets.right;
    }
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = "translate3d(" + left + "px, " + top + "px, 0)";
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = "transform";
  } else {
    var invertTop = sideA === "bottom" ? -1 : 1;
    var invertLeft = sideB === "right" ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ", " + sideB;
  }
  var attributes = {
    "x-placement": data.placement
  };
  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);
  return data;
}
function isModifierRequired(modifiers2, requestingName, requestedName) {
  var requesting = find(modifiers2, function(_ref) {
    var name = _ref.name;
    return name === requestingName;
  });
  var isRequired = !!requesting && modifiers2.some(function(modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });
  if (!isRequired) {
    var _requesting = "`" + requestingName + "`";
    var requested = "`" + requestedName + "`";
    console.warn(requested + " modifier is required by " + _requesting + " modifier in order to work, be sure to include it before " + _requesting + "!");
  }
  return isRequired;
}
function arrow(data, options) {
  var _data$offsets$arrow;
  if (!isModifierRequired(data.instance.modifiers, "arrow", "keepTogether")) {
    return data;
  }
  var arrowElement = options.element;
  if (typeof arrowElement === "string") {
    arrowElement = data.instance.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return data;
    }
  } else {
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn("WARNING: `arrow.element` must be child of its popper element!");
      return data;
    }
  }
  var placement = data.placement.split("-")[0];
  var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
  var isVertical = ["left", "right"].indexOf(placement) !== -1;
  var len = isVertical ? "height" : "width";
  var sideCapitalized = isVertical ? "Top" : "Left";
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? "left" : "top";
  var opSide = isVertical ? "bottom" : "right";
  var arrowElementSize = getOuterSizes(arrowElement)[len];
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }
  data.offsets.popper = getClientRect(data.offsets.popper);
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;
  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css["margin" + sideCapitalized]);
  var popperBorderSide = parseFloat(css["border" + sideCapitalized + "Width"]);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ""), _data$offsets$arrow);
  return data;
}
function getOppositeVariation(variation) {
  if (variation === "end") {
    return "start";
  } else if (variation === "start") {
    return "end";
  }
  return variation;
}
var placements = ["auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start"];
var validPlacements = placements.slice(3);
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}
var BEHAVIORS = {
  FLIP: "flip",
  CLOCKWISE: "clockwise",
  COUNTERCLOCKWISE: "counterclockwise"
};
function flip(data, options) {
  if (isModifierEnabled(data.instance.modifiers, "inner")) {
    return data;
  }
  if (data.flipped && data.placement === data.originalPlacement) {
    return data;
  }
  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
  var placement = data.placement.split("-")[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split("-")[1] || "";
  var flipOrder = [];
  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }
  flipOrder.forEach(function(step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }
    placement = data.placement.split("-")[0];
    placementOpposite = getOppositePlacement(placement);
    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;
    var floor = Math.floor;
    var overlapsRef = placement === "left" && floor(popperOffsets.right) > floor(refOffsets.left) || placement === "right" && floor(popperOffsets.left) < floor(refOffsets.right) || placement === "top" && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === "bottom" && floor(popperOffsets.top) < floor(refOffsets.bottom);
    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
    var overflowsBoundaries = placement === "left" && overflowsLeft || placement === "right" && overflowsRight || placement === "top" && overflowsTop || placement === "bottom" && overflowsBottom;
    var isVertical = ["top", "bottom"].indexOf(placement) !== -1;
    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === "start" && overflowsLeft || isVertical && variation === "end" && overflowsRight || !isVertical && variation === "start" && overflowsTop || !isVertical && variation === "end" && overflowsBottom);
    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === "start" && overflowsRight || isVertical && variation === "end" && overflowsLeft || !isVertical && variation === "start" && overflowsBottom || !isVertical && variation === "end" && overflowsTop);
    var flippedVariation = flippedVariationByRef || flippedVariationByContent;
    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      data.flipped = true;
      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }
      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }
      data.placement = placement + (variation ? "-" + variation : "");
      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
      data = runModifiers(data.instance.modifiers, data, "flip");
    }
  });
  return data;
}
function keepTogether(data) {
  var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
  var placement = data.placement.split("-")[0];
  var floor = Math.floor;
  var isVertical = ["top", "bottom"].indexOf(placement) !== -1;
  var side = isVertical ? "right" : "bottom";
  var opSide = isVertical ? "left" : "top";
  var measurement = isVertical ? "width" : "height";
  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }
  return data;
}
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];
  if (!value) {
    return str;
  }
  if (unit.indexOf("%") === 0) {
    var element = void 0;
    switch (unit) {
      case "%p":
        element = popperOffsets;
        break;
      case "%":
      case "%r":
      default:
        element = referenceOffsets;
    }
    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === "vh" || unit === "vw") {
    var size = void 0;
    if (unit === "vh") {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    return value;
  }
}
function parseOffset(offset2, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];
  var useHeight = ["right", "left"].indexOf(basePlacement) !== -1;
  var fragments = offset2.split(/(\+|\-)/).map(function(frag) {
    return frag.trim();
  });
  var divider = fragments.indexOf(find(fragments, function(frag) {
    return frag.search(/,|\s/) !== -1;
  }));
  if (fragments[divider] && fragments[divider].indexOf(",") === -1) {
    console.warn("Offsets separated by white space(s) are deprecated, use a comma (,) instead.");
  }
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];
  ops = ops.map(function(op, index) {
    var measurement = (index === 1 ? !useHeight : useHeight) ? "height" : "width";
    var mergeWithPrevious = false;
    return op.reduce(function(a, b) {
      if (a[a.length - 1] === "" && ["+", "-"].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, []).map(function(str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });
  ops.forEach(function(op, index) {
    op.forEach(function(frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === "-" ? -1 : 1);
      }
    });
  });
  return offsets;
}
function offset(data, _ref) {
  var offset2 = _ref.offset;
  var placement = data.placement, _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
  var basePlacement = placement.split("-")[0];
  var offsets = void 0;
  if (isNumeric(+offset2)) {
    offsets = [+offset2, 0];
  } else {
    offsets = parseOffset(offset2, popper, reference, basePlacement);
  }
  if (basePlacement === "left") {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === "right") {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === "top") {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === "bottom") {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }
  data.popper = popper;
  return data;
}
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }
  var transformProp = getSupportedPropertyName("transform");
  var popperStyles = data.instance.popper.style;
  var top = popperStyles.top, left = popperStyles.left, transform = popperStyles[transformProp];
  popperStyles.top = "";
  popperStyles.left = "";
  popperStyles[transformProp] = "";
  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);
  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;
  options.boundaries = boundaries;
  var order = options.priority;
  var popper = data.offsets.popper;
  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === "right" ? "left" : "top";
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === "right" ? popper.width : popper.height));
      }
      return defineProperty({}, mainSide, value);
    }
  };
  order.forEach(function(placement) {
    var side = ["left", "top"].indexOf(placement) !== -1 ? "primary" : "secondary";
    popper = _extends({}, popper, check[side](placement));
  });
  data.offsets.popper = popper;
  return data;
}
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split("-")[0];
  var shiftvariation = placement.split("-")[1];
  if (shiftvariation) {
    var _data$offsets = data.offsets, reference = _data$offsets.reference, popper = _data$offsets.popper;
    var isVertical = ["bottom", "top"].indexOf(basePlacement) !== -1;
    var side = isVertical ? "left" : "top";
    var measurement = isVertical ? "width" : "height";
    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };
    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }
  return data;
}
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, "hide", "preventOverflow")) {
    return data;
  }
  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function(modifier) {
    return modifier.name === "preventOverflow";
  }).boundaries;
  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    if (data.hide === true) {
      return data;
    }
    data.hide = true;
    data.attributes["x-out-of-boundaries"] = "";
  } else {
    if (data.hide === false) {
      return data;
    }
    data.hide = false;
    data.attributes["x-out-of-boundaries"] = false;
  }
  return data;
}
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split("-")[0];
  var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
  var isHoriz = ["left", "right"].indexOf(basePlacement) !== -1;
  var subtractLength = ["top", "left"].indexOf(basePlacement) === -1;
  popper[isHoriz ? "left" : "top"] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? "width" : "height"] : 0);
  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);
  return data;
}
var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: shift
  },
  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },
  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries"  or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ["left", "right", "top", "bottom"],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: "scrollParent"
  },
  /**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },
  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: arrow,
    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: "[x-arrow]"
  },
  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: flip,
    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
    behavior: "flip",
    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
    boundariesElement: "viewport",
    /**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariations: false,
    /**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariationsByContent: false
  },
  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,
    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,
    /** @prop {ModifierFn} */
    fn: inner
  },
  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: hide
  },
  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: computeStyle,
    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: "bottom",
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: "right"
  },
  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: void 0
  }
};
var Defaults = {
  /**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
  placement: "bottom",
  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,
  /**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,
  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,
  /**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {
  },
  /**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {
  },
  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
  modifiers
};
var Popper = function() {
  function Popper2(reference, popper) {
    var _this = this;
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    classCallCheck(this, Popper2);
    this.scheduleUpdate = function() {
      return requestAnimationFrame(_this.update);
    };
    this.update = debounce(this.update.bind(this));
    this.options = _extends({}, Popper2.Defaults, options);
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };
    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper;
    this.options.modifiers = {};
    Object.keys(_extends({}, Popper2.Defaults.modifiers, options.modifiers)).forEach(function(name) {
      _this.options.modifiers[name] = _extends({}, Popper2.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });
    this.modifiers = Object.keys(this.options.modifiers).map(function(name) {
      return _extends({
        name
      }, _this.options.modifiers[name]);
    }).sort(function(a, b) {
      return a.order - b.order;
    });
    this.modifiers.forEach(function(modifierOptions) {
      if (modifierOptions.enabled && isFunction2(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });
    this.update();
    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      this.enableEventListeners();
    }
    this.state.eventsEnabled = eventsEnabled;
  }
  createClass(Popper2, [{
    key: "update",
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: "destroy",
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: "enableEventListeners",
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: "disableEventListeners",
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }
    /**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */
    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */
  }]);
  return Popper2;
}();
Popper.Utils = (typeof window !== "undefined" ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;
var popper_default = Popper;

// node_modules/react-floater/es/index.js
var import_deepmerge = __toESM(require_cjs());
var import_react_dom = __toESM(require_react_dom());
var import_exenv = __toESM(require_exenv());
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf3(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf3(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
var DEFAULTS = { flip: { padding: 20 }, preventOverflow: { padding: 10 } };
var STATUS = { INIT: "init", IDLE: "idle", OPENING: "opening", OPEN: "open", CLOSING: "closing", ERROR: "error" };
var canUseDOM = import_exenv.default.canUseDOM;
var isReact16 = import_react_dom.default.createPortal !== void 0;
function isMobile() {
  return "ontouchstart" in window && /Mobi/.test(navigator.userAgent);
}
function log(_ref) {
  var title = _ref.title, data = _ref.data, _ref$warn = _ref.warn, warn = _ref$warn === void 0 ? false : _ref$warn, _ref$debug = _ref.debug, debug = _ref$debug === void 0 ? false : _ref$debug;
  var logFn = warn ? console.warn || console.error : console.log;
  if (debug && title && data) {
    console.groupCollapsed("%creact-floater: ".concat(title), "color: #9b00ff; font-weight: bold; font-size: 12px;");
    if (Array.isArray(data)) {
      data.forEach(function(d) {
        if (esm_default.plainObject(d) && d.key) {
          logFn.apply(console, [d.key, d.value]);
        } else {
          logFn.apply(console, [d]);
        }
      });
    } else {
      logFn.apply(console, [data]);
    }
    console.groupEnd();
  }
}
function on(element, event, cb) {
  var capture = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  element.addEventListener(event, cb, capture);
}
function off(element, event, cb) {
  var capture = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  element.removeEventListener(event, cb, capture);
}
function once(element, event, cb) {
  var capture = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var _nextCB;
  _nextCB = function nextCB(e) {
    cb(e);
    off(element, event, _nextCB);
  };
  on(element, event, _nextCB, capture);
}
function noop() {
}
var ReactFloaterPortal = function(_React$Component) {
  _inherits(ReactFloaterPortal2, _React$Component);
  var _super = _createSuper(ReactFloaterPortal2);
  function ReactFloaterPortal2() {
    _classCallCheck(this, ReactFloaterPortal2);
    return _super.apply(this, arguments);
  }
  _createClass(ReactFloaterPortal2, [{ key: "componentDidMount", value: function componentDidMount() {
    if (!canUseDOM)
      return;
    if (!this.node) {
      this.appendNode();
    }
    if (!isReact16) {
      this.renderPortal();
    }
  } }, { key: "componentDidUpdate", value: function componentDidUpdate() {
    if (!canUseDOM)
      return;
    if (!isReact16) {
      this.renderPortal();
    }
  } }, { key: "componentWillUnmount", value: function componentWillUnmount() {
    if (!canUseDOM || !this.node)
      return;
    if (!isReact16) {
      import_react_dom.default.unmountComponentAtNode(this.node);
    }
    if (this.node && this.node.parentNode === document.body) {
      document.body.removeChild(this.node);
      this.node = void 0;
    }
  } }, { key: "appendNode", value: function appendNode() {
    var _this$props = this.props, id = _this$props.id, zIndex = _this$props.zIndex;
    if (!this.node) {
      this.node = document.createElement("div");
      if (id) {
        this.node.id = id;
      }
      if (zIndex) {
        this.node.style.zIndex = zIndex;
      }
      document.body.appendChild(this.node);
    }
  } }, { key: "renderPortal", value: function renderPortal() {
    if (!canUseDOM)
      return null;
    var _this$props2 = this.props, children = _this$props2.children, setRef = _this$props2.setRef;
    if (!this.node) {
      this.appendNode();
    }
    if (isReact16) {
      return import_react_dom.default.createPortal(children, this.node);
    }
    var portal = import_react_dom.default.unstable_renderSubtreeIntoContainer(this, children.length > 1 ? import_react.default.createElement("div", null, children) : children[0], this.node);
    setRef(portal);
    return null;
  } }, { key: "renderReact16", value: function renderReact16() {
    var _this$props3 = this.props, hasChildren = _this$props3.hasChildren, placement = _this$props3.placement, target = _this$props3.target;
    if (!hasChildren) {
      if (target || placement === "center") {
        return this.renderPortal();
      }
      return null;
    }
    return this.renderPortal();
  } }, { key: "render", value: function render() {
    if (!isReact16) {
      return null;
    }
    return this.renderReact16();
  } }]);
  return ReactFloaterPortal2;
}(import_react.default.Component);
_defineProperty(ReactFloaterPortal, "propTypes", { children: import_prop_types.default.oneOfType([import_prop_types.default.element, import_prop_types.default.array]), hasChildren: import_prop_types.default.bool, id: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.number]), placement: import_prop_types.default.string, setRef: import_prop_types.default.func.isRequired, target: import_prop_types.default.oneOfType([import_prop_types.default.object, import_prop_types.default.string]), zIndex: import_prop_types.default.number });
var FloaterArrow = function(_React$Component) {
  _inherits(FloaterArrow2, _React$Component);
  var _super = _createSuper(FloaterArrow2);
  function FloaterArrow2() {
    _classCallCheck(this, FloaterArrow2);
    return _super.apply(this, arguments);
  }
  _createClass(FloaterArrow2, [{ key: "parentStyle", get: function get() {
    var _this$props = this.props, placement = _this$props.placement, styles = _this$props.styles;
    var length = styles.arrow.length;
    var arrow2 = { pointerEvents: "none", position: "absolute", width: "100%" };
    if (placement.startsWith("top")) {
      arrow2.bottom = 0;
      arrow2.left = 0;
      arrow2.right = 0;
      arrow2.height = length;
    } else if (placement.startsWith("bottom")) {
      arrow2.left = 0;
      arrow2.right = 0;
      arrow2.top = 0;
      arrow2.height = length;
    } else if (placement.startsWith("left")) {
      arrow2.right = 0;
      arrow2.top = 0;
      arrow2.bottom = 0;
    } else if (placement.startsWith("right")) {
      arrow2.left = 0;
      arrow2.top = 0;
    }
    return arrow2;
  } }, { key: "render", value: function render() {
    var _this$props2 = this.props, placement = _this$props2.placement, setArrowRef = _this$props2.setArrowRef, styles = _this$props2.styles;
    var _styles$arrow = styles.arrow, color = _styles$arrow.color, display = _styles$arrow.display, length = _styles$arrow.length, margin = _styles$arrow.margin, position = _styles$arrow.position, spread = _styles$arrow.spread;
    var arrowStyles = { display, position };
    var points;
    var x = spread;
    var y = length;
    if (placement.startsWith("top")) {
      points = "0,0 ".concat(x / 2, ",").concat(y, " ").concat(x, ",0");
      arrowStyles.bottom = 0;
      arrowStyles.marginLeft = margin;
      arrowStyles.marginRight = margin;
    } else if (placement.startsWith("bottom")) {
      points = "".concat(x, ",").concat(y, " ").concat(x / 2, ",0 0,").concat(y);
      arrowStyles.top = 0;
      arrowStyles.marginLeft = margin;
      arrowStyles.marginRight = margin;
    } else if (placement.startsWith("left")) {
      y = spread;
      x = length;
      points = "0,0 ".concat(x, ",").concat(y / 2, " 0,").concat(y);
      arrowStyles.right = 0;
      arrowStyles.marginTop = margin;
      arrowStyles.marginBottom = margin;
    } else if (placement.startsWith("right")) {
      y = spread;
      x = length;
      points = "".concat(x, ",").concat(y, " ").concat(x, ",0 0,").concat(y / 2);
      arrowStyles.left = 0;
      arrowStyles.marginTop = margin;
      arrowStyles.marginBottom = margin;
    }
    return import_react.default.createElement("div", { className: "__floater__arrow", style: this.parentStyle }, import_react.default.createElement("span", { ref: setArrowRef, style: arrowStyles }, import_react.default.createElement("svg", { width: x, height: y, version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, import_react.default.createElement("polygon", { points, fill: color }))));
  } }]);
  return FloaterArrow2;
}(import_react.default.Component);
_defineProperty(FloaterArrow, "propTypes", { placement: import_prop_types.default.string.isRequired, setArrowRef: import_prop_types.default.func.isRequired, styles: import_prop_types.default.object.isRequired });
var _excluded$1 = ["color", "height", "width"];
var FloaterCloseBtn = function FloaterCloseBtn2(_ref) {
  var handleClick = _ref.handleClick, styles = _ref.styles;
  var color = styles.color, height = styles.height, width = styles.width, style = _objectWithoutProperties(styles, _excluded$1);
  return import_react.default.createElement("button", { "aria-label": "close", onClick: handleClick, style, type: "button" }, import_react.default.createElement("svg", { width: "".concat(width, "px"), height: "".concat(height, "px"), viewBox: "0 0 18 18", version: "1.1", xmlns: "http://www.w3.org/2000/svg", preserveAspectRatio: "xMidYMid" }, import_react.default.createElement("g", null, import_react.default.createElement("path", { d: "M8.13911129,9.00268191 L0.171521827,17.0258467 C-0.0498027049,17.248715 -0.0498027049,17.6098394 0.171521827,17.8327545 C0.28204354,17.9443526 0.427188206,17.9998706 0.572051765,17.9998706 C0.71714958,17.9998706 0.862013139,17.9443526 0.972581703,17.8327545 L9.0000937,9.74924618 L17.0276057,17.8327545 C17.1384085,17.9443526 17.2832721,17.9998706 17.4281356,17.9998706 C17.5729992,17.9998706 17.718097,17.9443526 17.8286656,17.8327545 C18.0499901,17.6098862 18.0499901,17.2487618 17.8286656,17.0258467 L9.86135722,9.00268191 L17.8340066,0.973848225 C18.0553311,0.750979934 18.0553311,0.389855532 17.8340066,0.16694039 C17.6126821,-0.0556467968 17.254037,-0.0556467968 17.0329467,0.16694039 L9.00042166,8.25611765 L0.967006424,0.167268345 C0.745681892,-0.0553188426 0.387317931,-0.0553188426 0.165993399,0.167268345 C-0.0553311331,0.390136635 -0.0553311331,0.751261038 0.165993399,0.974176179 L8.13920499,9.00268191 L8.13911129,9.00268191 Z", fill: color }))));
};
FloaterCloseBtn.propTypes = { handleClick: import_prop_types.default.func.isRequired, styles: import_prop_types.default.object.isRequired };
var FloaterContainer = function FloaterContainer2(_ref) {
  var content = _ref.content, footer = _ref.footer, handleClick = _ref.handleClick, open = _ref.open, positionWrapper = _ref.positionWrapper, showCloseButton = _ref.showCloseButton, title = _ref.title, styles = _ref.styles;
  var output = { content: import_react.default.isValidElement(content) ? content : import_react.default.createElement("div", { className: "__floater__content", style: styles.content }, content) };
  if (title) {
    output.title = import_react.default.isValidElement(title) ? title : import_react.default.createElement("div", { className: "__floater__title", style: styles.title }, title);
  }
  if (footer) {
    output.footer = import_react.default.isValidElement(footer) ? footer : import_react.default.createElement("div", { className: "__floater__footer", style: styles.footer }, footer);
  }
  if ((showCloseButton || positionWrapper) && !esm_default["boolean"](open)) {
    output.close = import_react.default.createElement(FloaterCloseBtn, { styles: styles.close, handleClick });
  }
  return import_react.default.createElement("div", { className: "__floater__container", style: styles.container }, output.close, output.title, output.content, output.footer);
};
FloaterContainer.propTypes = { content: import_prop_types.default.node.isRequired, footer: import_prop_types.default.node, handleClick: import_prop_types.default.func.isRequired, open: import_prop_types.default.bool, positionWrapper: import_prop_types.default.bool.isRequired, showCloseButton: import_prop_types.default.bool.isRequired, styles: import_prop_types.default.object.isRequired, title: import_prop_types.default.node };
var Floater = function(_React$Component) {
  _inherits(Floater2, _React$Component);
  var _super = _createSuper(Floater2);
  function Floater2() {
    _classCallCheck(this, Floater2);
    return _super.apply(this, arguments);
  }
  _createClass(Floater2, [{ key: "style", get: function get() {
    var _this$props = this.props, disableAnimation = _this$props.disableAnimation, component = _this$props.component, placement = _this$props.placement, hideArrow = _this$props.hideArrow, status = _this$props.status, styles = _this$props.styles;
    var length = styles.arrow.length, floater = styles.floater, floaterCentered = styles.floaterCentered, floaterClosing = styles.floaterClosing, floaterOpening = styles.floaterOpening, floaterWithAnimation = styles.floaterWithAnimation, floaterWithComponent = styles.floaterWithComponent;
    var element = {};
    if (!hideArrow) {
      if (placement.startsWith("top")) {
        element.padding = "0 0 ".concat(length, "px");
      } else if (placement.startsWith("bottom")) {
        element.padding = "".concat(length, "px 0 0");
      } else if (placement.startsWith("left")) {
        element.padding = "0 ".concat(length, "px 0 0");
      } else if (placement.startsWith("right")) {
        element.padding = "0 0 0 ".concat(length, "px");
      }
    }
    if ([STATUS.OPENING, STATUS.OPEN].indexOf(status) !== -1) {
      element = _objectSpread2(_objectSpread2({}, element), floaterOpening);
    }
    if (status === STATUS.CLOSING) {
      element = _objectSpread2(_objectSpread2({}, element), floaterClosing);
    }
    if (status === STATUS.OPEN && !disableAnimation) {
      element = _objectSpread2(_objectSpread2({}, element), floaterWithAnimation);
    }
    if (placement === "center") {
      element = _objectSpread2(_objectSpread2({}, element), floaterCentered);
    }
    if (component) {
      element = _objectSpread2(_objectSpread2({}, element), floaterWithComponent);
    }
    return _objectSpread2(_objectSpread2({}, floater), element);
  } }, { key: "render", value: function render() {
    var _this$props2 = this.props, component = _this$props2.component, closeFn = _this$props2.handleClick, hideArrow = _this$props2.hideArrow, setFloaterRef = _this$props2.setFloaterRef, status = _this$props2.status;
    var output = {};
    var classes = ["__floater"];
    if (component) {
      if (import_react.default.isValidElement(component)) {
        output.content = import_react.default.cloneElement(component, { closeFn });
      } else {
        output.content = component({ closeFn });
      }
    } else {
      output.content = import_react.default.createElement(FloaterContainer, this.props);
    }
    if (status === STATUS.OPEN) {
      classes.push("__floater__open");
    }
    if (!hideArrow) {
      output.arrow = import_react.default.createElement(FloaterArrow, this.props);
    }
    return import_react.default.createElement("div", { ref: setFloaterRef, className: classes.join(" "), style: this.style }, import_react.default.createElement("div", { className: "__floater__body" }, output.content, output.arrow));
  } }]);
  return Floater2;
}(import_react.default.Component);
_defineProperty(Floater, "propTypes", { component: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.element]), content: import_prop_types.default.node, disableAnimation: import_prop_types.default.bool.isRequired, footer: import_prop_types.default.node, handleClick: import_prop_types.default.func.isRequired, hideArrow: import_prop_types.default.bool.isRequired, open: import_prop_types.default.bool, placement: import_prop_types.default.string.isRequired, positionWrapper: import_prop_types.default.bool.isRequired, setArrowRef: import_prop_types.default.func.isRequired, setFloaterRef: import_prop_types.default.func.isRequired, showCloseButton: import_prop_types.default.bool, status: import_prop_types.default.string.isRequired, styles: import_prop_types.default.object.isRequired, title: import_prop_types.default.node });
var ReactFloaterWrapper = function(_React$Component) {
  _inherits(ReactFloaterWrapper2, _React$Component);
  var _super = _createSuper(ReactFloaterWrapper2);
  function ReactFloaterWrapper2() {
    _classCallCheck(this, ReactFloaterWrapper2);
    return _super.apply(this, arguments);
  }
  _createClass(ReactFloaterWrapper2, [{ key: "render", value: function render() {
    var _this$props = this.props, children = _this$props.children, handleClick = _this$props.handleClick, handleMouseEnter = _this$props.handleMouseEnter, handleMouseLeave = _this$props.handleMouseLeave, setChildRef = _this$props.setChildRef, setWrapperRef = _this$props.setWrapperRef, style = _this$props.style, styles = _this$props.styles;
    var element;
    if (children) {
      if (import_react.default.Children.count(children) === 1) {
        if (!import_react.default.isValidElement(children)) {
          element = import_react.default.createElement("span", null, children);
        } else {
          var refProp = esm_default["function"](children.type) ? "innerRef" : "ref";
          element = import_react.default.cloneElement(import_react.default.Children.only(children), _defineProperty({}, refProp, setChildRef));
        }
      } else {
        element = children;
      }
    }
    if (!element) {
      return null;
    }
    return import_react.default.createElement("span", { ref: setWrapperRef, style: _objectSpread2(_objectSpread2({}, styles), style), onClick: handleClick, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave }, element);
  } }]);
  return ReactFloaterWrapper2;
}(import_react.default.Component);
_defineProperty(ReactFloaterWrapper, "propTypes", { children: import_prop_types.default.node, handleClick: import_prop_types.default.func.isRequired, handleMouseEnter: import_prop_types.default.func.isRequired, handleMouseLeave: import_prop_types.default.func.isRequired, setChildRef: import_prop_types.default.func.isRequired, setWrapperRef: import_prop_types.default.func.isRequired, style: import_prop_types.default.object, styles: import_prop_types.default.object.isRequired });
var defaultOptions = { zIndex: 100 };
function getStyles(styles) {
  var options = (0, import_deepmerge.default)(defaultOptions, styles.options || {});
  return { wrapper: { cursor: "help", display: "inline-flex", flexDirection: "column", zIndex: options.zIndex }, wrapperPosition: { left: -1e3, position: "absolute", top: -1e3, visibility: "hidden" }, floater: { display: "inline-block", filter: "drop-shadow(0 0 3px rgba(0, 0, 0, 0.3))", maxWidth: 300, opacity: 0, position: "relative", transition: "opacity 0.3s", visibility: "hidden", zIndex: options.zIndex }, floaterOpening: { opacity: 1, visibility: "visible" }, floaterWithAnimation: { opacity: 1, transition: "opacity 0.3s, transform 0.2s", visibility: "visible" }, floaterWithComponent: { maxWidth: "100%" }, floaterClosing: { opacity: 0, visibility: "visible" }, floaterCentered: { left: "50%", position: "fixed", top: "50%", transform: "translate(-50%, -50%)" }, container: { backgroundColor: "#fff", color: "#666", minHeight: 60, minWidth: 200, padding: 20, position: "relative", zIndex: 10 }, title: { borderBottom: "1px solid #555", color: "#555", fontSize: 18, marginBottom: 5, paddingBottom: 6, paddingRight: 18 }, content: { fontSize: 15 }, close: { backgroundColor: "transparent", border: 0, borderRadius: 0, color: "#555", fontSize: 0, height: 15, outline: "none", padding: 10, position: "absolute", right: 0, top: 0, width: 15, WebkitAppearance: "none" }, footer: { borderTop: "1px solid #ccc", fontSize: 13, marginTop: 10, paddingTop: 5 }, arrow: { color: "#fff", display: "inline-flex", length: 16, margin: 8, position: "absolute", spread: 32 }, options };
}
var _excluded = ["arrow", "flip", "offset"];
var POSITIONING_PROPS = ["position", "top", "right", "bottom", "left"];
var ReactFloater = function(_React$Component) {
  _inherits(ReactFloater2, _React$Component);
  var _super = _createSuper(ReactFloater2);
  function ReactFloater2(props) {
    var _this;
    _classCallCheck(this, ReactFloater2);
    _this = _super.call(this, props);
    _defineProperty(_assertThisInitialized(_this), "setArrowRef", function(ref) {
      _this.arrowRef = ref;
    });
    _defineProperty(_assertThisInitialized(_this), "setChildRef", function(ref) {
      _this.childRef = ref;
    });
    _defineProperty(_assertThisInitialized(_this), "setFloaterRef", function(ref) {
      _this.floaterRef = ref;
    });
    _defineProperty(_assertThisInitialized(_this), "setWrapperRef", function(ref) {
      _this.wrapperRef = ref;
    });
    _defineProperty(_assertThisInitialized(_this), "handleTransitionEnd", function() {
      var status = _this.state.status;
      var callback = _this.props.callback;
      if (_this.wrapperPopper) {
        _this.wrapperPopper.instance.update();
      }
      _this.setState({ status: status === STATUS.OPENING ? STATUS.OPEN : STATUS.IDLE }, function() {
        var newStatus = _this.state.status;
        callback(newStatus === STATUS.OPEN ? "open" : "close", _this.props);
      });
    });
    _defineProperty(_assertThisInitialized(_this), "handleClick", function() {
      var _this$props = _this.props, event = _this$props.event, open = _this$props.open;
      if (esm_default["boolean"](open))
        return;
      var _this$state = _this.state, positionWrapper = _this$state.positionWrapper, status = _this$state.status;
      if (_this.event === "click" || _this.event === "hover" && positionWrapper) {
        log({ title: "click", data: [{ event, status: status === STATUS.OPEN ? "closing" : "opening" }], debug: _this.debug });
        _this.toggle();
      }
    });
    _defineProperty(_assertThisInitialized(_this), "handleMouseEnter", function() {
      var _this$props2 = _this.props, event = _this$props2.event, open = _this$props2.open;
      if (esm_default["boolean"](open) || isMobile())
        return;
      var status = _this.state.status;
      if (_this.event === "hover" && status === STATUS.IDLE) {
        log({ title: "mouseEnter", data: [{ key: "originalEvent", value: event }], debug: _this.debug });
        clearTimeout(_this.eventDelayTimeout);
        _this.toggle();
      }
    });
    _defineProperty(_assertThisInitialized(_this), "handleMouseLeave", function() {
      var _this$props3 = _this.props, event = _this$props3.event, eventDelay = _this$props3.eventDelay, open = _this$props3.open;
      if (esm_default["boolean"](open) || isMobile())
        return;
      var _this$state2 = _this.state, status = _this$state2.status, positionWrapper = _this$state2.positionWrapper;
      if (_this.event === "hover") {
        log({ title: "mouseLeave", data: [{ key: "originalEvent", value: event }], debug: _this.debug });
        if (!eventDelay) {
          _this.toggle(STATUS.IDLE);
        } else if ([STATUS.OPENING, STATUS.OPEN].indexOf(status) !== -1 && !positionWrapper && !_this.eventDelayTimeout) {
          _this.eventDelayTimeout = setTimeout(function() {
            delete _this.eventDelayTimeout;
            _this.toggle();
          }, eventDelay * 1e3);
        }
      }
    });
    _this.state = { currentPlacement: props.placement, needsUpdate: false, positionWrapper: props.wrapperOptions.position && !!props.target, status: STATUS.INIT, statusWrapper: STATUS.INIT };
    _this._isMounted = false;
    _this.hasMounted = false;
    if (canUseDOM) {
      window.addEventListener("load", function() {
        if (_this.popper) {
          _this.popper.instance.update();
        }
        if (_this.wrapperPopper) {
          _this.wrapperPopper.instance.update();
        }
      });
    }
    return _this;
  }
  _createClass(ReactFloater2, [{ key: "componentDidMount", value: function componentDidMount() {
    if (!canUseDOM)
      return;
    var positionWrapper = this.state.positionWrapper;
    var _this$props5 = this.props, children = _this$props5.children, open = _this$props5.open, target = _this$props5.target;
    this._isMounted = true;
    log({ title: "init", data: { hasChildren: !!children, hasTarget: !!target, isControlled: esm_default["boolean"](open), positionWrapper, target: this.target, floater: this.floaterRef }, debug: this.debug });
    if (!this.hasMounted) {
      this.initPopper();
      this.hasMounted = true;
    }
    if (!children && target && !esm_default["boolean"](open))
      ;
  } }, { key: "componentDidUpdate", value: function componentDidUpdate(prevProps, prevState) {
    if (!canUseDOM)
      return;
    var _this$props6 = this.props, autoOpen = _this$props6.autoOpen, open = _this$props6.open, target = _this$props6.target, wrapperOptions = _this$props6.wrapperOptions;
    var _treeChanges = treeChanges(prevState, this.state), changedFrom = _treeChanges.changedFrom, changed = _treeChanges.changed;
    if (prevProps.open !== open) {
      var forceStatus;
      if (esm_default["boolean"](open)) {
        forceStatus = open ? STATUS.OPENING : STATUS.CLOSING;
      }
      this.toggle(forceStatus);
    }
    if (prevProps.wrapperOptions.position !== wrapperOptions.position || prevProps.target !== target) {
      this.changeWrapperPosition(this.props);
    }
    if (changed("status", STATUS.IDLE) && open) {
      this.toggle(STATUS.OPEN);
    } else if (changedFrom("status", STATUS.INIT, STATUS.IDLE) && autoOpen) {
      this.toggle(STATUS.OPEN);
    }
    if (this.popper && changed("status", STATUS.OPENING)) {
      this.popper.instance.update();
    }
    if (this.floaterRef && (changed("status", STATUS.OPENING) || changed("status", STATUS.CLOSING))) {
      once(this.floaterRef, "transitionend", this.handleTransitionEnd);
    }
    if (changed("needsUpdate", true)) {
      this.rebuildPopper();
    }
  } }, { key: "componentWillUnmount", value: function componentWillUnmount() {
    if (!canUseDOM)
      return;
    this._isMounted = false;
    if (this.popper) {
      this.popper.instance.destroy();
    }
    if (this.wrapperPopper) {
      this.wrapperPopper.instance.destroy();
    }
  } }, { key: "initPopper", value: function initPopper() {
    var _this2 = this;
    var target = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.target;
    var positionWrapper = this.state.positionWrapper;
    var _this$props7 = this.props, disableFlip = _this$props7.disableFlip, getPopper = _this$props7.getPopper, hideArrow = _this$props7.hideArrow, offset2 = _this$props7.offset, placement = _this$props7.placement, wrapperOptions = _this$props7.wrapperOptions;
    var flipBehavior = placement === "top" || placement === "bottom" ? "flip" : ["right", "bottom-end", "top-end", "left", "top-start", "bottom-start"];
    if (placement === "center") {
      this.setState({ status: STATUS.IDLE });
    } else if (target && this.floaterRef) {
      var _this$options = this.options, arrow2 = _this$options.arrow, flip2 = _this$options.flip, offsetOptions = _this$options.offset, rest = _objectWithoutProperties(_this$options, _excluded);
      new popper_default(target, this.floaterRef, { placement, modifiers: _objectSpread2({ arrow: _objectSpread2({ enabled: !hideArrow, element: this.arrowRef }, arrow2), flip: _objectSpread2({ enabled: !disableFlip, behavior: flipBehavior }, flip2), offset: _objectSpread2({ offset: "0, ".concat(offset2, "px") }, offsetOptions) }, rest), onCreate: function onCreate2(data) {
        var _this2$floaterRef;
        _this2.popper = data;
        if (!((_this2$floaterRef = _this2.floaterRef) !== null && _this2$floaterRef !== void 0 && _this2$floaterRef.isConnected)) {
          _this2.setState({ needsUpdate: true });
          return;
        }
        getPopper(data, "floater");
        if (_this2._isMounted) {
          _this2.setState({ currentPlacement: data.placement, status: STATUS.IDLE });
        }
        if (placement !== data.placement) {
          setTimeout(function() {
            data.instance.update();
          }, 1);
        }
      }, onUpdate: function onUpdate2(data) {
        _this2.popper = data;
        var currentPlacement = _this2.state.currentPlacement;
        if (_this2._isMounted && data.placement !== currentPlacement) {
          _this2.setState({ currentPlacement: data.placement });
        }
      } });
    }
    if (positionWrapper) {
      var wrapperOffset = !esm_default.undefined(wrapperOptions.offset) ? wrapperOptions.offset : 0;
      new popper_default(this.target, this.wrapperRef, { placement: wrapperOptions.placement || placement, modifiers: { arrow: { enabled: false }, offset: { offset: "0, ".concat(wrapperOffset, "px") }, flip: { enabled: false } }, onCreate: function onCreate2(data) {
        _this2.wrapperPopper = data;
        if (_this2._isMounted) {
          _this2.setState({ statusWrapper: STATUS.IDLE });
        }
        getPopper(data, "wrapper");
        if (placement !== data.placement) {
          setTimeout(function() {
            data.instance.update();
          }, 1);
        }
      } });
    }
  } }, { key: "rebuildPopper", value: function rebuildPopper() {
    var _this3 = this;
    this.floaterRefInterval = setInterval(function() {
      var _this3$floaterRef;
      if ((_this3$floaterRef = _this3.floaterRef) !== null && _this3$floaterRef !== void 0 && _this3$floaterRef.isConnected) {
        clearInterval(_this3.floaterRefInterval);
        _this3.setState({ needsUpdate: false });
        _this3.initPopper();
      }
    }, 50);
  } }, { key: "changeWrapperPosition", value: function changeWrapperPosition(_ref) {
    var target = _ref.target, wrapperOptions = _ref.wrapperOptions;
    this.setState({ positionWrapper: wrapperOptions.position && !!target });
  } }, { key: "toggle", value: function toggle(forceStatus) {
    var status = this.state.status;
    var nextStatus = status === STATUS.OPEN ? STATUS.CLOSING : STATUS.OPENING;
    if (!esm_default.undefined(forceStatus)) {
      nextStatus = forceStatus;
    }
    this.setState({ status: nextStatus });
  } }, { key: "debug", get: function get() {
    var debug = this.props.debug;
    return debug || !!global.ReactFloaterDebug;
  } }, { key: "event", get: function get() {
    var _this$props8 = this.props, disableHoverToClick = _this$props8.disableHoverToClick, event = _this$props8.event;
    if (event === "hover" && isMobile() && !disableHoverToClick) {
      return "click";
    }
    return event;
  } }, { key: "options", get: function get() {
    var options = this.props.options;
    return (0, import_deepmerge.default)(DEFAULTS, options || {});
  } }, { key: "styles", get: function get() {
    var _this4 = this;
    var _this$state3 = this.state, status = _this$state3.status, positionWrapper = _this$state3.positionWrapper, statusWrapper = _this$state3.statusWrapper;
    var styles = this.props.styles;
    var nextStyles = (0, import_deepmerge.default)(getStyles(styles), styles);
    if (positionWrapper) {
      var wrapperStyles;
      if (!([STATUS.IDLE].indexOf(status) !== -1) || !([STATUS.IDLE].indexOf(statusWrapper) !== -1)) {
        wrapperStyles = nextStyles.wrapperPosition;
      } else {
        wrapperStyles = this.wrapperPopper.styles;
      }
      nextStyles.wrapper = _objectSpread2(_objectSpread2({}, nextStyles.wrapper), wrapperStyles);
    }
    if (this.target) {
      var targetStyles = window.getComputedStyle(this.target);
      if (this.wrapperStyles) {
        nextStyles.wrapper = _objectSpread2(_objectSpread2({}, nextStyles.wrapper), this.wrapperStyles);
      } else if (!(["relative", "static"].indexOf(targetStyles.position) !== -1)) {
        this.wrapperStyles = {};
        if (!positionWrapper) {
          POSITIONING_PROPS.forEach(function(d) {
            _this4.wrapperStyles[d] = targetStyles[d];
          });
          nextStyles.wrapper = _objectSpread2(_objectSpread2({}, nextStyles.wrapper), this.wrapperStyles);
          this.target.style.position = "relative";
          this.target.style.top = "auto";
          this.target.style.right = "auto";
          this.target.style.bottom = "auto";
          this.target.style.left = "auto";
        }
      }
    }
    return nextStyles;
  } }, { key: "target", get: function get() {
    if (!canUseDOM)
      return null;
    var target = this.props.target;
    if (target) {
      if (esm_default.domElement(target)) {
        return target;
      }
      return document.querySelector(target);
    }
    return this.childRef || this.wrapperRef;
  } }, { key: "render", value: function render() {
    var _this$state4 = this.state, currentPlacement = _this$state4.currentPlacement, positionWrapper = _this$state4.positionWrapper, status = _this$state4.status;
    var _this$props9 = this.props, children = _this$props9.children, component = _this$props9.component, content = _this$props9.content, disableAnimation = _this$props9.disableAnimation, footer = _this$props9.footer, hideArrow = _this$props9.hideArrow, id = _this$props9.id, open = _this$props9.open, showCloseButton = _this$props9.showCloseButton, style = _this$props9.style, target = _this$props9.target, title = _this$props9.title;
    var wrapper = import_react.default.createElement(ReactFloaterWrapper, { handleClick: this.handleClick, handleMouseEnter: this.handleMouseEnter, handleMouseLeave: this.handleMouseLeave, setChildRef: this.setChildRef, setWrapperRef: this.setWrapperRef, style, styles: this.styles.wrapper }, children);
    var output = {};
    if (positionWrapper) {
      output.wrapperInPortal = wrapper;
    } else {
      output.wrapperAsChildren = wrapper;
    }
    return import_react.default.createElement("span", null, import_react.default.createElement(ReactFloaterPortal, { hasChildren: !!children, id, placement: currentPlacement, setRef: this.setFloaterRef, target, zIndex: this.styles.options.zIndex }, import_react.default.createElement(Floater, { component, content, disableAnimation, footer, handleClick: this.handleClick, hideArrow: hideArrow || currentPlacement === "center", open, placement: currentPlacement, positionWrapper, setArrowRef: this.setArrowRef, setFloaterRef: this.setFloaterRef, showCloseButton, status, styles: this.styles, title }), output.wrapperInPortal), output.wrapperAsChildren);
  } }]);
  return ReactFloater2;
}(import_react.default.Component);
_defineProperty(ReactFloater, "propTypes", { autoOpen: import_prop_types.default.bool, callback: import_prop_types.default.func, children: import_prop_types.default.node, component: (0, import_react_proptype_conditional_require.default)(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.element]), function(props) {
  return !props.content;
}), content: (0, import_react_proptype_conditional_require.default)(import_prop_types.default.node, function(props) {
  return !props.component;
}), debug: import_prop_types.default.bool, disableAnimation: import_prop_types.default.bool, disableFlip: import_prop_types.default.bool, disableHoverToClick: import_prop_types.default.bool, event: import_prop_types.default.oneOf(["hover", "click"]), eventDelay: import_prop_types.default.number, footer: import_prop_types.default.node, getPopper: import_prop_types.default.func, hideArrow: import_prop_types.default.bool, id: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.number]), offset: import_prop_types.default.number, open: import_prop_types.default.bool, options: import_prop_types.default.object, placement: import_prop_types.default.oneOf(["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "left", "left-start", "left-end", "right", "right-start", "right-end", "auto", "center"]), showCloseButton: import_prop_types.default.bool, style: import_prop_types.default.object, styles: import_prop_types.default.object, target: import_prop_types.default.oneOfType([import_prop_types.default.object, import_prop_types.default.string]), title: import_prop_types.default.node, wrapperOptions: import_prop_types.default.shape({ offset: import_prop_types.default.number, placement: import_prop_types.default.oneOf(["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "left", "left-start", "left-end", "right", "right-start", "right-end", "auto"]), position: import_prop_types.default.bool }) });
_defineProperty(ReactFloater, "defaultProps", { autoOpen: false, callback: noop, debug: false, disableAnimation: false, disableFlip: false, disableHoverToClick: false, event: "click", eventDelay: 0.4, getPopper: noop, hideArrow: false, offset: 15, placement: "bottom", showCloseButton: false, styles: {}, target: null, wrapperOptions: { position: false } });

// node_modules/react-joyride/es/index.js
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread22(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _classCallCheck2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties2(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends2() {
  _extends2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function _inherits2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf2(subClass, superClass);
}
function _getPrototypeOf2(o) {
  _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf3(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf2(o);
}
function _setPrototypeOf2(o, p) {
  _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf3(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf2(o, p);
}
function _isNativeReflectConstruct2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties2(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose2(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _assertThisInitialized2(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _possibleConstructorReturn2(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized2(self);
}
function _createSuper2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn2(this, result);
  };
}
var ACTIONS = {
  INIT: "init",
  START: "start",
  STOP: "stop",
  RESET: "reset",
  PREV: "prev",
  NEXT: "next",
  GO: "go",
  CLOSE: "close",
  SKIP: "skip",
  UPDATE: "update"
};
var EVENTS = {
  TOUR_START: "tour:start",
  STEP_BEFORE: "step:before",
  BEACON: "beacon",
  TOOLTIP: "tooltip",
  STEP_AFTER: "step:after",
  TOUR_END: "tour:end",
  TOUR_STATUS: "tour:status",
  TARGET_NOT_FOUND: "error:target_not_found",
  ERROR: "error"
};
var LIFECYCLE = {
  INIT: "init",
  READY: "ready",
  BEACON: "beacon",
  TOOLTIP: "tooltip",
  COMPLETE: "complete",
  ERROR: "error"
};
var STATUS2 = {
  IDLE: "idle",
  READY: "ready",
  WAITING: "waiting",
  RUNNING: "running",
  PAUSED: "paused",
  SKIPPED: "skipped",
  FINISHED: "finished",
  ERROR: "error"
};
var canUseDOM2 = import_exenv2.default.canUseDOM;
var isReact162 = import_react_dom2.createPortal !== void 0;
function getBrowser() {
  var userAgent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : navigator.userAgent;
  var browser = userAgent;
  if (typeof window === "undefined") {
    browser = "node";
  } else if (document.documentMode) {
    browser = "ie";
  } else if (/Edge/.test(userAgent)) {
    browser = "edge";
  } else if (Boolean(window.opera) || userAgent.indexOf(" OPR/") >= 0) {
    browser = "opera";
  } else if (typeof window.InstallTrigger !== "undefined") {
    browser = "firefox";
  } else if (window.chrome) {
    browser = "chrome";
  } else if (/(Version\/([0-9._]+).*Safari|CriOS|FxiOS| Mobile\/)/.test(userAgent)) {
    browser = "safari";
  }
  return browser;
}
function getObjectType3(value) {
  return Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
}
function getText(root) {
  var content = [];
  var recurse = function recurse2(child) {
    if (typeof child === "string" || typeof child === "number") {
      content.push(child);
    } else if (Array.isArray(child)) {
      child.forEach(function(c) {
        return recurse2(c);
      });
    } else if (child && child.props) {
      var children = child.props.children;
      if (Array.isArray(children)) {
        children.forEach(function(c) {
          return recurse2(c);
        });
      } else {
        recurse2(children);
      }
    }
  };
  recurse(root);
  return content.join(" ").trim();
}
function hasOwnProperty(value, key) {
  return Object.prototype.hasOwnProperty.call(value, key);
}
function hasValidKeys(value, keys) {
  if (!src_default.plainObject(value) || !src_default.array(keys)) {
    return false;
  }
  return Object.keys(value).every(function(d) {
    return keys.indexOf(d) !== -1;
  });
}
function hexToRGB(hex) {
  var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  var properHex = hex.replace(shorthandRegex, function(m, r, g, b) {
    return r + r + g + g + b + b;
  });
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(properHex);
  return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : [];
}
function hideBeacon(step) {
  return step.disableBeacon || step.placement === "center";
}
function isEqual(left, right) {
  var type;
  var hasReactElement = (0, import_react2.isValidElement)(left) || (0, import_react2.isValidElement)(right);
  var hasUndefined = src_default.undefined(left) || src_default.undefined(right);
  if (getObjectType3(left) !== getObjectType3(right) || hasReactElement || hasUndefined) {
    return false;
  }
  if (src_default.domElement(left)) {
    return left.isSameNode(right);
  }
  if (src_default.number(left)) {
    return left === right;
  }
  if (src_default["function"](left)) {
    return left.toString() === right.toString();
  }
  for (var key in left) {
    if (hasOwnProperty(left, key)) {
      if (typeof left[key] === "undefined" || typeof right[key] === "undefined") {
        return false;
      }
      type = getObjectType3(left[key]);
      if (["object", "array"].indexOf(type) !== -1 && isEqual(left[key], right[key])) {
        continue;
      }
      if (type === "function" && isEqual(left[key], right[key])) {
        continue;
      }
      if (left[key] !== right[key]) {
        return false;
      }
    }
  }
  for (var p in right) {
    if (hasOwnProperty(right, p)) {
      if (typeof left[p] === "undefined") {
        return false;
      }
    }
  }
  return true;
}
function isLegacy() {
  return !(["chrome", "safari", "firefox", "opera"].indexOf(getBrowser()) !== -1);
}
function log2(_ref) {
  var title = _ref.title, data = _ref.data, _ref$warn = _ref.warn, warn = _ref$warn === void 0 ? false : _ref$warn, _ref$debug = _ref.debug, debug = _ref$debug === void 0 ? false : _ref$debug;
  var logFn = warn ? console.warn || console.error : console.log;
  if (debug) {
    if (title && data) {
      console.groupCollapsed("%creact-joyride: ".concat(title), "color: #ff0044; font-weight: bold; font-size: 12px;");
      if (Array.isArray(data)) {
        data.forEach(function(d) {
          if (src_default.plainObject(d) && d.key) {
            logFn.apply(console, [d.key, d.value]);
          } else {
            logFn.apply(console, [d]);
          }
        });
      } else {
        logFn.apply(console, [data]);
      }
      console.groupEnd();
    } else {
      console.error("Missing title or data props");
    }
  }
}
var defaultState = {
  action: "",
  controlled: false,
  index: 0,
  lifecycle: LIFECYCLE.INIT,
  size: 0,
  status: STATUS2.IDLE
};
var validKeys = ["action", "index", "lifecycle", "status"];
function createStore(props) {
  var store = /* @__PURE__ */ new Map();
  var data = /* @__PURE__ */ new Map();
  var Store = function() {
    function Store2() {
      var _this = this;
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$continuous = _ref.continuous, continuous = _ref$continuous === void 0 ? false : _ref$continuous, stepIndex = _ref.stepIndex, _ref$steps = _ref.steps, _steps = _ref$steps === void 0 ? [] : _ref$steps;
      _classCallCheck2(this, Store2);
      _defineProperty2(this, "listener", void 0);
      _defineProperty2(this, "setSteps", function(steps) {
        var _this$getState = _this.getState(), size = _this$getState.size, status = _this$getState.status;
        var state = {
          size: steps.length,
          status
        };
        data.set("steps", steps);
        if (status === STATUS2.WAITING && !size && steps.length) {
          state.status = STATUS2.RUNNING;
        }
        _this.setState(state);
      });
      _defineProperty2(this, "addListener", function(listener) {
        _this.listener = listener;
      });
      _defineProperty2(this, "update", function(state) {
        if (!hasValidKeys(state, validKeys)) {
          throw new Error("State is not valid. Valid keys: ".concat(validKeys.join(", ")));
        }
        _this.setState(_objectSpread22({}, _this.getNextState(_objectSpread22(_objectSpread22(_objectSpread22({}, _this.getState()), state), {}, {
          action: state.action || ACTIONS.UPDATE
        }), true)));
      });
      _defineProperty2(this, "start", function(nextIndex) {
        var _this$getState2 = _this.getState(), index = _this$getState2.index, size = _this$getState2.size;
        _this.setState(_objectSpread22(_objectSpread22({}, _this.getNextState({
          action: ACTIONS.START,
          index: src_default.number(nextIndex) ? nextIndex : index
        }, true)), {}, {
          status: size ? STATUS2.RUNNING : STATUS2.WAITING
        }));
      });
      _defineProperty2(this, "stop", function() {
        var advance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        var _this$getState3 = _this.getState(), index = _this$getState3.index, status = _this$getState3.status;
        if ([STATUS2.FINISHED, STATUS2.SKIPPED].indexOf(status) !== -1)
          return;
        _this.setState(_objectSpread22(_objectSpread22({}, _this.getNextState({
          action: ACTIONS.STOP,
          index: index + (advance ? 1 : 0)
        })), {}, {
          status: STATUS2.PAUSED
        }));
      });
      _defineProperty2(this, "close", function() {
        var _this$getState4 = _this.getState(), index = _this$getState4.index, status = _this$getState4.status;
        if (status !== STATUS2.RUNNING)
          return;
        _this.setState(_objectSpread22({}, _this.getNextState({
          action: ACTIONS.CLOSE,
          index: index + 1
        })));
      });
      _defineProperty2(this, "go", function(nextIndex) {
        var _this$getState5 = _this.getState(), controlled = _this$getState5.controlled, status = _this$getState5.status;
        if (controlled || status !== STATUS2.RUNNING)
          return;
        var step = _this.getSteps()[nextIndex];
        _this.setState(_objectSpread22(_objectSpread22({}, _this.getNextState({
          action: ACTIONS.GO,
          index: nextIndex
        })), {}, {
          status: step ? status : STATUS2.FINISHED
        }));
      });
      _defineProperty2(this, "info", function() {
        return _this.getState();
      });
      _defineProperty2(this, "next", function() {
        var _this$getState6 = _this.getState(), index = _this$getState6.index, status = _this$getState6.status;
        if (status !== STATUS2.RUNNING)
          return;
        _this.setState(_this.getNextState({
          action: ACTIONS.NEXT,
          index: index + 1
        }));
      });
      _defineProperty2(this, "open", function() {
        var _this$getState7 = _this.getState(), status = _this$getState7.status;
        if (status !== STATUS2.RUNNING)
          return;
        _this.setState(_objectSpread22({}, _this.getNextState({
          action: ACTIONS.UPDATE,
          lifecycle: LIFECYCLE.TOOLTIP
        })));
      });
      _defineProperty2(this, "prev", function() {
        var _this$getState8 = _this.getState(), index = _this$getState8.index, status = _this$getState8.status;
        if (status !== STATUS2.RUNNING)
          return;
        _this.setState(_objectSpread22({}, _this.getNextState({
          action: ACTIONS.PREV,
          index: index - 1
        })));
      });
      _defineProperty2(this, "reset", function() {
        var restart = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        var _this$getState9 = _this.getState(), controlled = _this$getState9.controlled;
        if (controlled)
          return;
        _this.setState(_objectSpread22(_objectSpread22({}, _this.getNextState({
          action: ACTIONS.RESET,
          index: 0
        })), {}, {
          status: restart ? STATUS2.RUNNING : STATUS2.READY
        }));
      });
      _defineProperty2(this, "skip", function() {
        var _this$getState10 = _this.getState(), status = _this$getState10.status;
        if (status !== STATUS2.RUNNING)
          return;
        _this.setState({
          action: ACTIONS.SKIP,
          lifecycle: LIFECYCLE.INIT,
          status: STATUS2.SKIPPED
        });
      });
      this.setState({
        action: ACTIONS.INIT,
        controlled: src_default.number(stepIndex),
        continuous,
        index: src_default.number(stepIndex) ? stepIndex : 0,
        lifecycle: LIFECYCLE.INIT,
        status: _steps.length ? STATUS2.READY : STATUS2.IDLE
      }, true);
      this.setSteps(_steps);
    }
    _createClass2(Store2, [{
      key: "setState",
      value: function setState(nextState) {
        var initial = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var state = this.getState();
        var _state$nextState = _objectSpread22(_objectSpread22({}, state), nextState), action = _state$nextState.action, index = _state$nextState.index, lifecycle = _state$nextState.lifecycle, size = _state$nextState.size, status = _state$nextState.status;
        store.set("action", action);
        store.set("index", index);
        store.set("lifecycle", lifecycle);
        store.set("size", size);
        store.set("status", status);
        if (initial) {
          store.set("controlled", nextState.controlled);
          store.set("continuous", nextState.continuous);
        }
        if (this.listener && this.hasUpdatedState(state)) {
          this.listener(this.getState());
        }
      }
    }, {
      key: "getState",
      value: function getState() {
        if (!store.size) {
          return _objectSpread22({}, defaultState);
        }
        return {
          action: store.get("action") || "",
          controlled: store.get("controlled") || false,
          index: parseInt(store.get("index"), 10),
          lifecycle: store.get("lifecycle") || "",
          size: store.get("size") || 0,
          status: store.get("status") || ""
        };
      }
    }, {
      key: "getNextState",
      value: function getNextState(state) {
        var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var _this$getState11 = this.getState(), action = _this$getState11.action, controlled = _this$getState11.controlled, index = _this$getState11.index, size = _this$getState11.size, status = _this$getState11.status;
        var newIndex = src_default.number(state.index) ? state.index : index;
        var nextIndex = controlled && !force ? index : Math.min(Math.max(newIndex, 0), size);
        return {
          action: state.action || action,
          controlled,
          index: nextIndex,
          lifecycle: state.lifecycle || LIFECYCLE.INIT,
          size: state.size || size,
          status: nextIndex === size ? STATUS2.FINISHED : state.status || status
        };
      }
    }, {
      key: "hasUpdatedState",
      value: function hasUpdatedState(oldState) {
        var before = JSON.stringify(oldState);
        var after = JSON.stringify(this.getState());
        return before !== after;
      }
    }, {
      key: "getSteps",
      value: function getSteps() {
        var steps = data.get("steps");
        return Array.isArray(steps) ? steps : [];
      }
    }, {
      key: "getHelpers",
      value: function getHelpers2() {
        return {
          close: this.close,
          go: this.go,
          info: this.info,
          next: this.next,
          open: this.open,
          prev: this.prev,
          reset: this.reset,
          skip: this.skip
        };
      }
    }]);
    return Store2;
  }();
  return new Store(props);
}
function getClientRect2(element) {
  if (!element) {
    return {};
  }
  return element.getBoundingClientRect();
}
function getDocumentHeight() {
  var _document = document, body = _document.body, html = _document.documentElement;
  if (!body || !html) {
    return 0;
  }
  return Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
}
function getElement(element) {
  if (typeof element === "string") {
    return document.querySelector(element);
  }
  return element;
}
function getStyleComputedProperty2(el) {
  if (!el || el.nodeType !== 1) {
    return {};
  }
  return getComputedStyle(el);
}
function getScrollParent2(element, skipFix, forListener) {
  var parent = (0, import_scrollparent.default)(element);
  if (parent.isSameNode(scrollDoc())) {
    if (forListener) {
      return document;
    }
    return scrollDoc();
  }
  var hasScrolling = parent.scrollHeight > parent.offsetHeight;
  if (!hasScrolling && !skipFix) {
    parent.style.overflow = "initial";
    return scrollDoc();
  }
  return parent;
}
function hasCustomScrollParent(element, skipFix) {
  if (!element)
    return false;
  var parent = getScrollParent2(element, skipFix);
  return !parent.isSameNode(scrollDoc());
}
function hasCustomOffsetParent(element) {
  return element.offsetParent !== document.body;
}
function hasPosition(el) {
  var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "fixed";
  if (!el || !(el instanceof HTMLElement)) {
    return false;
  }
  var nodeName = el.nodeName;
  if (nodeName === "BODY" || nodeName === "HTML") {
    return false;
  }
  if (getStyleComputedProperty2(el).position === type) {
    return true;
  }
  return hasPosition(el.parentNode, type);
}
function isElementVisible(element) {
  if (!element)
    return false;
  var parentElement = element;
  while (parentElement) {
    if (parentElement === document.body)
      break;
    if (parentElement instanceof HTMLElement) {
      var _getComputedStyle = getComputedStyle(parentElement), display = _getComputedStyle.display, visibility = _getComputedStyle.visibility;
      if (display === "none" || visibility === "hidden") {
        return false;
      }
    }
    parentElement = parentElement.parentNode;
  }
  return true;
}
function getElementPosition(element, offset2, skipFix) {
  var elementRect = getClientRect2(element);
  var parent = getScrollParent2(element, skipFix);
  var hasScrollParent = hasCustomScrollParent(element, skipFix);
  var parentTop = 0;
  if (parent instanceof HTMLElement) {
    parentTop = parent.scrollTop;
  }
  var top = elementRect.top + (!hasScrollParent && !hasPosition(element) ? parentTop : 0);
  return Math.floor(top - offset2);
}
function getTopOffset(element) {
  if (element instanceof HTMLElement) {
    if (element.offsetParent instanceof HTMLElement) {
      return getTopOffset(element.offsetParent) + element.offsetTop;
    }
    return element.offsetTop;
  }
  return 0;
}
function getScrollTo(element, offset2, skipFix) {
  if (!element) {
    return 0;
  }
  var parent = (0, import_scrollparent.default)(element);
  var top = getTopOffset(element);
  if (hasCustomScrollParent(element, skipFix) && !hasCustomOffsetParent(element)) {
    top -= getTopOffset(parent);
  }
  return Math.floor(top - offset2);
}
function scrollDoc() {
  return document.scrollingElement || document.createElement("body");
}
function scrollTo(value) {
  var element = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : scrollDoc();
  var scrollDuration = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 300;
  return new Promise(function(resolve, reject) {
    var scrollTop = element.scrollTop;
    var limit = value > scrollTop ? value - scrollTop : scrollTop - value;
    import_scroll.default.top(element, value, {
      duration: limit < 100 ? 50 : scrollDuration
    }, function(error) {
      if (error && error.message !== "Element already at target scroll position") {
        return reject(error);
      }
      return resolve();
    });
  });
}
function createChainableTypeChecker(validate) {
  function checkType(isRequired, props, propName, componentName, location, propFullName) {
    var componentNameSafe = componentName || "<<anonymous>>";
    var propFullNameSafe = propFullName || propName;
    if (props[propName] == null) {
      if (isRequired) {
        return new Error("Required ".concat(location, " `").concat(propFullNameSafe, "` was not specified in `").concat(componentNameSafe, "`."));
      }
      return null;
    }
    for (var _len = arguments.length, args = new Array(_len > 6 ? _len - 6 : 0), _key = 6; _key < _len; _key++) {
      args[_key - 6] = arguments[_key];
    }
    return validate.apply(void 0, [props, propName, componentNameSafe, location, propFullNameSafe].concat(args));
  }
  var chainedCheckType = checkType.bind(null, false);
  chainedCheckType.isRequired = checkType.bind(null, true);
  return chainedCheckType;
}
createChainableTypeChecker(function(props, propName, componentName, location, propFullName) {
  var propValue = props[propName];
  var Component = propValue;
  if (!import_react2.default.isValidElement(propValue) && (0, import_react_is.isValidElementType)(propValue)) {
    var ownProps = {
      ref: function ref() {
      },
      step: {}
    };
    Component = import_react2.default.createElement(Component, ownProps);
  }
  if (src_default.string(propValue) || src_default.number(propValue) || !(0, import_react_is.isValidElementType)(propValue) || !([import_react_is.Element, import_react_is.ForwardRef].indexOf((0, import_react_is.typeOf)(Component)) !== -1)) {
    return new Error("Invalid ".concat(location, " `").concat(propFullName, "` supplied to `").concat(componentName, "`. Expected a React class or forwardRef."));
  }
  return void 0;
});
var defaultOptions2 = {
  arrowColor: "#fff",
  backgroundColor: "#fff",
  beaconSize: 36,
  overlayColor: "rgba(0, 0, 0, 0.5)",
  primaryColor: "#f04",
  spotlightShadow: "0 0 15px rgba(0, 0, 0, 0.5)",
  textColor: "#333",
  zIndex: 100
};
var buttonBase = {
  backgroundColor: "transparent",
  border: 0,
  borderRadius: 0,
  color: "#555",
  cursor: "pointer",
  fontSize: 16,
  lineHeight: 1,
  padding: 8,
  WebkitAppearance: "none"
};
var spotlight = {
  borderRadius: 4,
  position: "absolute"
};
function getStyles2() {
  var stepStyles = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var options = (0, import_deepmerge2.default)(defaultOptions2, stepStyles.options || {});
  var width = 290;
  if (window.innerWidth > 480) {
    width = 380;
  }
  if (options.width) {
    if (window.innerWidth < options.width) {
      width = window.innerWidth - 30;
    } else {
      width = options.width;
    }
  }
  var overlay = {
    bottom: 0,
    left: 0,
    overflow: "hidden",
    position: "absolute",
    right: 0,
    top: 0,
    zIndex: options.zIndex
  };
  var defaultStyles = {
    beacon: _objectSpread22(_objectSpread22({}, buttonBase), {}, {
      display: "inline-block",
      height: options.beaconSize,
      position: "relative",
      width: options.beaconSize,
      zIndex: options.zIndex
    }),
    beaconInner: {
      animation: "joyride-beacon-inner 1.2s infinite ease-in-out",
      backgroundColor: options.primaryColor,
      borderRadius: "50%",
      display: "block",
      height: "50%",
      left: "50%",
      opacity: 0.7,
      position: "absolute",
      top: "50%",
      transform: "translate(-50%, -50%)",
      width: "50%"
    },
    beaconOuter: {
      animation: "joyride-beacon-outer 1.2s infinite ease-in-out",
      backgroundColor: "rgba(".concat(hexToRGB(options.primaryColor).join(","), ", 0.2)"),
      border: "2px solid ".concat(options.primaryColor),
      borderRadius: "50%",
      boxSizing: "border-box",
      display: "block",
      height: "100%",
      left: 0,
      opacity: 0.9,
      position: "absolute",
      top: 0,
      transformOrigin: "center",
      width: "100%"
    },
    tooltip: {
      backgroundColor: options.backgroundColor,
      borderRadius: 5,
      boxSizing: "border-box",
      color: options.textColor,
      fontSize: 16,
      maxWidth: "100%",
      padding: 15,
      position: "relative",
      width
    },
    tooltipContainer: {
      lineHeight: 1.4,
      textAlign: "center"
    },
    tooltipTitle: {
      fontSize: 18,
      margin: 0
    },
    tooltipContent: {
      padding: "20px 10px"
    },
    tooltipFooter: {
      alignItems: "center",
      display: "flex",
      justifyContent: "flex-end",
      marginTop: 15
    },
    tooltipFooterSpacer: {
      flex: 1
    },
    buttonNext: _objectSpread22(_objectSpread22({}, buttonBase), {}, {
      backgroundColor: options.primaryColor,
      borderRadius: 4,
      color: "#fff"
    }),
    buttonBack: _objectSpread22(_objectSpread22({}, buttonBase), {}, {
      color: options.primaryColor,
      marginLeft: "auto",
      marginRight: 5
    }),
    buttonClose: _objectSpread22(_objectSpread22({}, buttonBase), {}, {
      color: options.textColor,
      height: 14,
      padding: 15,
      position: "absolute",
      right: 0,
      top: 0,
      width: 14
    }),
    buttonSkip: _objectSpread22(_objectSpread22({}, buttonBase), {}, {
      color: options.textColor,
      fontSize: 14
    }),
    overlay: _objectSpread22(_objectSpread22({}, overlay), {}, {
      backgroundColor: options.overlayColor,
      mixBlendMode: "hard-light"
    }),
    overlayLegacy: _objectSpread22({}, overlay),
    overlayLegacyCenter: _objectSpread22(_objectSpread22({}, overlay), {}, {
      backgroundColor: options.overlayColor
    }),
    spotlight: _objectSpread22(_objectSpread22({}, spotlight), {}, {
      backgroundColor: "gray"
    }),
    spotlightLegacy: _objectSpread22(_objectSpread22({}, spotlight), {}, {
      boxShadow: "0 0 0 9999px ".concat(options.overlayColor, ", ").concat(options.spotlightShadow)
    }),
    floaterStyles: {
      arrow: {
        color: options.arrowColor
      },
      options: {
        zIndex: options.zIndex + 100
      }
    },
    options
  };
  return (0, import_deepmerge2.default)(defaultStyles, stepStyles);
}
var DEFAULTS2 = {
  floaterProps: {
    options: {
      preventOverflow: {
        boundariesElement: "scrollParent"
      }
    },
    wrapperOptions: {
      offset: -18,
      position: true
    }
  },
  locale: {
    back: "Back",
    close: "Close",
    last: "Last",
    next: "Next",
    open: "Open the dialog",
    skip: "Skip"
  },
  step: {
    event: "click",
    placement: "bottom",
    offset: 10
  }
};
function getTourProps(props) {
  var sharedTourProps = ["beaconComponent", "disableCloseOnEsc", "disableOverlay", "disableOverlayClose", "disableScrolling", "disableScrollParentFix", "floaterProps", "hideBackButton", "hideCloseButton", "locale", "showProgress", "showSkipButton", "spotlightClicks", "spotlightPadding", "styles", "tooltipComponent"];
  return Object.keys(props).filter(function(d) {
    return sharedTourProps.indexOf(d) !== -1;
  }).reduce(function(acc, i) {
    acc[i] = props[i];
    return acc;
  }, {});
}
function getMergedStep(step, props) {
  if (!step)
    return null;
  var mergedStep = import_deepmerge2.default.all([getTourProps(props), DEFAULTS2.step, step], {
    isMergeableObject: src_default.plainObject
  });
  var mergedStyles = getStyles2((0, import_deepmerge2.default)(props.styles || {}, step.styles || {}));
  var scrollParent2 = hasCustomScrollParent(getElement(step.target), mergedStep.disableScrollParentFix);
  var floaterProps = import_deepmerge2.default.all([props.floaterProps || {}, DEFAULTS2.floaterProps, mergedStep.floaterProps || {}]);
  floaterProps.offset = mergedStep.offset;
  floaterProps.styles = (0, import_deepmerge2.default)(floaterProps.styles || {}, mergedStyles.floaterStyles || {});
  delete mergedStyles.floaterStyles;
  floaterProps.offset += props.spotlightPadding || step.spotlightPadding || 0;
  if (step.placementBeacon) {
    floaterProps.wrapperOptions.placement = step.placementBeacon;
  }
  if (scrollParent2) {
    floaterProps.options.preventOverflow.boundariesElement = "window";
  }
  return _objectSpread22(_objectSpread22({}, mergedStep), {}, {
    locale: import_deepmerge2.default.all([DEFAULTS2.locale, props.locale || {}, mergedStep.locale || {}]),
    floaterProps,
    styles: mergedStyles
  });
}
function validateStep(step) {
  var debug = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  if (!src_default.plainObject(step)) {
    log2({
      title: "validateStep",
      data: "step must be an object",
      warn: true,
      debug
    });
    return false;
  }
  if (!step.target) {
    log2({
      title: "validateStep",
      data: "target is missing from the step",
      warn: true,
      debug
    });
    return false;
  }
  return true;
}
function validateSteps(steps) {
  var debug = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  if (!src_default.array(steps)) {
    log2({
      title: "validateSteps",
      data: "steps must be an array",
      warn: true,
      debug
    });
    return false;
  }
  return steps.every(function(d) {
    return validateStep(d, debug);
  });
}
var Scope = _createClass2(function Scope2(_element) {
  var _this = this;
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  _classCallCheck2(this, Scope2);
  _defineProperty2(this, "element", void 0);
  _defineProperty2(this, "options", void 0);
  _defineProperty2(this, "canBeTabbed", function(element) {
    var tabIndex = element.tabIndex;
    if (tabIndex === null || tabIndex < 0)
      tabIndex = void 0;
    var isTabIndexNaN = isNaN(tabIndex);
    return !isTabIndexNaN && _this.canHaveFocus(element);
  });
  _defineProperty2(this, "canHaveFocus", function(element) {
    var validTabNodes = /input|select|textarea|button|object/;
    var nodeName = element.nodeName.toLowerCase();
    var res = validTabNodes.test(nodeName) && !element.getAttribute("disabled") || nodeName === "a" && !!element.getAttribute("href");
    return res && _this.isVisible(element);
  });
  _defineProperty2(this, "findValidTabElements", function() {
    return [].slice.call(_this.element.querySelectorAll("*"), 0).filter(_this.canBeTabbed);
  });
  _defineProperty2(this, "handleKeyDown", function(e) {
    var _this$options$keyCode = _this.options.keyCode, keyCode = _this$options$keyCode === void 0 ? 9 : _this$options$keyCode;
    if (e.keyCode === keyCode) {
      _this.interceptTab(e);
    }
  });
  _defineProperty2(this, "interceptTab", function(event) {
    var elements = _this.findValidTabElements();
    if (!elements.length) {
      return;
    }
    event.preventDefault();
    var shiftKey = event.shiftKey;
    var x = elements.indexOf(document.activeElement);
    if (x === -1 || !shiftKey && x + 1 === elements.length) {
      x = 0;
    } else if (shiftKey && x === 0) {
      x = elements.length - 1;
    } else {
      x += shiftKey ? -1 : 1;
    }
    elements[x].focus();
  });
  _defineProperty2(this, "isHidden", function(element) {
    var noSize = element.offsetWidth <= 0 && element.offsetHeight <= 0;
    var style = window.getComputedStyle(element);
    if (noSize && !element.innerHTML)
      return true;
    return noSize && style.getPropertyValue("overflow") !== "visible" || style.getPropertyValue("display") === "none";
  });
  _defineProperty2(this, "isVisible", function(element) {
    var parentElement = element;
    while (parentElement) {
      if (parentElement instanceof HTMLElement) {
        if (parentElement === document.body)
          break;
        if (_this.isHidden(parentElement))
          return false;
        parentElement = parentElement.parentNode;
      }
    }
    return true;
  });
  _defineProperty2(this, "removeScope", function() {
    window.removeEventListener("keydown", _this.handleKeyDown);
  });
  _defineProperty2(this, "checkFocus", function(target) {
    if (document.activeElement !== target) {
      target.focus();
      window.requestAnimationFrame(function() {
        return _this.checkFocus(target);
      });
    }
  });
  _defineProperty2(this, "setFocus", function() {
    var selector = _this.options.selector;
    if (!selector)
      return;
    var target = _this.element.querySelector(selector);
    if (target) {
      window.requestAnimationFrame(function() {
        return _this.checkFocus(target);
      });
    }
  });
  if (!(_element instanceof HTMLElement)) {
    throw new TypeError("Invalid parameter: element must be an HTMLElement");
  }
  this.element = _element;
  this.options = options;
  window.addEventListener("keydown", this.handleKeyDown, false);
  this.setFocus();
});
var JoyrideBeacon = function(_React$Component) {
  _inherits2(JoyrideBeacon2, _React$Component);
  var _super = _createSuper2(JoyrideBeacon2);
  function JoyrideBeacon2(props) {
    var _this;
    _classCallCheck2(this, JoyrideBeacon2);
    _this = _super.call(this, props);
    _defineProperty2(_assertThisInitialized2(_this), "setBeaconRef", function(c) {
      _this.beacon = c;
    });
    if (!props.beaconComponent) {
      var head = document.head || document.getElementsByTagName("head")[0];
      var style = document.createElement("style");
      var css = "\n        @keyframes joyride-beacon-inner {\n          20% {\n            opacity: 0.9;\n          }\n        \n          90% {\n            opacity: 0.7;\n          }\n        }\n        \n        @keyframes joyride-beacon-outer {\n          0% {\n            transform: scale(1);\n          }\n        \n          45% {\n            opacity: 0.7;\n            transform: scale(0.75);\n          }\n        \n          100% {\n            opacity: 0.9;\n            transform: scale(1);\n          }\n        }\n      ";
      style.type = "text/css";
      style.id = "joyride-beacon-animation";
      if (props.nonce !== void 0) {
        style.setAttribute("nonce", props.nonce);
      }
      style.appendChild(document.createTextNode(css));
      head.appendChild(style);
    }
    return _this;
  }
  _createClass2(JoyrideBeacon2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;
      var shouldFocus = this.props.shouldFocus;
      setTimeout(function() {
        if (src_default.domElement(_this2.beacon) && shouldFocus) {
          _this2.beacon.focus();
        }
      }, 0);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var style = document.getElementById("joyride-beacon-animation");
      if (style) {
        style.parentNode.removeChild(style);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props, beaconComponent = _this$props.beaconComponent, locale = _this$props.locale, onClickOrHover = _this$props.onClickOrHover, styles = _this$props.styles;
      var props = {
        "aria-label": locale.open,
        onClick: onClickOrHover,
        onMouseEnter: onClickOrHover,
        ref: this.setBeaconRef,
        title: locale.open
      };
      var component;
      if (beaconComponent) {
        var BeaconComponent = beaconComponent;
        component = import_react2.default.createElement(BeaconComponent, props);
      } else {
        component = import_react2.default.createElement("button", _extends2({
          key: "JoyrideBeacon",
          className: "react-joyride__beacon",
          style: styles.beacon,
          type: "button"
        }, props), import_react2.default.createElement("span", {
          style: styles.beaconInner
        }), import_react2.default.createElement("span", {
          style: styles.beaconOuter
        }));
      }
      return component;
    }
  }]);
  return JoyrideBeacon2;
}(import_react2.default.Component);
function JoyrideSpotlight(_ref) {
  var styles = _ref.styles;
  return import_react2.default.createElement("div", {
    key: "JoyrideSpotlight",
    className: "react-joyride__spotlight",
    style: styles
  });
}
var _excluded$2 = ["mixBlendMode", "zIndex"];
var JoyrideOverlay = function(_React$Component) {
  _inherits2(JoyrideOverlay2, _React$Component);
  var _super = _createSuper2(JoyrideOverlay2);
  function JoyrideOverlay2() {
    var _this;
    _classCallCheck2(this, JoyrideOverlay2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty2(_assertThisInitialized2(_this), "_isMounted", false);
    _defineProperty2(_assertThisInitialized2(_this), "state", {
      mouseOverSpotlight: false,
      isScrolling: false,
      showSpotlight: true
    });
    _defineProperty2(_assertThisInitialized2(_this), "handleMouseMove", function(e) {
      var mouseOverSpotlight = _this.state.mouseOverSpotlight;
      var _this$spotlightStyles = _this.spotlightStyles, height = _this$spotlightStyles.height, left = _this$spotlightStyles.left, position = _this$spotlightStyles.position, top = _this$spotlightStyles.top, width = _this$spotlightStyles.width;
      var offsetY = position === "fixed" ? e.clientY : e.pageY;
      var offsetX = position === "fixed" ? e.clientX : e.pageX;
      var inSpotlightHeight = offsetY >= top && offsetY <= top + height;
      var inSpotlightWidth = offsetX >= left && offsetX <= left + width;
      var inSpotlight = inSpotlightWidth && inSpotlightHeight;
      if (inSpotlight !== mouseOverSpotlight) {
        _this.updateState({
          mouseOverSpotlight: inSpotlight
        });
      }
    });
    _defineProperty2(_assertThisInitialized2(_this), "handleScroll", function() {
      var target = _this.props.target;
      var element = getElement(target);
      if (_this.scrollParent !== document) {
        var isScrolling = _this.state.isScrolling;
        if (!isScrolling) {
          _this.updateState({
            isScrolling: true,
            showSpotlight: false
          });
        }
        clearTimeout(_this.scrollTimeout);
        _this.scrollTimeout = setTimeout(function() {
          _this.updateState({
            isScrolling: false,
            showSpotlight: true
          });
        }, 50);
      } else if (hasPosition(element, "sticky")) {
        _this.updateState({});
      }
    });
    _defineProperty2(_assertThisInitialized2(_this), "handleResize", function() {
      clearTimeout(_this.resizeTimeout);
      _this.resizeTimeout = setTimeout(function() {
        if (!_this._isMounted) {
          return;
        }
        _this.forceUpdate();
      }, 100);
    });
    return _this;
  }
  _createClass2(JoyrideOverlay2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this$props = this.props;
      _this$props.debug;
      _this$props.disableScrolling;
      var disableScrollParentFix = _this$props.disableScrollParentFix, target = _this$props.target;
      var element = getElement(target);
      this.scrollParent = getScrollParent2(element, disableScrollParentFix, true);
      this._isMounted = true;
      window.addEventListener("resize", this.handleResize);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this2 = this;
      var _this$props2 = this.props, lifecycle = _this$props2.lifecycle, spotlightClicks = _this$props2.spotlightClicks;
      var _treeChanges = treeChanges(prevProps, this.props), changed = _treeChanges.changed;
      if (changed("lifecycle", LIFECYCLE.TOOLTIP)) {
        this.scrollParent.addEventListener("scroll", this.handleScroll, {
          passive: true
        });
        setTimeout(function() {
          var isScrolling = _this2.state.isScrolling;
          if (!isScrolling) {
            _this2.updateState({
              showSpotlight: true
            });
          }
        }, 100);
      }
      if (changed("spotlightClicks") || changed("disableOverlay") || changed("lifecycle")) {
        if (spotlightClicks && lifecycle === LIFECYCLE.TOOLTIP) {
          window.addEventListener("mousemove", this.handleMouseMove, false);
        } else if (lifecycle !== LIFECYCLE.TOOLTIP) {
          window.removeEventListener("mousemove", this.handleMouseMove);
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this._isMounted = false;
      window.removeEventListener("mousemove", this.handleMouseMove);
      window.removeEventListener("resize", this.handleResize);
      clearTimeout(this.resizeTimeout);
      clearTimeout(this.scrollTimeout);
      this.scrollParent.removeEventListener("scroll", this.handleScroll);
    }
  }, {
    key: "spotlightStyles",
    get: function get() {
      var showSpotlight = this.state.showSpotlight;
      var _this$props3 = this.props, disableScrollParentFix = _this$props3.disableScrollParentFix, spotlightClicks = _this$props3.spotlightClicks, spotlightPadding = _this$props3.spotlightPadding, styles = _this$props3.styles, target = _this$props3.target;
      var element = getElement(target);
      var elementRect = getClientRect2(element);
      var isFixedTarget = hasPosition(element);
      var top = getElementPosition(element, spotlightPadding, disableScrollParentFix);
      return _objectSpread22(_objectSpread22({}, isLegacy() ? styles.spotlightLegacy : styles.spotlight), {}, {
        height: Math.round(elementRect.height + spotlightPadding * 2),
        left: Math.round(elementRect.left - spotlightPadding),
        opacity: showSpotlight ? 1 : 0,
        pointerEvents: spotlightClicks ? "none" : "auto",
        position: isFixedTarget ? "fixed" : "absolute",
        top,
        transition: "opacity 0.2s",
        width: Math.round(elementRect.width + spotlightPadding * 2)
      });
    }
  }, {
    key: "updateState",
    value: function updateState(state) {
      if (!this._isMounted) {
        return;
      }
      this.setState(state);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$state = this.state, mouseOverSpotlight = _this$state.mouseOverSpotlight, showSpotlight = _this$state.showSpotlight;
      var _this$props4 = this.props, disableOverlay = _this$props4.disableOverlay, disableOverlayClose = _this$props4.disableOverlayClose, lifecycle = _this$props4.lifecycle, onClickOverlay = _this$props4.onClickOverlay, placement = _this$props4.placement, styles = _this$props4.styles;
      if (disableOverlay || lifecycle !== LIFECYCLE.TOOLTIP) {
        return null;
      }
      var baseStyles = styles.overlay;
      if (isLegacy()) {
        baseStyles = placement === "center" ? styles.overlayLegacyCenter : styles.overlayLegacy;
      }
      var stylesOverlay = _objectSpread22({
        cursor: disableOverlayClose ? "default" : "pointer",
        height: getDocumentHeight(),
        pointerEvents: mouseOverSpotlight ? "none" : "auto"
      }, baseStyles);
      var spotlight2 = placement !== "center" && showSpotlight && import_react2.default.createElement(JoyrideSpotlight, {
        styles: this.spotlightStyles
      });
      if (getBrowser() === "safari") {
        stylesOverlay.mixBlendMode;
        stylesOverlay.zIndex;
        var safarOverlay = _objectWithoutProperties2(stylesOverlay, _excluded$2);
        spotlight2 = import_react2.default.createElement("div", {
          style: _objectSpread22({}, safarOverlay)
        }, spotlight2);
        delete stylesOverlay.backgroundColor;
      }
      return import_react2.default.createElement("div", {
        className: "react-joyride__overlay",
        style: stylesOverlay,
        onClick: onClickOverlay
      }, spotlight2);
    }
  }]);
  return JoyrideOverlay2;
}(import_react2.default.Component);
var _excluded$12 = ["styles"];
var _excluded2 = ["color", "height", "width"];
function JoyrideTooltipCloseBtn(_ref) {
  var styles = _ref.styles, props = _objectWithoutProperties2(_ref, _excluded$12);
  var color = styles.color, height = styles.height, width = styles.width, style = _objectWithoutProperties2(styles, _excluded2);
  return import_react2.default.createElement("button", _extends2({
    style,
    type: "button"
  }, props), import_react2.default.createElement("svg", {
    width: typeof width === "number" ? "".concat(width, "px") : width,
    height: typeof height === "number" ? "".concat(height, "px") : height,
    viewBox: "0 0 18 18",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    preserveAspectRatio: "xMidYMid"
  }, import_react2.default.createElement("g", null, import_react2.default.createElement("path", {
    d: "M8.13911129,9.00268191 L0.171521827,17.0258467 C-0.0498027049,17.248715 -0.0498027049,17.6098394 0.171521827,17.8327545 C0.28204354,17.9443526 0.427188206,17.9998706 0.572051765,17.9998706 C0.71714958,17.9998706 0.862013139,17.9443526 0.972581703,17.8327545 L9.0000937,9.74924618 L17.0276057,17.8327545 C17.1384085,17.9443526 17.2832721,17.9998706 17.4281356,17.9998706 C17.5729992,17.9998706 17.718097,17.9443526 17.8286656,17.8327545 C18.0499901,17.6098862 18.0499901,17.2487618 17.8286656,17.0258467 L9.86135722,9.00268191 L17.8340066,0.973848225 C18.0553311,0.750979934 18.0553311,0.389855532 17.8340066,0.16694039 C17.6126821,-0.0556467968 17.254037,-0.0556467968 17.0329467,0.16694039 L9.00042166,8.25611765 L0.967006424,0.167268345 C0.745681892,-0.0553188426 0.387317931,-0.0553188426 0.165993399,0.167268345 C-0.0553311331,0.390136635 -0.0553311331,0.751261038 0.165993399,0.974176179 L8.13920499,9.00268191 L8.13911129,9.00268191 Z",
    fill: color
  }))));
}
var JoyrideTooltipContainer = function(_React$Component) {
  _inherits2(JoyrideTooltipContainer2, _React$Component);
  var _super = _createSuper2(JoyrideTooltipContainer2);
  function JoyrideTooltipContainer2() {
    _classCallCheck2(this, JoyrideTooltipContainer2);
    return _super.apply(this, arguments);
  }
  _createClass2(JoyrideTooltipContainer2, [{
    key: "render",
    value: function render() {
      var _this$props = this.props, backProps = _this$props.backProps, closeProps = _this$props.closeProps, continuous = _this$props.continuous, index = _this$props.index, isLastStep = _this$props.isLastStep, primaryProps = _this$props.primaryProps, size = _this$props.size, skipProps = _this$props.skipProps, step = _this$props.step, tooltipProps = _this$props.tooltipProps;
      var content = step.content, hideBackButton = step.hideBackButton, hideCloseButton = step.hideCloseButton, hideFooter = step.hideFooter, showProgress = step.showProgress, showSkipButton = step.showSkipButton, title = step.title, styles = step.styles;
      var _step$locale = step.locale, back = _step$locale.back, close = _step$locale.close, last = _step$locale.last, next = _step$locale.next, skip = _step$locale.skip;
      var output = {
        primary: close
      };
      if (continuous) {
        output.primary = isLastStep ? last : next;
        if (showProgress) {
          output.primary = import_react2.default.createElement("span", null, output.primary, " (", index + 1, "/", size, ")");
        }
      }
      if (showSkipButton && !isLastStep) {
        output.skip = import_react2.default.createElement("button", _extends2({
          style: styles.buttonSkip,
          type: "button",
          "aria-live": "off"
        }, skipProps), skip);
      }
      if (!hideBackButton && index > 0) {
        output.back = import_react2.default.createElement("button", _extends2({
          style: styles.buttonBack,
          type: "button"
        }, backProps), back);
      }
      output.close = !hideCloseButton && import_react2.default.createElement(JoyrideTooltipCloseBtn, _extends2({
        styles: styles.buttonClose
      }, closeProps));
      return import_react2.default.createElement("div", _extends2({
        key: "JoyrideTooltip",
        className: "react-joyride__tooltip",
        style: styles.tooltip
      }, tooltipProps), import_react2.default.createElement("div", {
        style: styles.tooltipContainer
      }, title && import_react2.default.createElement("h4", {
        style: styles.tooltipTitle,
        "aria-label": title
      }, title), import_react2.default.createElement("div", {
        style: styles.tooltipContent
      }, content)), !hideFooter && import_react2.default.createElement("div", {
        style: styles.tooltipFooter
      }, import_react2.default.createElement("div", {
        style: styles.tooltipFooterSpacer
      }, output.skip), output.back, import_react2.default.createElement("button", _extends2({
        style: styles.buttonNext,
        type: "button"
      }, primaryProps), output.primary)), output.close);
    }
  }]);
  return JoyrideTooltipContainer2;
}(import_react2.default.Component);
var _excluded3 = ["beaconComponent", "tooltipComponent"];
var JoyrideTooltip = function(_React$Component) {
  _inherits2(JoyrideTooltip2, _React$Component);
  var _super = _createSuper2(JoyrideTooltip2);
  function JoyrideTooltip2() {
    var _this;
    _classCallCheck2(this, JoyrideTooltip2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty2(_assertThisInitialized2(_this), "handleClickBack", function(e) {
      e.preventDefault();
      var helpers = _this.props.helpers;
      helpers.prev();
    });
    _defineProperty2(_assertThisInitialized2(_this), "handleClickClose", function(e) {
      e.preventDefault();
      var helpers = _this.props.helpers;
      helpers.close();
    });
    _defineProperty2(_assertThisInitialized2(_this), "handleClickPrimary", function(e) {
      e.preventDefault();
      var _this$props = _this.props, continuous = _this$props.continuous, helpers = _this$props.helpers;
      if (!continuous) {
        helpers.close();
        return;
      }
      helpers.next();
    });
    _defineProperty2(_assertThisInitialized2(_this), "handleClickSkip", function(e) {
      e.preventDefault();
      var helpers = _this.props.helpers;
      helpers.skip();
    });
    _defineProperty2(_assertThisInitialized2(_this), "getElementsProps", function() {
      var _this$props2 = _this.props, continuous = _this$props2.continuous, isLastStep = _this$props2.isLastStep, setTooltipRef = _this$props2.setTooltipRef, step = _this$props2.step;
      var back = getText(step.locale.back);
      var close = getText(step.locale.close);
      var last = getText(step.locale.last);
      var next = getText(step.locale.next);
      var skip = getText(step.locale.skip);
      var primaryText = continuous ? next : close;
      if (isLastStep) {
        primaryText = last;
      }
      return {
        backProps: {
          "aria-label": back,
          "data-action": "back",
          onClick: _this.handleClickBack,
          role: "button",
          title: back
        },
        closeProps: {
          "aria-label": close,
          "data-action": "close",
          onClick: _this.handleClickClose,
          role: "button",
          title: close
        },
        primaryProps: {
          "aria-label": primaryText,
          "data-action": "primary",
          onClick: _this.handleClickPrimary,
          role: "button",
          title: primaryText
        },
        skipProps: {
          "aria-label": skip,
          "data-action": "skip",
          onClick: _this.handleClickSkip,
          role: "button",
          title: skip
        },
        tooltipProps: {
          "aria-modal": true,
          ref: setTooltipRef,
          role: "alertdialog"
        }
      };
    });
    return _this;
  }
  _createClass2(JoyrideTooltip2, [{
    key: "render",
    value: function render() {
      var _this$props3 = this.props, continuous = _this$props3.continuous, index = _this$props3.index, isLastStep = _this$props3.isLastStep, size = _this$props3.size, step = _this$props3.step;
      step.beaconComponent;
      var tooltipComponent = step.tooltipComponent, cleanStep = _objectWithoutProperties2(step, _excluded3);
      var component;
      if (tooltipComponent) {
        var renderProps = _objectSpread22(_objectSpread22({}, this.getElementsProps()), {}, {
          continuous,
          index,
          isLastStep,
          size,
          step: cleanStep
        });
        var TooltipComponent = tooltipComponent;
        component = import_react2.default.createElement(TooltipComponent, renderProps);
      } else {
        component = import_react2.default.createElement(JoyrideTooltipContainer, _extends2({}, this.getElementsProps(), {
          continuous,
          index,
          isLastStep,
          size,
          step
        }));
      }
      return component;
    }
  }]);
  return JoyrideTooltip2;
}(import_react2.default.Component);
var JoyridePortal = function(_React$Component) {
  _inherits2(JoyridePortal2, _React$Component);
  var _super = _createSuper2(JoyridePortal2);
  function JoyridePortal2() {
    _classCallCheck2(this, JoyridePortal2);
    return _super.apply(this, arguments);
  }
  _createClass2(JoyridePortal2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (!canUseDOM2)
        return;
      if (!isReact162) {
        this.renderReact15();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      if (!canUseDOM2)
        return;
      if (!isReact162) {
        this.renderReact15();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (!canUseDOM2 || !this.node)
        return;
      if (!isReact162) {
        import_react_dom2.default.unmountComponentAtNode(this.node);
      }
      if (this.node.parentNode === document.body) {
        document.body.removeChild(this.node);
        this.node = void 0;
      }
    }
  }, {
    key: "appendNode",
    value: function appendNode() {
      var id = this.props.id;
      if (!this.node) {
        this.node = document.createElement("div");
        if (id) {
          this.node.id = id;
        }
        document.body.appendChild(this.node);
      }
    }
  }, {
    key: "renderReact15",
    value: function renderReact15() {
      if (!canUseDOM2)
        return null;
      var children = this.props.children;
      if (!this.node) {
        this.appendNode();
      }
      import_react_dom2.default.unstable_renderSubtreeIntoContainer(this, children, this.node);
      return null;
    }
  }, {
    key: "renderReact16",
    value: function renderReact16() {
      if (!canUseDOM2 || !isReact162)
        return null;
      var children = this.props.children;
      if (!this.node) {
        this.appendNode();
      }
      return import_react_dom2.default.createPortal(children, this.node);
    }
  }, {
    key: "render",
    value: function render() {
      if (!isReact162) {
        return null;
      }
      return this.renderReact16();
    }
  }]);
  return JoyridePortal2;
}(import_react2.default.Component);
var JoyrideStep = function(_React$Component) {
  _inherits2(JoyrideStep2, _React$Component);
  var _super = _createSuper2(JoyrideStep2);
  function JoyrideStep2() {
    var _this;
    _classCallCheck2(this, JoyrideStep2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty2(_assertThisInitialized2(_this), "scope", {
      removeScope: function removeScope() {
      }
    });
    _defineProperty2(_assertThisInitialized2(_this), "handleClickHoverBeacon", function(e) {
      var _this$props = _this.props, step = _this$props.step, update2 = _this$props.update;
      if (e.type === "mouseenter" && step.event !== "hover") {
        return;
      }
      update2({
        lifecycle: LIFECYCLE.TOOLTIP
      });
    });
    _defineProperty2(_assertThisInitialized2(_this), "handleClickOverlay", function() {
      var _this$props2 = _this.props, helpers = _this$props2.helpers, step = _this$props2.step;
      if (!step.disableOverlayClose) {
        helpers.close();
      }
    });
    _defineProperty2(_assertThisInitialized2(_this), "setTooltipRef", function(c) {
      _this.tooltip = c;
    });
    _defineProperty2(_assertThisInitialized2(_this), "setPopper", function(popper, type) {
      var _this$props3 = _this.props, action = _this$props3.action, setPopper = _this$props3.setPopper, update2 = _this$props3.update;
      if (type === "wrapper") {
        _this.beaconPopper = popper;
      } else {
        _this.tooltipPopper = popper;
      }
      setPopper(popper, type);
      if (_this.beaconPopper && _this.tooltipPopper) {
        update2({
          action: action === ACTIONS.CLOSE ? ACTIONS.CLOSE : action,
          lifecycle: LIFECYCLE.READY
        });
      }
    });
    return _this;
  }
  _createClass2(JoyrideStep2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this$props4 = this.props, debug = _this$props4.debug, index = _this$props4.index;
      log2({
        title: "step:".concat(index),
        data: [{
          key: "props",
          value: this.props
        }],
        debug
      });
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props5 = this.props, action = _this$props5.action, callback = _this$props5.callback, continuous = _this$props5.continuous, controlled = _this$props5.controlled, debug = _this$props5.debug, index = _this$props5.index, lifecycle = _this$props5.lifecycle, size = _this$props5.size, status = _this$props5.status, step = _this$props5.step, update2 = _this$props5.update;
      var _treeChanges = treeChanges(prevProps, this.props), changed = _treeChanges.changed, changedFrom = _treeChanges.changedFrom;
      var state = {
        action,
        controlled,
        index,
        lifecycle,
        size,
        status
      };
      var skipBeacon = continuous && action !== ACTIONS.CLOSE && (index > 0 || action === ACTIONS.PREV);
      var hasStoreChanged = changed("action") || changed("index") || changed("lifecycle") || changed("status");
      var hasStarted = changedFrom("lifecycle", [LIFECYCLE.TOOLTIP, LIFECYCLE.INIT], LIFECYCLE.INIT);
      var isAfterAction = changed("action", [ACTIONS.NEXT, ACTIONS.PREV, ACTIONS.SKIP, ACTIONS.CLOSE]);
      if (isAfterAction && (hasStarted || controlled)) {
        callback(_objectSpread22(_objectSpread22({}, state), {}, {
          index: prevProps.index,
          lifecycle: LIFECYCLE.COMPLETE,
          step: prevProps.step,
          type: EVENTS.STEP_AFTER
        }));
      }
      if (step.placement === "center" && status === STATUS2.RUNNING && changed("index") && action !== ACTIONS.START && lifecycle === LIFECYCLE.INIT) {
        update2({
          lifecycle: LIFECYCLE.READY
        });
      }
      if (hasStoreChanged) {
        var element = getElement(step.target);
        var elementExists = !!element;
        var hasRenderedTarget = elementExists && isElementVisible(element);
        if (hasRenderedTarget) {
          if (changedFrom("status", STATUS2.READY, STATUS2.RUNNING) || changedFrom("lifecycle", LIFECYCLE.INIT, LIFECYCLE.READY)) {
            callback(_objectSpread22(_objectSpread22({}, state), {}, {
              step,
              type: EVENTS.STEP_BEFORE
            }));
          }
        } else {
          console.warn(elementExists ? "Target not visible" : "Target not mounted", step);
          callback(_objectSpread22(_objectSpread22({}, state), {}, {
            type: EVENTS.TARGET_NOT_FOUND,
            step
          }));
          if (!controlled) {
            update2({
              index: index + ([ACTIONS.PREV].indexOf(action) !== -1 ? -1 : 1)
            });
          }
        }
      }
      if (changedFrom("lifecycle", LIFECYCLE.INIT, LIFECYCLE.READY)) {
        update2({
          lifecycle: hideBeacon(step) || skipBeacon ? LIFECYCLE.TOOLTIP : LIFECYCLE.BEACON
        });
      }
      if (changed("index")) {
        log2({
          title: "step:".concat(lifecycle),
          data: [{
            key: "props",
            value: this.props
          }],
          debug
        });
      }
      if (changed("lifecycle", LIFECYCLE.BEACON)) {
        callback(_objectSpread22(_objectSpread22({}, state), {}, {
          step,
          type: EVENTS.BEACON
        }));
      }
      if (changed("lifecycle", LIFECYCLE.TOOLTIP)) {
        callback(_objectSpread22(_objectSpread22({}, state), {}, {
          step,
          type: EVENTS.TOOLTIP
        }));
        this.scope = new Scope(this.tooltip, {
          selector: "[data-action=primary]"
        });
        this.scope.setFocus();
      }
      if (changedFrom("lifecycle", [LIFECYCLE.TOOLTIP, LIFECYCLE.INIT], LIFECYCLE.INIT)) {
        this.scope.removeScope();
        delete this.beaconPopper;
        delete this.tooltipPopper;
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.scope.removeScope();
    }
    /**
     * Beacon click/hover event listener
     *
     * @param {Event} e
     */
  }, {
    key: "open",
    get: function get() {
      var _this$props6 = this.props, step = _this$props6.step, lifecycle = _this$props6.lifecycle;
      return !!(hideBeacon(step) || lifecycle === LIFECYCLE.TOOLTIP);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props7 = this.props, continuous = _this$props7.continuous, debug = _this$props7.debug, helpers = _this$props7.helpers, index = _this$props7.index, lifecycle = _this$props7.lifecycle, nonce = _this$props7.nonce, shouldScroll = _this$props7.shouldScroll, size = _this$props7.size, step = _this$props7.step;
      var target = getElement(step.target);
      if (!validateStep(step) || !src_default.domElement(target)) {
        return null;
      }
      return import_react2.default.createElement("div", {
        key: "JoyrideStep-".concat(index),
        className: "react-joyride__step"
      }, import_react2.default.createElement(JoyridePortal, {
        id: "react-joyride-portal"
      }, import_react2.default.createElement(JoyrideOverlay, _extends2({}, step, {
        debug,
        lifecycle,
        onClickOverlay: this.handleClickOverlay
      }))), import_react2.default.createElement(ReactFloater, _extends2({
        component: import_react2.default.createElement(JoyrideTooltip, {
          continuous,
          helpers,
          index,
          isLastStep: index + 1 === size,
          setTooltipRef: this.setTooltipRef,
          size,
          step
        }),
        debug,
        getPopper: this.setPopper,
        id: "react-joyride-step-".concat(index),
        isPositioned: step.isFixed || hasPosition(target),
        open: this.open,
        placement: step.placement,
        target: step.target
      }, step.floaterProps), import_react2.default.createElement(JoyrideBeacon, {
        beaconComponent: step.beaconComponent,
        locale: step.locale,
        nonce,
        onClickOrHover: this.handleClickHoverBeacon,
        shouldFocus: shouldScroll,
        styles: step.styles
      })));
    }
  }]);
  return JoyrideStep2;
}(import_react2.default.Component);
var Joyride = function(_React$Component) {
  _inherits2(Joyride2, _React$Component);
  var _super = _createSuper2(Joyride2);
  function Joyride2(props) {
    var _this;
    _classCallCheck2(this, Joyride2);
    _this = _super.call(this, props);
    _defineProperty2(_assertThisInitialized2(_this), "initStore", function() {
      var _this$props = _this.props, debug = _this$props.debug, getHelpers2 = _this$props.getHelpers, run = _this$props.run, stepIndex = _this$props.stepIndex;
      _this.store = new createStore(_objectSpread22(_objectSpread22({}, _this.props), {}, {
        controlled: run && src_default.number(stepIndex)
      }));
      _this.helpers = _this.store.getHelpers();
      var addListener = _this.store.addListener;
      log2({
        title: "init",
        data: [{
          key: "props",
          value: _this.props
        }, {
          key: "state",
          value: _this.state
        }],
        debug
      });
      addListener(_this.syncState);
      getHelpers2(_this.helpers);
      return _this.store.getState();
    });
    _defineProperty2(_assertThisInitialized2(_this), "callback", function(data) {
      var callback = _this.props.callback;
      if (src_default["function"](callback)) {
        callback(data);
      }
    });
    _defineProperty2(_assertThisInitialized2(_this), "handleKeyboard", function(e) {
      var _this$state = _this.state, index = _this$state.index, lifecycle = _this$state.lifecycle;
      var steps = _this.props.steps;
      var step = steps[index];
      var intKey = window.Event ? e.which : e.keyCode;
      if (lifecycle === LIFECYCLE.TOOLTIP) {
        if (intKey === 27 && step && !step.disableCloseOnEsc) {
          _this.store.close();
        }
      }
    });
    _defineProperty2(_assertThisInitialized2(_this), "syncState", function(state) {
      _this.setState(state);
    });
    _defineProperty2(_assertThisInitialized2(_this), "setPopper", function(popper, type) {
      if (type === "wrapper") {
        _this.beaconPopper = popper;
      } else {
        _this.tooltipPopper = popper;
      }
    });
    _defineProperty2(_assertThisInitialized2(_this), "shouldScroll", function(disableScrolling, index, scrollToFirstStep, lifecycle, step, target, prevState) {
      return !disableScrolling && (index !== 0 || scrollToFirstStep || lifecycle === LIFECYCLE.TOOLTIP) && step.placement !== "center" && (!step.isFixed || !hasPosition(target)) && // fixed steps don't need to scroll
      prevState.lifecycle !== lifecycle && [LIFECYCLE.BEACON, LIFECYCLE.TOOLTIP].indexOf(lifecycle) !== -1;
    });
    _this.state = _this.initStore();
    return _this;
  }
  _createClass2(Joyride2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (!canUseDOM2)
        return;
      var _this$props2 = this.props, disableCloseOnEsc = _this$props2.disableCloseOnEsc, debug = _this$props2.debug, run = _this$props2.run, steps = _this$props2.steps;
      var start = this.store.start;
      if (validateSteps(steps, debug) && run) {
        start();
      }
      if (!disableCloseOnEsc) {
        document.body.addEventListener("keydown", this.handleKeyboard, {
          passive: true
        });
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      if (!canUseDOM2)
        return;
      var _this$state2 = this.state, action = _this$state2.action, controlled = _this$state2.controlled, index = _this$state2.index, lifecycle = _this$state2.lifecycle, status = _this$state2.status;
      var _this$props3 = this.props, debug = _this$props3.debug, run = _this$props3.run, stepIndex = _this$props3.stepIndex, steps = _this$props3.steps;
      var prevSteps = prevProps.steps, prevStepIndex = prevProps.stepIndex;
      var _this$store = this.store, reset = _this$store.reset, setSteps = _this$store.setSteps, start = _this$store.start, stop = _this$store.stop, update2 = _this$store.update;
      var _treeChanges = treeChanges(prevProps, this.props), changedProps = _treeChanges.changed;
      var _treeChanges2 = treeChanges(prevState, this.state), changed = _treeChanges2.changed, changedFrom = _treeChanges2.changedFrom;
      var step = getMergedStep(steps[index], this.props);
      var stepsChanged = !isEqual(prevSteps, steps);
      var stepIndexChanged = src_default.number(stepIndex) && changedProps("stepIndex");
      var target = getElement(step === null || step === void 0 ? void 0 : step.target);
      if (stepsChanged) {
        if (validateSteps(steps, debug)) {
          setSteps(steps);
        } else {
          console.warn("Steps are not valid", steps);
        }
      }
      if (changedProps("run")) {
        if (run) {
          start(stepIndex);
        } else {
          stop();
        }
      }
      if (stepIndexChanged) {
        var nextAction = prevStepIndex < stepIndex ? ACTIONS.NEXT : ACTIONS.PREV;
        if (action === ACTIONS.STOP) {
          nextAction = ACTIONS.START;
        }
        if (!([STATUS2.FINISHED, STATUS2.SKIPPED].indexOf(status) !== -1)) {
          update2({
            action: action === ACTIONS.CLOSE ? ACTIONS.CLOSE : nextAction,
            index: stepIndex,
            lifecycle: LIFECYCLE.INIT
          });
        }
      }
      if (!controlled && status === STATUS2.RUNNING && index === 0 && !target) {
        update2({
          index: index + 1
        });
        this.callback(_objectSpread22(_objectSpread22({}, this.state), {}, {
          type: EVENTS.TARGET_NOT_FOUND,
          step
        }));
      }
      var callbackData = _objectSpread22(_objectSpread22({}, this.state), {}, {
        index,
        step
      });
      var isAfterAction = changed("action", [ACTIONS.NEXT, ACTIONS.PREV, ACTIONS.SKIP, ACTIONS.CLOSE]);
      if (isAfterAction && changed("status", STATUS2.PAUSED)) {
        var prevStep = getMergedStep(steps[prevState.index], this.props);
        this.callback(_objectSpread22(_objectSpread22({}, callbackData), {}, {
          index: prevState.index,
          lifecycle: LIFECYCLE.COMPLETE,
          step: prevStep,
          type: EVENTS.STEP_AFTER
        }));
      }
      if (changed("status", [STATUS2.FINISHED, STATUS2.SKIPPED])) {
        var _prevStep = getMergedStep(steps[prevState.index], this.props);
        if (!controlled) {
          this.callback(_objectSpread22(_objectSpread22({}, callbackData), {}, {
            index: prevState.index,
            lifecycle: LIFECYCLE.COMPLETE,
            step: _prevStep,
            type: EVENTS.STEP_AFTER
          }));
        }
        this.callback(_objectSpread22(_objectSpread22({}, callbackData), {}, {
          index: prevState.index,
          // Return the last step when the tour is finished
          step: _prevStep,
          type: EVENTS.TOUR_END
        }));
        reset();
      } else if (changedFrom("status", [STATUS2.IDLE, STATUS2.READY], STATUS2.RUNNING)) {
        this.callback(_objectSpread22(_objectSpread22({}, callbackData), {}, {
          type: EVENTS.TOUR_START
        }));
      } else if (changed("status")) {
        this.callback(_objectSpread22(_objectSpread22({}, callbackData), {}, {
          type: EVENTS.TOUR_STATUS
        }));
      } else if (changed("action", ACTIONS.RESET)) {
        this.callback(_objectSpread22(_objectSpread22({}, callbackData), {}, {
          type: EVENTS.TOUR_STATUS
        }));
      }
      if (step) {
        this.scrollToStep(prevState);
        if (step.placement === "center" && status === STATUS2.RUNNING && action === ACTIONS.START && lifecycle === LIFECYCLE.INIT) {
          update2({
            lifecycle: LIFECYCLE.READY
          });
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var disableCloseOnEsc = this.props.disableCloseOnEsc;
      if (!disableCloseOnEsc) {
        document.body.removeEventListener("keydown", this.handleKeyboard);
      }
    }
  }, {
    key: "scrollToStep",
    value: function scrollToStep(prevState) {
      var _this$state3 = this.state, index = _this$state3.index, lifecycle = _this$state3.lifecycle, status = _this$state3.status;
      var _this$props4 = this.props, debug = _this$props4.debug, disableScrolling = _this$props4.disableScrolling, disableScrollParentFix = _this$props4.disableScrollParentFix, scrollToFirstStep = _this$props4.scrollToFirstStep, scrollOffset = _this$props4.scrollOffset, scrollDuration = _this$props4.scrollDuration, steps = _this$props4.steps;
      var step = getMergedStep(steps[index], this.props);
      if (step) {
        var target = getElement(step.target);
        var shouldScroll = this.shouldScroll(disableScrolling, index, scrollToFirstStep, lifecycle, step, target, prevState);
        if (status === STATUS2.RUNNING && shouldScroll) {
          var hasCustomScroll = hasCustomScrollParent(target, disableScrollParentFix);
          var scrollParent2 = getScrollParent2(target, disableScrollParentFix);
          var scrollY = Math.floor(getScrollTo(target, scrollOffset, disableScrollParentFix)) || 0;
          log2({
            title: "scrollToStep",
            data: [{
              key: "index",
              value: index
            }, {
              key: "lifecycle",
              value: lifecycle
            }, {
              key: "status",
              value: status
            }],
            debug
          });
          if (lifecycle === LIFECYCLE.BEACON && this.beaconPopper) {
            var _this$beaconPopper = this.beaconPopper, placement = _this$beaconPopper.placement, popper = _this$beaconPopper.popper;
            if (!(["bottom"].indexOf(placement) !== -1) && !hasCustomScroll) {
              scrollY = Math.floor(popper.top - scrollOffset);
            }
          } else if (lifecycle === LIFECYCLE.TOOLTIP && this.tooltipPopper) {
            var _this$tooltipPopper = this.tooltipPopper, flipped = _this$tooltipPopper.flipped, _placement = _this$tooltipPopper.placement, _popper = _this$tooltipPopper.popper;
            if (["top", "right", "left"].indexOf(_placement) !== -1 && !flipped && !hasCustomScroll) {
              scrollY = Math.floor(_popper.top - scrollOffset);
            } else {
              scrollY -= step.spotlightPadding;
            }
          }
          scrollY = scrollY >= 0 ? scrollY : 0;
          if (status === STATUS2.RUNNING) {
            scrollTo(scrollY, scrollParent2, scrollDuration);
          }
        }
      }
    }
    /**
     * Trigger the callback.
     *
     * @private
     * @param {Object} data
     */
  }, {
    key: "render",
    value: function render() {
      if (!canUseDOM2)
        return null;
      var _this$state4 = this.state, index = _this$state4.index, status = _this$state4.status;
      var _this$props5 = this.props, continuous = _this$props5.continuous, debug = _this$props5.debug, nonce = _this$props5.nonce, scrollToFirstStep = _this$props5.scrollToFirstStep, steps = _this$props5.steps;
      var step = getMergedStep(steps[index], this.props);
      var output;
      if (status === STATUS2.RUNNING && step) {
        output = import_react2.default.createElement(JoyrideStep, _extends2({}, this.state, {
          callback: this.callback,
          continuous,
          debug,
          setPopper: this.setPopper,
          helpers: this.helpers,
          nonce,
          shouldScroll: !step.disableScrolling && (index !== 0 || scrollToFirstStep),
          step,
          update: this.store.update
        }));
      }
      return import_react2.default.createElement("div", {
        className: "react-joyride"
      }, output);
    }
  }]);
  return Joyride2;
}(import_react2.default.Component);
_defineProperty2(Joyride, "defaultProps", {
  continuous: false,
  debug: false,
  disableCloseOnEsc: false,
  disableOverlay: false,
  disableOverlayClose: false,
  disableScrolling: false,
  disableScrollParentFix: false,
  getHelpers: function getHelpers() {
  },
  hideBackButton: false,
  run: true,
  scrollOffset: 20,
  scrollDuration: 300,
  scrollToFirstStep: false,
  showSkipButton: false,
  showProgress: false,
  spotlightClicks: false,
  spotlightPadding: 10,
  steps: []
});
export {
  ACTIONS,
  EVENTS,
  LIFECYCLE,
  STATUS2 as STATUS,
  Joyride as default
};
/*! Bundled license information:

exenv/index.js:
  (*!
    Copyright (c) 2015 Jed Watson.
    Based on code that is Copyright 2013-2015, Facebook, Inc.
    All rights reserved.
  *)

popper.js/dist/esm/popper.js:
  (**!
   * @fileOverview Kickass library to create and place poppers near their reference elements.
   * @version 1.16.1
   * @license
   * Copyright (c) 2016 Federico Zivolo and contributors
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   *)
*/
//# sourceMappingURL=react-joyride.js.map
