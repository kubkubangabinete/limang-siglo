{"version":3,"file":"functions.cjs","sources":["../src/utils.ts","../src/center.ts","../src/get-node-scene.ts","../src/clear-node-parent.ts","../../../node_modules/gl-matrix/esm/common.js","../../../node_modules/gl-matrix/esm/mat4.js","../../../node_modules/gl-matrix/esm/mat3.js","../../../node_modules/gl-matrix/esm/vec3.js","../../../node_modules/gl-matrix/esm/vec4.js","../src/transform-primitive.ts","../src/transform-mesh.ts","../src/clear-node-transform.ts","../src/colorspace.ts","../src/dedup.ts","../src/dequantize.ts","../src/draco.ts","../src/prune.ts","../src/flatten.ts","../src/inspect.ts","../src/instance.ts","../src/join-primitives.ts","../src/join.ts","../src/reorder.ts","../src/sort-primitive-weights.ts","../src/quantize.ts","../src/meshopt.ts","../src/metal-rough.ts","../src/unweld.ts","../src/normals.ts","../src/partition.ts","../../../node_modules/gl-matrix/esm/quat.js","../src/resample.ts","../src/sequence.ts","../src/weld.ts","../src/simplify.ts","../src/sparse.ts","../src/list-texture-channels.ts","../src/list-texture-slots.ts","../src/texture-resize.ts","../src/texture-compress.ts","../src/tangents.ts","../src/unlit.ts","../src/unpartition.ts","../src/list-texture-info.ts"],"sourcesContent":["import type { NdArray } from 'ndarray';\nimport { getPixels, savePixels } from 'ndarray-pixels';\nimport {\n\tAccessor,\n\tDocument,\n\tNode,\n\tPrimitive,\n\tProperty,\n\tPropertyType,\n\tScene,\n\tTexture,\n\tTransform,\n\tTransformContext,\n} from '@gltf-transform/core';\n\n/**\n * Prepares a function used in an {@link Document.transform} pipeline. Use of this wrapper is\n * optional, and plain functions may be used in transform pipelines just as well. The wrapper is\n * used internally so earlier pipeline stages can detect and optimize based on later stages.\n * @hidden\n */\nexport function createTransform(name: string, fn: Transform): Transform {\n\tObject.defineProperty(fn, 'name', { value: name });\n\treturn fn;\n}\n\n/** @hidden */\nexport function isTransformPending(context: TransformContext | undefined, initial: string, pending: string): boolean {\n\tif (!context) return false;\n\tconst initialIndex = context.stack.lastIndexOf(initial);\n\tconst pendingIndex = context.stack.lastIndexOf(pending);\n\treturn initialIndex < pendingIndex;\n}\n\n/**\n * Maps pixels from source to target textures, with a per-pixel callback.\n * @hidden\n */\nexport async function rewriteTexture(\n\tsource: Texture,\n\ttarget: Texture,\n\tfn: (pixels: NdArray, i: number, j: number) => void\n): Promise<Texture | null> {\n\tif (!source) return null;\n\n\tconst srcImage = source.getImage();\n\tif (!srcImage) return null;\n\n\tconst pixels = await getPixels(srcImage, source.getMimeType());\n\n\tfor (let i = 0; i < pixels.shape[0]; ++i) {\n\t\tfor (let j = 0; j < pixels.shape[1]; ++j) {\n\t\t\tfn(pixels, i, j);\n\t\t}\n\t}\n\n\tconst dstImage = await savePixels(pixels, 'image/png');\n\treturn target.setImage(dstImage).setMimeType('image/png');\n}\n\n/** @hidden */\nexport function getGLPrimitiveCount(prim: Primitive): number {\n\tconst indices = prim.getIndices();\n\tconst position = prim.getAttribute('POSITION')!;\n\n\t// Reference: https://www.khronos.org/opengl/wiki/Primitive\n\tswitch (prim.getMode()) {\n\t\tcase Primitive.Mode.POINTS:\n\t\t\treturn position.getCount();\n\t\tcase Primitive.Mode.LINES:\n\t\t\treturn indices ? indices.getCount() / 2 : position.getCount() / 2;\n\t\tcase Primitive.Mode.LINE_LOOP:\n\t\t\treturn position.getCount();\n\t\tcase Primitive.Mode.LINE_STRIP:\n\t\t\treturn position.getCount() - 1;\n\t\tcase Primitive.Mode.TRIANGLES:\n\t\t\treturn indices ? indices.getCount() / 3 : position.getCount() / 3;\n\t\tcase Primitive.Mode.TRIANGLE_STRIP:\n\t\tcase Primitive.Mode.TRIANGLE_FAN:\n\t\t\treturn position.getCount() - 2;\n\t\tdefault:\n\t\t\tthrow new Error('Unexpected mode: ' + prim.getMode());\n\t}\n}\n\n/** @hidden */\nexport class SetMap<K, V> {\n\tprivate _map = new Map<K, Set<V>>();\n\tpublic get size(): number {\n\t\treturn this._map.size;\n\t}\n\tpublic has(k: K): boolean {\n\t\treturn this._map.has(k);\n\t}\n\tpublic add(k: K, v: V): this {\n\t\tlet entry = this._map.get(k);\n\t\tif (!entry) {\n\t\t\tentry = new Set();\n\t\t\tthis._map.set(k, entry);\n\t\t}\n\t\tentry.add(v);\n\t\treturn this;\n\t}\n\tpublic get(k: K): Set<V> {\n\t\treturn this._map.get(k) || new Set();\n\t}\n\tpublic keys(): Iterable<K> {\n\t\treturn this._map.keys();\n\t}\n}\n\n/** @hidden */\nexport function formatBytes(bytes: number, decimals = 2): string {\n\tif (bytes === 0) return '0 Bytes';\n\n\tconst k = 1000;\n\tconst dm = decimals < 0 ? 0 : decimals;\n\tconst sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n\n\tconst i = Math.floor(Math.log(bytes) / Math.log(k));\n\n\treturn parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];\n}\n\n/** @hidden */\nexport function formatLong(x: number): string {\n\treturn x.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');\n}\n\n/** @hidden */\nexport function formatDelta(a: number, b: number, decimals = 2): string {\n\tconst prefix = a > b ? '–' : '+';\n\tconst suffix = '%';\n\treturn prefix + ((Math.abs(a - b) / a) * 100).toFixed(decimals) + suffix;\n}\n\n/** @hidden */\nexport function formatDeltaOp(a: number, b: number) {\n\treturn `${formatLong(a)} → ${formatLong(b)} (${formatDelta(a, b)})`;\n}\n\n/**\n * Returns a list of all unique vertex attributes on the given primitive and\n * its morph targets.\n * @hidden\n */\nexport function deepListAttributes(prim: Primitive): Accessor[] {\n\tconst accessors: Accessor[] = [];\n\n\tfor (const attribute of prim.listAttributes()) {\n\t\taccessors.push(attribute);\n\t}\n\tfor (const target of prim.listTargets()) {\n\t\tfor (const attribute of target.listAttributes()) {\n\t\t\taccessors.push(attribute);\n\t\t}\n\t}\n\n\treturn Array.from(new Set(accessors));\n}\n\n/** @hidden */\nexport function deepSwapAttribute(prim: Primitive, src: Accessor, dst: Accessor): void {\n\tprim.swap(src, dst);\n\tfor (const target of prim.listTargets()) {\n\t\ttarget.swap(src, dst);\n\t}\n}\n\n/** @hidden */\nexport function remapAttribute(attribute: Accessor, remap: Uint32Array, dstCount: number) {\n\tconst elementSize = attribute.getElementSize();\n\tconst srcCount = attribute.getCount();\n\tconst srcArray = attribute.getArray()!;\n\tconst dstArray = srcArray.slice(0, dstCount * elementSize);\n\n\tfor (let i = 0; i < srcCount; i++) {\n\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\tdstArray[remap[i] * elementSize + j] = srcArray[i * elementSize + j];\n\t\t}\n\t}\n\n\tattribute.setArray(dstArray);\n}\n\n/** @hidden */\nexport function createIndices(count: number, maxIndex = count): Uint16Array | Uint32Array {\n\tconst array = maxIndex <= 65534 ? new Uint16Array(count) : new Uint32Array(count);\n\tfor (let i = 0; i < array.length; i++) array[i] = i;\n\treturn array;\n}\n\n/** @hidden */\nexport function traverseNodeParents(node: Node, fn: (parent: Scene | Node) => void): void {\n\tlet child = node;\n\tlet parent: Scene | Node | null;\n\twhile ((parent = child.getParent() as Scene | Node | null)) {\n\t\tfn(parent);\n\t\tif (parent instanceof Node) {\n\t\t\tchild = parent;\n\t\t}\n\t}\n}\n\n/** @hidden */\nexport function isUsed(prop: Property): boolean {\n\treturn prop.listParents().some((parent) => parent.propertyType !== PropertyType.ROOT);\n}\n\n/**\n * Creates a unique key associated with the structure and draw call characteristics of\n * a {@link Primitive}, independent of its vertex content. Helper method, used to\n * identify candidate Primitives for joining.\n * @hidden\n */\nexport function createPrimGroupKey(prim: Primitive): string {\n\tconst document = Document.fromGraph(prim.getGraph())!;\n\tconst material = prim.getMaterial();\n\tconst materialIndex = document.getRoot().listMaterials().indexOf(material!);\n\tconst mode = prim.getMode();\n\tconst indices = !!prim.getIndices();\n\n\tconst attributes = prim\n\t\t.listSemantics()\n\t\t.sort()\n\t\t.map((semantic) => {\n\t\t\tconst attribute = prim.getAttribute(semantic)!;\n\t\t\tconst elementSize = attribute.getElementSize();\n\t\t\tconst componentType = attribute.getComponentType();\n\t\t\treturn `${semantic}:${elementSize}:${componentType}`;\n\t\t})\n\t\t.join('+');\n\n\tconst targets = prim\n\t\t.listTargets()\n\t\t.map((target) => {\n\t\t\treturn target\n\t\t\t\t.listSemantics()\n\t\t\t\t.sort()\n\t\t\t\t.map((semantic) => {\n\t\t\t\t\tconst attribute = prim.getAttribute(semantic)!;\n\t\t\t\t\tconst elementSize = attribute.getElementSize();\n\t\t\t\t\tconst componentType = attribute.getComponentType();\n\t\t\t\t\treturn `${semantic}:${elementSize}:${componentType}`;\n\t\t\t\t})\n\t\t\t\t.join('+');\n\t\t})\n\t\t.join('~');\n\n\treturn `${materialIndex}|${mode}|${indices}|${attributes}|${targets}`;\n}\n","import type { Document, Transform, vec3 } from '@gltf-transform/core';\nimport { getBounds } from '@gltf-transform/core';\nimport { createTransform } from './utils';\n\nconst NAME = 'center';\n\n/** Options for the {@link center} function. */\nexport interface CenterOptions {\n\t/** Location on the model to be considered the pivot, and recentered at the origin. */\n\tpivot?: 'center' | 'above' | 'below' | vec3;\n}\n\nconst CENTER_DEFAULTS: Required<CenterOptions> = { pivot: 'center' };\n\n/**\n * Centers the {@link Scene} at the origin, or above/below it. Transformations from animation,\n * skinning, and morph targets are not taken into account.\n *\n * Example:\n *\n * ```ts\n * await document.transform(center({pivot: 'below'}));\n * ```\n */\nexport function center(_options: CenterOptions = CENTER_DEFAULTS): Transform {\n\tconst options = { ...CENTER_DEFAULTS, ..._options } as Required<CenterOptions>;\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\t\tconst isAnimated = root.listAnimations().length > 0 || root.listSkins().length > 0;\n\n\t\tdoc.getRoot()\n\t\t\t.listScenes()\n\t\t\t.forEach((scene, index) => {\n\t\t\t\tlogger.debug(`${NAME}: Scene ${index + 1} / ${root.listScenes().length}.`);\n\n\t\t\t\tlet pivot: vec3;\n\t\t\t\tif (typeof options.pivot === 'string') {\n\t\t\t\t\tconst bbox = getBounds(scene);\n\t\t\t\t\tpivot = [\n\t\t\t\t\t\t(bbox.max[0] - bbox.min[0]) / 2 + bbox.min[0],\n\t\t\t\t\t\t(bbox.max[1] - bbox.min[1]) / 2 + bbox.min[1],\n\t\t\t\t\t\t(bbox.max[2] - bbox.min[2]) / 2 + bbox.min[2],\n\t\t\t\t\t];\n\t\t\t\t\tif (options.pivot === 'above') pivot[1] = bbox.max[1];\n\t\t\t\t\tif (options.pivot === 'below') pivot[1] = bbox.min[1];\n\t\t\t\t} else {\n\t\t\t\t\tpivot = options.pivot as vec3;\n\t\t\t\t}\n\n\t\t\t\tlogger.debug(`${NAME}: Pivot \"${pivot.join(', ')}\".`);\n\n\t\t\t\tconst offset: vec3 = [-1 * pivot[0], -1 * pivot[1], -1 * pivot[2]];\n\n\t\t\t\tif (isAnimated) {\n\t\t\t\t\tlogger.debug(`${NAME}: Model contains animation or skin. Adding a wrapper node.`);\n\t\t\t\t\tconst offsetNode = doc.createNode('Pivot').setTranslation(offset);\n\t\t\t\t\tscene.listChildren().forEach((child) => offsetNode.addChild(child));\n\t\t\t\t\tscene.addChild(offsetNode);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.debug(`${NAME}: Skipping wrapper, offsetting all root nodes.`);\n\t\t\t\t\tscene.listChildren().forEach((child) => {\n\t\t\t\t\t\tconst t = child.getTranslation();\n\t\t\t\t\t\tchild.setTranslation([t[0] + offset[0], t[1] + offset[1], t[2] + offset[2]]);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n","import { Node, Scene } from '@gltf-transform/core';\n\n/**\n * Finds the parent {@link Scene} associated with the given {@link Node}.\n *\n * Example:\n *\n * ```typescript\n * import { getNodeScene } from '@gltf-transform/functions';\n *\n * const node = document.getRoot().listNodes()\n *  .find((node) => node.getName() === 'MyNode');\n *\n * const scene = getNodeScene(node);\n * ```\n */\nexport function getNodeScene(node: Node): Scene | null {\n\tconst visited = new Set<Node>();\n\n\tlet child = node;\n\tlet parent: Node | Scene | null;\n\n\twhile ((parent = child.getParent() as Node | Scene | null)) {\n\t\tif (parent instanceof Scene) {\n\t\t\treturn parent;\n\t\t}\n\t\tif (visited.has(parent)) {\n\t\t\tthrow new Error('Circular dependency in scene graph.');\n\t\t}\n\t\tvisited.add(parent);\n\t\tchild = parent;\n\t}\n\n\treturn null;\n}\n","import { Node, Scene } from '@gltf-transform/core';\nimport { getNodeScene } from './get-node-scene';\n\n/**\n * Clears the parent of the given {@link Node}, leaving it attached\n * directly to its {@link Scene}. Inherited transforms will be applied\n * to the Node. This operation changes the Node's local transform,\n * but leaves its world transform unchanged.\n *\n * Example:\n *\n * ```typescript\n * import { clearNodeParent } from '@gltf-transform/functions';\n *\n * scene.traverse((node) => { ... }); // Scene → … → Node\n *\n * clearNodeParent(node);\n *\n * scene.traverse((node) => { ... }); // Scene → Node\n * ```\n *\n * To clear _all_ transforms of a Node, first clear its inherited transforms with\n * {@link clearNodeParent}, then clear the local transform with {@link clearNodeTransform}.\n */\nexport function clearNodeParent(node: Node): Node {\n\tconst scene = getNodeScene(node);\n\tconst parent = node.getParent() as Scene | Node | null;\n\n\tif (!scene || !parent) {\n\t\tthrow new Error('Node must be a descendant of a Scene.');\n\t}\n\n\tif (parent instanceof Scene) {\n\t\treturn node;\n\t}\n\n\t// Apply inherited transforms to local matrix. Skinned meshes are not affected\n\t// by the node parent's trasnform, and can be ignored. Updates to IBMs and TRS\n\t// animations are out of scope in this context.\n\tnode.setMatrix(node.getWorldMatrix());\n\n\t// Set scene as parent.\n\tparent.removeChild(node);\n\tscene.addChild(node);\n\n\treturn node;\n}\n","/**\n * Common utilities\n * @module glMatrix\n */\n// Configuration Constants\nexport var EPSILON = 0.000001;\nexport var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nexport var RANDOM = Math.random;\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\n */\n\nexport function setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\n\nexport function toRadian(a) {\n  return a * degree;\n}\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};","import * as glMatrix from \"./common.js\";\n/**\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\n * @module mat4\n */\n\n/**\n * Creates a new identity mat4\n *\n * @returns {mat4} a new 4x4 matrix\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(16);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n  }\n\n  out[0] = 1;\n  out[5] = 1;\n  out[10] = 1;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat4} a matrix to clone\n * @returns {mat4} a new 4x4 matrix\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Create a new mat4 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} A new mat4\n */\n\nexport function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} out\n */\n\nexport function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    var a12 = a[6],\n        a13 = a[7];\n    var a23 = a[11];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a01;\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a02;\n    out[9] = a12;\n    out[11] = a[14];\n    out[12] = a03;\n    out[13] = a13;\n    out[14] = a23;\n  } else {\n    out[0] = a[0];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a[1];\n    out[5] = a[5];\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a[2];\n    out[9] = a[6];\n    out[10] = a[10];\n    out[11] = a[14];\n    out[12] = a[3];\n    out[13] = a[7];\n    out[14] = a[11];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);\n  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);\n  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);\n  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);\n  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);\n  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);\n  return out;\n}\n/**\n * Calculates the determinant of a mat4\n *\n * @param {ReadonlyMat4} a the source matrix\n * @returns {Number} determinant of a\n */\n\nexport function determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15]; // Cache only the current line of the second matrix\n\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to translate\n * @param {ReadonlyVec3} v vector to translate by\n * @returns {mat4} out\n */\n\nexport function translate(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n\n  return out;\n}\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {ReadonlyVec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\n\nexport function scale(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nexport function rotate(out, a, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n  var b00, b01, b02;\n  var b10, b11, b12;\n  var b20, b21, b22;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n  a00 = a[0];\n  a01 = a[1];\n  a02 = a[2];\n  a03 = a[3];\n  a10 = a[4];\n  a11 = a[5];\n  a12 = a[6];\n  a13 = a[7];\n  a20 = a[8];\n  a21 = a[9];\n  a22 = a[10];\n  a23 = a[11]; // Construct the elements of the rotation matrix\n\n  b00 = x * x * t + c;\n  b01 = y * x * t + z * s;\n  b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s;\n  b11 = y * y * t + c;\n  b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s;\n  b21 = y * z * t - x * s;\n  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication\n\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the X axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateX(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[4] = a10 * c + a20 * s;\n  out[5] = a11 * c + a21 * s;\n  out[6] = a12 * c + a22 * s;\n  out[7] = a13 * c + a23 * s;\n  out[8] = a20 * c - a10 * s;\n  out[9] = a21 * c - a11 * s;\n  out[10] = a22 * c - a12 * s;\n  out[11] = a23 * c - a13 * s;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Y axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateY(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c - a20 * s;\n  out[1] = a01 * c - a21 * s;\n  out[2] = a02 * c - a22 * s;\n  out[3] = a03 * c - a23 * s;\n  out[8] = a00 * s + a20 * c;\n  out[9] = a01 * s + a21 * c;\n  out[10] = a02 * s + a22 * c;\n  out[11] = a03 * s + a23 * c;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Z axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateZ(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c + a10 * s;\n  out[1] = a01 * c + a11 * s;\n  out[2] = a02 * c + a12 * s;\n  out[3] = a03 * c + a13 * s;\n  out[4] = a10 * c - a00 * s;\n  out[5] = a11 * c - a01 * s;\n  out[6] = a12 * c - a02 * s;\n  out[7] = a13 * c - a03 * s;\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.scale(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Scaling vector\n * @returns {mat4} out\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = v[1];\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = v[2];\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle around a given axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotate(dest, dest, rad, axis);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nexport function fromRotation(out, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c; // Perform rotation-specific matrix multiplication\n\n  out[0] = x * x * t + c;\n  out[1] = y * x * t + z * s;\n  out[2] = z * x * t - y * s;\n  out[3] = 0;\n  out[4] = x * y * t - z * s;\n  out[5] = y * y * t + c;\n  out[6] = z * y * t + x * s;\n  out[7] = 0;\n  out[8] = x * z * t + y * s;\n  out[9] = y * z * t - x * s;\n  out[10] = z * z * t + c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the X axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateX(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromXRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = c;\n  out[6] = s;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = -s;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Y axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateY(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromYRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = 0;\n  out[2] = -s;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = s;\n  out[9] = 0;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Z axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateZ(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromZRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -s;\n  out[5] = c;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation and vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslation(out, q, v) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - (yy + zz);\n  out[1] = xy + wz;\n  out[2] = xz - wy;\n  out[3] = 0;\n  out[4] = xy - wz;\n  out[5] = 1 - (xx + zz);\n  out[6] = yz + wx;\n  out[7] = 0;\n  out[8] = xz + wy;\n  out[9] = yz - wx;\n  out[10] = 1 - (xx + yy);\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 from a dual quat.\n *\n * @param {mat4} out Matrix\n * @param {ReadonlyQuat2} a Dual Quaternion\n * @returns {mat4} mat4 receiving operation result\n */\n\nexport function fromQuat2(out, a) {\n  var translation = new glMatrix.ARRAY_TYPE(3);\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7];\n  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense\n\n  if (magnitude > 0) {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\n  } else {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  }\n\n  fromRotationTranslation(out, a, translation);\n  return out;\n}\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nexport function getTranslation(out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n  return out;\n}\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nexport function getScaling(out, mat) {\n  var m11 = mat[0];\n  var m12 = mat[1];\n  var m13 = mat[2];\n  var m21 = mat[4];\n  var m22 = mat[5];\n  var m23 = mat[6];\n  var m31 = mat[8];\n  var m32 = mat[9];\n  var m33 = mat[10];\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n  return out;\n}\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\n\nexport function getRotation(out, mat) {\n  var scaling = new glMatrix.ARRAY_TYPE(3);\n  getScaling(scaling, mat);\n  var is1 = 1 / scaling[0];\n  var is2 = 1 / scaling[1];\n  var is3 = 1 / scaling[2];\n  var sm11 = mat[0] * is1;\n  var sm12 = mat[1] * is2;\n  var sm13 = mat[2] * is3;\n  var sm21 = mat[4] * is1;\n  var sm22 = mat[5] * is2;\n  var sm23 = mat[6] * is3;\n  var sm31 = mat[8] * is1;\n  var sm32 = mat[9] * is2;\n  var sm33 = mat[10] * is3;\n  var trace = sm11 + sm22 + sm33;\n  var S = 0;\n\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (sm23 - sm32) / S;\n    out[1] = (sm31 - sm13) / S;\n    out[2] = (sm12 - sm21) / S;\n  } else if (sm11 > sm22 && sm11 > sm33) {\n    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n    out[3] = (sm23 - sm32) / S;\n    out[0] = 0.25 * S;\n    out[1] = (sm12 + sm21) / S;\n    out[2] = (sm31 + sm13) / S;\n  } else if (sm22 > sm33) {\n    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n    out[3] = (sm31 - sm13) / S;\n    out[0] = (sm12 + sm21) / S;\n    out[1] = 0.25 * S;\n    out[2] = (sm23 + sm32) / S;\n  } else {\n    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n    out[3] = (sm12 - sm21) / S;\n    out[0] = (sm31 + sm13) / S;\n    out[1] = (sm23 + sm32) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     mat4.translate(dest, origin);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *     mat4.translate(dest, negativeOrigin);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @param {ReadonlyVec3} o The origin vector around which to scale and rotate\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslationScaleOrigin(out, q, v, s, o) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  var ox = o[0];\n  var oy = o[1];\n  var oz = o[2];\n  var out0 = (1 - (yy + zz)) * sx;\n  var out1 = (xy + wz) * sx;\n  var out2 = (xz - wy) * sx;\n  var out4 = (xy - wz) * sy;\n  var out5 = (1 - (xx + zz)) * sy;\n  var out6 = (yz + wx) * sy;\n  var out8 = (xz + wy) * sz;\n  var out9 = (yz - wx) * sz;\n  var out10 = (1 - (xx + yy)) * sz;\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = 0;\n  out[4] = out4;\n  out[5] = out5;\n  out[6] = out6;\n  out[7] = 0;\n  out[8] = out8;\n  out[9] = out9;\n  out[10] = out10;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\n  out[15] = 1;\n  return out;\n}\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\n\nexport function fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a frustum matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Number} left Left bound of the frustum\n * @param {Number} right Right bound of the frustum\n * @param {Number} bottom Bottom bound of the frustum\n * @param {Number} top Top bound of the frustum\n * @param {Number} near Near bound of the frustum\n * @param {Number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function frustum(out, left, right, bottom, top, near, far) {\n  var rl = 1 / (right - left);\n  var tb = 1 / (top - bottom);\n  var nf = 1 / (near - far);\n  out[0] = near * 2 * rl;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = near * 2 * tb;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = (right + left) * rl;\n  out[9] = (top + bottom) * tb;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = far * near * 2 * nf;\n  out[15] = 0;\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nexport function perspectiveNO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = (far + near) * nf;\n    out[14] = 2 * far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -2 * near;\n  }\n\n  return out;\n}\n/**\n * Alias for {@link mat4.perspectiveNO}\n * @function\n */\n\nexport var perspective = perspectiveNO;\n/**\n * Generates a perspective projection matrix suitable for WebGPU with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nexport function perspectiveZO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = far * nf;\n    out[14] = far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -near;\n  }\n\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given field of view.\n * This is primarily useful for generating projection matrices to be used\n * with the still experiemental WebVR API.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function perspectiveFromFieldOfView(out, fov, near, far) {\n  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\n  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\n  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\n  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\n  var xScale = 2.0 / (leftTan + rightTan);\n  var yScale = 2.0 / (upTan + downTan);\n  out[0] = xScale;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  out[4] = 0.0;\n  out[5] = yScale;\n  out[6] = 0.0;\n  out[7] = 0.0;\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\n  out[9] = (upTan - downTan) * yScale * 0.5;\n  out[10] = far / (near - far);\n  out[11] = -1.0;\n  out[12] = 0.0;\n  out[13] = 0.0;\n  out[14] = far * near / (near - far);\n  out[15] = 0.0;\n  return out;\n}\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function orthoNO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Alias for {@link mat4.orthoNO}\n * @function\n */\n\nexport var ortho = orthoNO;\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function orthoZO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = near * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nexport function lookAt(out, eye, center, up) {\n  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n  var eyex = eye[0];\n  var eyey = eye[1];\n  var eyez = eye[2];\n  var upx = up[0];\n  var upy = up[1];\n  var upz = up[2];\n  var centerx = center[0];\n  var centery = center[1];\n  var centerz = center[2];\n\n  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {\n    return identity(out);\n  }\n\n  z0 = eyex - centerx;\n  z1 = eyey - centery;\n  z2 = eyez - centerz;\n  len = 1 / Math.hypot(z0, z1, z2);\n  z0 *= len;\n  z1 *= len;\n  z2 *= len;\n  x0 = upy * z2 - upz * z1;\n  x1 = upz * z0 - upx * z2;\n  x2 = upx * z1 - upy * z0;\n  len = Math.hypot(x0, x1, x2);\n\n  if (!len) {\n    x0 = 0;\n    x1 = 0;\n    x2 = 0;\n  } else {\n    len = 1 / len;\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  y0 = z1 * x2 - z2 * x1;\n  y1 = z2 * x0 - z0 * x2;\n  y2 = z0 * x1 - z1 * x0;\n  len = Math.hypot(y0, y1, y2);\n\n  if (!len) {\n    y0 = 0;\n    y1 = 0;\n    y2 = 0;\n  } else {\n    len = 1 / len;\n    y0 *= len;\n    y1 *= len;\n    y2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = y0;\n  out[2] = z0;\n  out[3] = 0;\n  out[4] = x1;\n  out[5] = y1;\n  out[6] = z1;\n  out[7] = 0;\n  out[8] = x2;\n  out[9] = y2;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nexport function targetTo(out, eye, target, up) {\n  var eyex = eye[0],\n      eyey = eye[1],\n      eyez = eye[2],\n      upx = up[0],\n      upy = up[1],\n      upz = up[2];\n  var z0 = eyex - target[0],\n      z1 = eyey - target[1],\n      z2 = eyez - target[2];\n  var len = z0 * z0 + z1 * z1 + z2 * z2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n  }\n\n  var x0 = upy * z2 - upz * z1,\n      x1 = upz * z0 - upx * z2,\n      x2 = upx * z1 - upy * z0;\n  len = x0 * x0 + x1 * x1 + x2 * x2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = x1;\n  out[2] = x2;\n  out[3] = 0;\n  out[4] = z1 * x2 - z2 * x1;\n  out[5] = z2 * x0 - z0 * x2;\n  out[6] = z0 * x1 - z1 * x0;\n  out[7] = 0;\n  out[8] = z0;\n  out[9] = z1;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = eyex;\n  out[13] = eyey;\n  out[14] = eyez;\n  out[15] = 1;\n  return out;\n}\n/**\n * Returns a string representation of a mat4\n *\n * @param {ReadonlyMat4} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nexport function str(a) {\n  return \"mat4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \", \" + a[9] + \", \" + a[10] + \", \" + a[11] + \", \" + a[12] + \", \" + a[13] + \", \" + a[14] + \", \" + a[15] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat4\n *\n * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n}\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  out[9] = a[9] + b[9];\n  out[10] = a[10] + b[10];\n  out[11] = a[11] + b[11];\n  out[12] = a[12] + b[12];\n  out[13] = a[13] + b[13];\n  out[14] = a[14] + b[14];\n  out[15] = a[15] + b[15];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  out[9] = a[9] - b[9];\n  out[10] = a[10] - b[10];\n  out[11] = a[11] - b[11];\n  out[12] = a[12] - b[12];\n  out[13] = a[13] - b[13];\n  out[14] = a[14] - b[14];\n  out[15] = a[15] - b[15];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  out[9] = a[9] * b;\n  out[10] = a[10] * b;\n  out[11] = a[11] * b;\n  out[12] = a[12] * b;\n  out[13] = a[13] * b;\n  out[14] = a[14] * b;\n  out[15] = a[15] * b;\n  return out;\n}\n/**\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat4} out the receiving vector\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat4} out\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  out[9] = a[9] + b[9] * scale;\n  out[10] = a[10] + b[10] * scale;\n  out[11] = a[11] + b[11] * scale;\n  out[12] = a[12] + b[12] * scale;\n  out[13] = a[13] + b[13] * scale;\n  out[14] = a[14] + b[14] * scale;\n  out[15] = a[15] + b[15] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7];\n  var a8 = a[8],\n      a9 = a[9],\n      a10 = a[10],\n      a11 = a[11];\n  var a12 = a[12],\n      a13 = a[13],\n      a14 = a[14],\n      a15 = a[15];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  var b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7];\n  var b8 = b[8],\n      b9 = b[9],\n      b10 = b[10],\n      b11 = b[11];\n  var b12 = b[12],\n      b13 = b[13],\n      b14 = b[14],\n      b15 = b[15];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\n}\n/**\n * Alias for {@link mat4.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link mat4.subtract}\n * @function\n */\n\nexport var sub = subtract;","import * as glMatrix from \"./common.js\";\n/**\n * 3x3 Matrix\n * @module mat3\n */\n\n/**\n * Creates a new identity mat3\n *\n * @returns {mat3} a new 3x3 matrix\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(9);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n  }\n\n  out[0] = 1;\n  out[4] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {ReadonlyMat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */\n\nexport function fromMat4(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[4];\n  out[4] = a[5];\n  out[5] = a[6];\n  out[6] = a[8];\n  out[7] = a[9];\n  out[8] = a[10];\n  return out;\n}\n/**\n * Creates a new mat3 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat3} a matrix to clone\n * @returns {mat3} a new 3x3 matrix\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Copy the values from one mat3 to another\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Create a new mat3 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} A new mat3\n */\n\nexport function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\n * Set the components of a mat3 to the given values\n *\n * @param {mat3} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} out\n */\n\nexport function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a12 = a[5];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a01;\n    out[5] = a[7];\n    out[6] = a02;\n    out[7] = a12;\n  } else {\n    out[0] = a[0];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a[1];\n    out[4] = a[4];\n    out[5] = a[7];\n    out[6] = a[2];\n    out[7] = a[5];\n    out[8] = a[8];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b01 = a22 * a11 - a12 * a21;\n  var b11 = -a22 * a10 + a12 * a20;\n  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant\n\n  var det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = b01 * det;\n  out[1] = (-a22 * a01 + a02 * a21) * det;\n  out[2] = (a12 * a01 - a02 * a11) * det;\n  out[3] = b11 * det;\n  out[4] = (a22 * a00 - a02 * a20) * det;\n  out[5] = (-a12 * a00 + a02 * a10) * det;\n  out[6] = b21 * det;\n  out[7] = (-a21 * a00 + a01 * a20) * det;\n  out[8] = (a11 * a00 - a01 * a10) * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  out[0] = a11 * a22 - a12 * a21;\n  out[1] = a02 * a21 - a01 * a22;\n  out[2] = a01 * a12 - a02 * a11;\n  out[3] = a12 * a20 - a10 * a22;\n  out[4] = a00 * a22 - a02 * a20;\n  out[5] = a02 * a10 - a00 * a12;\n  out[6] = a10 * a21 - a11 * a20;\n  out[7] = a01 * a20 - a00 * a21;\n  out[8] = a00 * a11 - a01 * a10;\n  return out;\n}\n/**\n * Calculates the determinant of a mat3\n *\n * @param {ReadonlyMat3} a the source matrix\n * @returns {Number} determinant of a\n */\n\nexport function determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n}\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nexport function multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b00 = b[0],\n      b01 = b[1],\n      b02 = b[2];\n  var b10 = b[3],\n      b11 = b[4],\n      b12 = b[5];\n  var b20 = b[6],\n      b21 = b[7],\n      b22 = b[8];\n  out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n  out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n  out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return out;\n}\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to translate\n * @param {ReadonlyVec2} v vector to translate by\n * @returns {mat3} out\n */\n\nexport function translate(out, a, v) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      x = v[0],\n      y = v[1];\n  out[0] = a00;\n  out[1] = a01;\n  out[2] = a02;\n  out[3] = a10;\n  out[4] = a11;\n  out[5] = a12;\n  out[6] = x * a00 + y * a10 + a20;\n  out[7] = x * a01 + y * a11 + a21;\n  out[8] = x * a02 + y * a12 + a22;\n  return out;\n}\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\n\nexport function rotate(out, a, rad) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c * a00 + s * a10;\n  out[1] = c * a01 + s * a11;\n  out[2] = c * a02 + s * a12;\n  out[3] = c * a10 - s * a00;\n  out[4] = c * a11 - s * a01;\n  out[5] = c * a12 - s * a02;\n  out[6] = a20;\n  out[7] = a21;\n  out[8] = a22;\n  return out;\n}\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/\n\nexport function scale(out, a, v) {\n  var x = v[0],\n      y = v[1];\n  out[0] = x * a[0];\n  out[1] = x * a[1];\n  out[2] = x * a[2];\n  out[3] = y * a[3];\n  out[4] = y * a[4];\n  out[5] = y * a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.translate(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyVec2} v Translation vector\n * @returns {mat3} out\n */\n\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = v[0];\n  out[7] = v[1];\n  out[8] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.rotate(dest, dest, rad);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\n\nexport function fromRotation(out, rad) {\n  var s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = -s;\n  out[4] = c;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.scale(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyVec2} v Scaling vector\n * @returns {mat3} out\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = v[1];\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Copies the values from a mat2d into a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to copy\n * @returns {mat3} out\n **/\n\nexport function fromMat2d(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = 0;\n  out[3] = a[2];\n  out[4] = a[3];\n  out[5] = 0;\n  out[6] = a[4];\n  out[7] = a[5];\n  out[8] = 1;\n  return out;\n}\n/**\n * Calculates a 3x3 matrix from the given quaternion\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat3} out\n */\n\nexport function fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[3] = yx - wz;\n  out[6] = zx + wy;\n  out[1] = yx + wz;\n  out[4] = 1 - xx - zz;\n  out[7] = zy - wx;\n  out[2] = zx - wy;\n  out[5] = zy + wx;\n  out[8] = 1 - xx - yy;\n  return out;\n}\n/**\n * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from\n *\n * @returns {mat3} out\n */\n\nexport function normalFromMat4(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  return out;\n}\n/**\n * Generates a 2D projection matrix with the given bounds\n *\n * @param {mat3} out mat3 frustum matrix will be written into\n * @param {number} width Width of your gl context\n * @param {number} height Height of gl context\n * @returns {mat3} out\n */\n\nexport function projection(out, width, height) {\n  out[0] = 2 / width;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -2 / height;\n  out[5] = 0;\n  out[6] = -1;\n  out[7] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\n * Returns a string representation of a mat3\n *\n * @param {ReadonlyMat3} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nexport function str(a) {\n  return \"mat3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat3\n *\n * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);\n}\n/**\n * Adds two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat3} out\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  return out;\n}\n/**\n * Adds two mat3's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat3} out the receiving vector\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat3} out\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat3} a The first matrix.\n * @param {ReadonlyMat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat3} a The first matrix.\n * @param {ReadonlyMat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7],\n      a8 = a[8];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7],\n      b8 = b[8];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));\n}\n/**\n * Alias for {@link mat3.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link mat3.subtract}\n * @function\n */\n\nexport var sub = subtract;","import * as glMatrix from \"./common.js\";\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(3);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {ReadonlyVec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Calculates the length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\n\nexport function fromValues(x, y, z) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the source vector\n * @returns {vec3} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\n\nexport function set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to ceil\n * @returns {vec3} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to floor\n * @returns {vec3} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to round\n * @returns {vec3} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Calculates the squared length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to negate\n * @returns {vec3} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to invert\n * @returns {vec3} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to normalize\n * @returns {vec3} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec3} out\n */\n\nexport function transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateX(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateY(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateZ(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Get the angle between two 3D vectors\n * @param {ReadonlyVec3} a The first operand\n * @param {ReadonlyVec3} b The second operand\n * @returns {Number} The angle in radians\n */\n\nexport function angle(a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n      mag = mag1 * mag2,\n      cosine = mag && dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec3 to zero\n *\n * @param {vec3} out the receiving vector\n * @returns {vec3} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec3.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();","import * as glMatrix from \"./common.js\";\n/**\n * 4 Dimensional Vector\n * @module vec4\n */\n\n/**\n * Creates a new, empty vec4\n *\n * @returns {vec4} a new 4D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec4 initialized with values from an existing vector\n *\n * @param {ReadonlyVec4} a vector to clone\n * @returns {vec4} a new 4D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Creates a new vec4 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} a new 4D vector\n */\n\nexport function fromValues(x, y, z, w) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the source vector\n * @returns {vec4} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */\n\nexport function set(out, x, y, z, w) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n/**\n * Multiplies two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  out[3] = a[3] * b[3];\n  return out;\n}\n/**\n * Divides two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  out[3] = a[3] / b[3];\n  return out;\n}\n/**\n * Math.ceil the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to ceil\n * @returns {vec4} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  out[3] = Math.ceil(a[3]);\n  return out;\n}\n/**\n * Math.floor the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to floor\n * @returns {vec4} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  out[3] = Math.floor(a[3]);\n  return out;\n}\n/**\n * Returns the minimum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  out[3] = Math.min(a[3], b[3]);\n  return out;\n}\n/**\n * Returns the maximum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  out[3] = Math.max(a[3], b[3]);\n  return out;\n}\n/**\n * Math.round the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to round\n * @returns {vec4} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  out[3] = Math.round(a[3]);\n  return out;\n}\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\n * Adds two vec4's after scaling the second operand by a scalar value\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec4} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\n * Calculates the squared euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\n * Calculates the length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\n * Calculates the squared length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\n * Negates the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to negate\n * @returns {vec4} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = -a[3];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to invert\n * @returns {vec4} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  out[3] = 1.0 / a[3];\n  return out;\n}\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to normalize\n * @returns {vec4} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  var len = x * x + y * y + z * z + w * w;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = x * len;\n  out[1] = y * len;\n  out[2] = z * len;\n  out[3] = w * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n/**\n * Returns the cross-product of three vectors in a 4-dimensional space\n *\n * @param {ReadonlyVec4} result the receiving vector\n * @param {ReadonlyVec4} U the first vector\n * @param {ReadonlyVec4} V the second vector\n * @param {ReadonlyVec4} W the third vector\n * @returns {vec4} result\n */\n\nexport function cross(out, u, v, w) {\n  var A = v[0] * w[1] - v[1] * w[0],\n      B = v[0] * w[2] - v[2] * w[0],\n      C = v[0] * w[3] - v[3] * w[0],\n      D = v[1] * w[2] - v[2] * w[1],\n      E = v[1] * w[3] - v[3] * w[1],\n      F = v[2] * w[3] - v[3] * w[2];\n  var G = u[0];\n  var H = u[1];\n  var I = u[2];\n  var J = u[3];\n  out[0] = H * F - I * E + J * D;\n  out[1] = -(G * F) + I * C - J * B;\n  out[2] = G * E - H * C + J * A;\n  out[3] = -(G * D) + H * B - I * A;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec4} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  var aw = a[3];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  out[3] = aw + t * (b[3] - aw);\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec4} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec4} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a\n  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.\n  // http://projecteuclid.org/euclid.aoms/1177692644;\n\n  var v1, v2, v3, v4;\n  var s1, s2;\n\n  do {\n    v1 = glMatrix.RANDOM() * 2 - 1;\n    v2 = glMatrix.RANDOM() * 2 - 1;\n    s1 = v1 * v1 + v2 * v2;\n  } while (s1 >= 1);\n\n  do {\n    v3 = glMatrix.RANDOM() * 2 - 1;\n    v4 = glMatrix.RANDOM() * 2 - 1;\n    s2 = v3 * v3 + v4 * v4;\n  } while (s2 >= 1);\n\n  var d = Math.sqrt((1 - s1) / s2);\n  out[0] = scale * v1;\n  out[1] = scale * v2;\n  out[2] = scale * v3 * d;\n  out[3] = scale * v4 * d;\n  return out;\n}\n/**\n * Transforms the vec4 with a mat4.\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec4} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n  return out;\n}\n/**\n * Transforms the vec4 with a quat\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec4} out\n */\n\nexport function transformQuat(out, a, q) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3]; // calculate quat * vec\n\n  var ix = qw * x + qy * z - qz * y;\n  var iy = qw * y + qz * x - qx * z;\n  var iz = qw * z + qx * y - qy * x;\n  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set the components of a vec4 to zero\n *\n * @param {vec4} out the receiving vector\n * @returns {vec4} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec4} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n/**\n * Alias for {@link vec4.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec4.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec4.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec4.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec4.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec4.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec4.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec4s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 4;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      vec[3] = a[i + 3];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n      a[i + 3] = vec[3];\n    }\n\n    return a;\n  };\n}();","import type { vec3, vec4, mat4, Accessor, Primitive } from '@gltf-transform/core';\nimport { create as createMat3, fromMat4, invert, transpose } from 'gl-matrix/mat3';\nimport { create as createVec3, normalize as normalizeVec3, transformMat3, transformMat4 } from 'gl-matrix/vec3';\nimport { create as createVec4 } from 'gl-matrix/vec4';\nimport { createIndices } from './utils';\n\n/**\n * Applies a transform matrix to a {@link Primitive}.\n *\n * When calling {@link transformPrimitive}, any un-masked vertices are overwritten\n * directly in the underlying vertex streams. If streams should be detached instead,\n * see {@link transformMesh}.\n *\n * Example:\n *\n * ```javascript\n * import { fromTranslation } from 'gl-matrix/mat4';\n * import { transformPrimitive } from '@gltf-transform/functions';\n *\n * // offset vertices, y += 10.\n * transformPrimitive(prim, fromTranslation([], [0, 10, 0]));\n * ```\n *\n * @param prim\n * @param matrix\n * @param skipIndices Vertices, specified by index, to be _excluded_ from the transformation.\n */\nexport function transformPrimitive(prim: Primitive, matrix: mat4, skipIndices = new Set<number>()): void {\n\tconst position = prim.getAttribute('POSITION')!;\n\tconst indices = (prim.getIndices()?.getArray() || createIndices(position!.getCount())) as Uint32Array;\n\n\t// Apply transform to base attributes.\n\tif (position) {\n\t\tapplyMatrix(matrix, position, indices, new Set(skipIndices));\n\t}\n\n\tconst normal = prim.getAttribute('NORMAL');\n\tif (normal) {\n\t\tapplyNormalMatrix(matrix, normal, indices, new Set(skipIndices));\n\t}\n\n\tconst tangent = prim.getAttribute('TANGENT');\n\tif (tangent) {\n\t\tapplyTangentMatrix(matrix, tangent, indices, new Set(skipIndices));\n\t}\n\n\t// Apply transform to morph attributes.\n\tfor (const target of prim.listTargets()) {\n\t\tconst position = target.getAttribute('POSITION');\n\t\tif (position) {\n\t\t\tapplyMatrix(matrix, position, indices, new Set(skipIndices));\n\t\t}\n\n\t\tconst normal = target.getAttribute('NORMAL');\n\t\tif (normal) {\n\t\t\tapplyNormalMatrix(matrix, normal, indices, new Set(skipIndices));\n\t\t}\n\n\t\tconst tangent = target.getAttribute('TANGENT');\n\t\tif (tangent) {\n\t\t\tapplyTangentMatrix(matrix, tangent, indices, new Set(skipIndices));\n\t\t}\n\t}\n\n\t// Update mask.\n\tfor (let i = 0; i < indices.length; i++) skipIndices.add(indices[i]);\n}\n\nfunction applyMatrix(matrix: mat4, attribute: Accessor, indices: Uint32Array, skipIndices: Set<number>) {\n\t// An arbitrary transform may not keep vertex positions in the required\n\t// range of a normalized attribute. Replace the array, instead.\n\tconst dstArray = new Float32Array(attribute.getCount() * 3);\n\tconst elementSize = attribute.getElementSize();\n\n\tfor (let i = 0, el: number[] = [], il = attribute.getCount(); i < il; i++) {\n\t\tdstArray.set(attribute.getElement(i, el), i * elementSize);\n\t}\n\n\tconst vector = createVec3() as vec3;\n\tfor (let i = 0; i < indices.length; i++) {\n\t\tconst index = indices[i];\n\t\tif (skipIndices.has(index)) continue;\n\n\t\tattribute.getElement(index, vector);\n\t\ttransformMat4(vector, vector, matrix);\n\t\tdstArray.set(vector, index * 3);\n\n\t\tskipIndices.add(index);\n\t}\n\n\tattribute.setArray(dstArray).setNormalized(false);\n}\n\nfunction applyNormalMatrix(matrix: mat4, attribute: Accessor, indices: Uint32Array, skipIndices: Set<number>) {\n\tconst normalMatrix = createMat3();\n\tfromMat4(normalMatrix, matrix);\n\tinvert(normalMatrix, normalMatrix);\n\ttranspose(normalMatrix, normalMatrix);\n\n\tconst vector = createVec3() as vec3;\n\tfor (let i = 0; i < indices.length; i++) {\n\t\tconst index = indices[i];\n\t\tif (skipIndices.has(index)) continue;\n\n\t\tattribute.getElement(index, vector);\n\t\ttransformMat3(vector, vector, normalMatrix);\n\t\tnormalizeVec3(vector, vector);\n\t\tattribute.setElement(index, vector);\n\n\t\tskipIndices.add(index);\n\t}\n}\n\nfunction applyTangentMatrix(matrix: mat4, attribute: Accessor, indices: Uint32Array, skipIndices: Set<number>) {\n\tconst v3 = createVec3() as vec3;\n\tconst v4 = createVec4() as vec4;\n\tfor (let i = 0; i < indices.length; i++) {\n\t\tconst index = indices[i];\n\t\tif (skipIndices.has(index)) continue;\n\n\t\tattribute.getElement(index, v4);\n\n\t\t// mat4 affine matrix applied to vector, vector interpreted as a direction.\n\t\t// Reference: https://github.com/mrdoob/three.js/blob/9f4de99828c05e71c47e6de0beb4c6e7652e486a/src/math/Vector3.js#L286-L300\n\t\tconst [x, y, z] = v4;\n\t\tv3[0] = matrix[0] * x + matrix[4] * y + matrix[8] * z;\n\t\tv3[1] = matrix[1] * x + matrix[5] * y + matrix[9] * z;\n\t\tv3[2] = matrix[2] * x + matrix[6] * y + matrix[10] * z;\n\t\tnormalizeVec3(v3, v3);\n\n\t\t(v4[0] = v3[0]), (v4[1] = v3[1]), (v4[2] = v3[2]);\n\n\t\tattribute.setElement(index, v4);\n\n\t\tskipIndices.add(index);\n\t}\n}\n","import { mat4, Accessor, Primitive, Mesh, PropertyType, PrimitiveTarget } from '@gltf-transform/core';\nimport { transformPrimitive } from './transform-primitive';\nimport { deepListAttributes } from './utils';\n\n/**\n * Applies a transform matrix to every {@link Primitive} in the given {@link Mesh}.\n *\n * Method:\n * - If any primitives are shared by other meshes, they will be detached.\n * - If any vertex streams are shared by primitives of other meshes, vertex data\n *  will be overwritten unless _overwrite=false_ or the indices are masked. If\n * \t_overwrite=false_, a detached copy of the vertex stream is made before applying\n * \tthe transform.\n * - Primitives within the mesh sharing vertex streams will continue to share those streams.\n * - For indexed primitives, only indexed vertices are modified.\n *\n * Example:\n *\n * ```javascript\n * import { fromTranslation } from 'gl-matrix/mat4';\n * import { transformMesh } from '@gltf-transform/functions';\n *\n * // offset vertices, y += 10.\n * transformMesh(mesh, fromTranslation([], [0, 10, 0]));\n * ```\n *\n * @param mesh\n * @param matrix\n * @param overwrite Whether to overwrite vertex streams in place. If false,\n * \t\tstreams shared with other meshes will be detached.\n * @param skipIndices Vertices, specified by index, to be _excluded_ from the transformation.\n */\nexport function transformMesh(mesh: Mesh, matrix: mat4, overwrite = false, skipIndices?: Set<number>): void {\n\t// (1) Detach shared prims.\n\tfor (const srcPrim of mesh.listPrimitives()) {\n\t\tconst isShared = srcPrim.listParents().some((p) => p.propertyType === PropertyType.MESH && p !== mesh);\n\t\tif (isShared) {\n\t\t\tconst dstPrim = srcPrim.clone();\n\t\t\tmesh.swap(srcPrim, dstPrim);\n\n\t\t\tfor (const srcTarget of dstPrim.listTargets()) {\n\t\t\t\tconst dstTarget = srcTarget.clone();\n\t\t\t\tdstPrim.swap(srcTarget, dstTarget);\n\t\t\t}\n\t\t}\n\t}\n\n\t// (2) Detach shared vertex streams.\n\tif (!overwrite) {\n\t\tconst parents = new Set<Primitive | PrimitiveTarget>([\n\t\t\t...mesh.listPrimitives(),\n\t\t\t...mesh.listPrimitives().flatMap((prim) => prim.listTargets()),\n\t\t]);\n\t\tconst attributes = new Map<Accessor, Accessor>();\n\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\tfor (const srcAttribute of deepListAttributes(prim)) {\n\t\t\t\tconst isShared = srcAttribute\n\t\t\t\t\t.listParents()\n\t\t\t\t\t.some((a) => (a instanceof Primitive || a instanceof PrimitiveTarget) && !parents.has(a));\n\t\t\t\tif (isShared && !attributes.has(srcAttribute)) {\n\t\t\t\t\tattributes.set(srcAttribute, srcAttribute.clone());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const parent of parents) {\n\t\t\tfor (const [srcAttribute, dstAttribute] of attributes) {\n\t\t\t\tparent.swap(srcAttribute, dstAttribute);\n\t\t\t}\n\t\t}\n\t}\n\n\t// (3) Apply transform.\n\tskipIndices = skipIndices || new Set<number>();\n\tfor (const prim of mesh.listPrimitives()) {\n\t\ttransformPrimitive(prim, matrix, skipIndices);\n\t}\n}\n","import { mat4, MathUtils, Node } from '@gltf-transform/core';\nimport { multiply as multiplyMat4 } from 'gl-matrix/mat4';\nimport { transformMesh } from './transform-mesh';\n\n// prettier-ignore\nconst IDENTITY: mat4 = [\n  1, 0, 0, 0,\n  0, 1, 0, 0,\n  0, 0, 1, 0,\n  0, 0, 0, 1\n];\n\n/**\n * Clears local transform of the {@link Node}, applying the transform to children and meshes.\n *\n * - Applies transform to children\n * - Applies transform to {@link Mesh mesh}\n * - Resets {@link Light lights}, {@link Camera cameras}, and other attachments to the origin\n *\n * Example:\n *\n * ```typescript\n * import { clearNodeTransform } from '@gltf-transform/functions';\n *\n * node.getTranslation(); // → [ 5, 0, 0 ]\n * node.getMesh(); // → vertex data centered at origin\n *\n * clearNodeTransform(node);\n *\n * node.getTranslation(); // → [ 0, 0, 0 ]\n * node.getMesh(); // → vertex data centered at [ 5, 0, 0 ]\n * ```\n *\n * To clear _all_ transforms of a Node, first clear its inherited transforms with\n * {@link clearNodeParent}, then clear the local transform with {@link clearNodeTransform}.\n */\nexport function clearNodeTransform(node: Node): Node {\n\tconst mesh = node.getMesh();\n\tconst localMatrix = node.getMatrix();\n\n\tif (mesh && !MathUtils.eq(localMatrix, IDENTITY)) {\n\t\ttransformMesh(mesh, localMatrix);\n\t}\n\n\tfor (const child of node.listChildren()) {\n\t\tconst matrix = child.getMatrix();\n\t\tmultiplyMat4(matrix, matrix, localMatrix);\n\t\tchild.setMatrix(matrix);\n\t}\n\n\treturn node.setMatrix(IDENTITY);\n}\n","import type { Accessor, Document, Primitive, Transform, vec3 } from '@gltf-transform/core';\nimport { createTransform } from './utils';\n\nconst NAME = 'colorspace';\n\n/** Options for the {@link colorspace} function. */\nexport interface ColorspaceOptions {\n\t/** Must be `\"sRGB\"`. Required. */\n\tinputEncoding: string;\n}\n\n/**\n * Vertex color colorspace correction. The glTF format requires vertex colors to be stored\n * as linear values, and this function provides a way to correct vertex colors that are\n * (incorrectly) sRGB.\n */\nexport function colorspace(options: ColorspaceOptions): Transform {\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\n\t\tif (options.inputEncoding === 'linear') {\n\t\t\tlogger.info(`${NAME}: Vertex colors already linear. Skipping conversion.`);\n\t\t\treturn;\n\t\t}\n\n\t\tif (options.inputEncoding !== 'sRGB') {\n\t\t\tlogger.error(\n\t\t\t\t`${NAME}: Unknown input encoding \"${options.inputEncoding}\" – should be \"sRGB\" or ` +\n\t\t\t\t\t'\"linear\". Skipping conversion.'\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tconst converted = new Set<Accessor>();\n\n\t\t// Source: THREE.Color\n\t\tfunction sRGBToLinear(c: number): number {\n\t\t\treturn c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n\t\t}\n\n\t\tfunction updatePrimitive(primitive: Primitive): void {\n\t\t\tconst color = [0, 0, 0] as vec3;\n\t\t\tlet attribute: Accessor | null;\n\t\t\tfor (let i = 0; (attribute = primitive.getAttribute(`COLOR_${i}`)); i++) {\n\t\t\t\tif (converted.has(attribute)) continue;\n\n\t\t\t\tfor (let j = 0; j < attribute.getCount(); j++) {\n\t\t\t\t\tattribute.getElement(j, color);\n\t\t\t\t\tcolor[0] = sRGBToLinear(color[0]);\n\t\t\t\t\tcolor[1] = sRGBToLinear(color[1]);\n\t\t\t\t\tcolor[2] = sRGBToLinear(color[2]);\n\t\t\t\t\tattribute.setElement(j, color);\n\t\t\t\t}\n\n\t\t\t\tconverted.add(attribute);\n\t\t\t}\n\t\t}\n\n\t\tdoc.getRoot()\n\t\t\t.listMeshes()\n\t\t\t.forEach((mesh) => mesh.listPrimitives().forEach(updatePrimitive));\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n","import {\n\tAccessor,\n\tBufferUtils,\n\tDocument,\n\tILogger,\n\tMaterial,\n\tMesh,\n\tPrimitive,\n\tPrimitiveTarget,\n\tPropertyType,\n\tRoot,\n\tTexture,\n\tTransform,\n} from '@gltf-transform/core';\nimport { createTransform } from './utils';\n\nconst NAME = 'dedup';\n\nexport interface DedupOptions {\n\t/** List of {@link PropertyType} identifiers to be de-duplicated.*/\n\tpropertyTypes: string[];\n}\n\nconst DEDUP_DEFAULTS: Required<DedupOptions> = {\n\tpropertyTypes: [PropertyType.ACCESSOR, PropertyType.MESH, PropertyType.TEXTURE, PropertyType.MATERIAL],\n};\n\n/**\n * Removes duplicate {@link Accessor}, {@link Mesh}, {@link Texture}, and {@link Material}\n * properties. Partially based on a\n * [gist by mattdesl](https://gist.github.com/mattdesl/aea40285e2d73916b6b9101b36d84da8). Only\n * accessors in mesh primitives, morph targets, and animation samplers are processed.\n *\n * Example:\n *\n * ```ts\n * document.getRoot().listMeshes(); // → [Mesh, Mesh, Mesh]\n *\n * await document.transform(dedup({propertyTypes: [PropertyType.MESH]}));\n *\n * document.getRoot().listMeshes(); // → [Mesh]\n * ```\n */\nexport const dedup = function (_options: DedupOptions = DEDUP_DEFAULTS): Transform {\n\tconst options = { ...DEDUP_DEFAULTS, ..._options } as Required<DedupOptions>;\n\n\tconst propertyTypes = new Set(options.propertyTypes);\n\tfor (const propertyType of options.propertyTypes) {\n\t\tif (!DEDUP_DEFAULTS.propertyTypes.includes(propertyType)) {\n\t\t\tthrow new Error(`${NAME}: Unsupported deduplication on type \"${propertyType}\".`);\n\t\t}\n\t}\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\n\t\tif (propertyTypes.has(PropertyType.ACCESSOR)) dedupAccessors(logger, doc);\n\t\tif (propertyTypes.has(PropertyType.TEXTURE)) dedupImages(logger, doc);\n\t\tif (propertyTypes.has(PropertyType.MATERIAL)) dedupMaterials(logger, doc);\n\t\tif (propertyTypes.has(PropertyType.MESH)) dedupMeshes(logger, doc);\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n};\n\nfunction dedupAccessors(logger: ILogger, doc: Document): void {\n\t// Find all accessors used for mesh data.\n\tconst indicesAccessors: Set<Accessor> = new Set();\n\tconst attributeAccessors: Set<Accessor> = new Set();\n\tconst inputAccessors: Set<Accessor> = new Set();\n\tconst outputAccessors: Set<Accessor> = new Set();\n\n\tconst meshes = doc.getRoot().listMeshes();\n\tmeshes.forEach((mesh) => {\n\t\tmesh.listPrimitives().forEach((primitive) => {\n\t\t\tprimitive.listAttributes().forEach((accessor) => attributeAccessors.add(accessor));\n\t\t\tconst indices = primitive.getIndices();\n\t\t\tif (indices) indicesAccessors.add(indices);\n\t\t});\n\t});\n\n\tfor (const animation of doc.getRoot().listAnimations()) {\n\t\tfor (const sampler of animation.listSamplers()) {\n\t\t\tconst input = sampler.getInput();\n\t\t\tconst output = sampler.getOutput();\n\t\t\tif (input) inputAccessors.add(input);\n\t\t\tif (output) outputAccessors.add(output);\n\t\t}\n\t}\n\n\t// Find duplicate accessors of a given type.\n\tfunction detectDuplicates(accessors: Accessor[]): Map<Accessor, Accessor> {\n\t\tconst duplicateAccessors: Map<Accessor, Accessor> = new Map();\n\n\t\tfor (let i = 0; i < accessors.length; i++) {\n\t\t\tconst a = accessors[i];\n\t\t\tconst aData = BufferUtils.toView(a.getArray()!);\n\n\t\t\tif (duplicateAccessors.has(a)) continue;\n\n\t\t\tfor (let j = 0; j < accessors.length; j++) {\n\t\t\t\tconst b = accessors[j];\n\n\t\t\t\tif (a === b) continue;\n\t\t\t\tif (duplicateAccessors.has(b)) continue;\n\n\t\t\t\tif (a.getType() !== b.getType()) continue;\n\t\t\t\tif (a.getComponentType() !== b.getComponentType()) continue;\n\t\t\t\tif (a.getCount() !== b.getCount()) continue;\n\t\t\t\tif (a.getNormalized() !== b.getNormalized()) continue;\n\t\t\t\tif (BufferUtils.equals(aData, BufferUtils.toView(b.getArray()!))) {\n\t\t\t\t\tduplicateAccessors.set(b, a);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn duplicateAccessors;\n\t}\n\n\tconst duplicateIndices = detectDuplicates(Array.from(indicesAccessors));\n\tlogger.debug(`${NAME}: Found ${duplicateIndices.size} duplicates among ${indicesAccessors.size} indices.`);\n\n\tconst duplicateAttributes = detectDuplicates(Array.from(attributeAccessors));\n\tlogger.debug(\n\t\t`${NAME}: Found ${duplicateAttributes.size} duplicates among ${attributeAccessors.size}` + ' attributes.'\n\t);\n\n\tconst duplicateInputs = detectDuplicates(Array.from(inputAccessors));\n\tconst duplicateOutputs = detectDuplicates(Array.from(outputAccessors));\n\tlogger.debug(\n\t\t`${NAME}: Found ${duplicateInputs.size + duplicateOutputs.size} duplicates among` +\n\t\t\t` ${inputAccessors.size + outputAccessors.size} animation accessors.`\n\t);\n\n\t// Dissolve duplicate vertex attributes and indices.\n\tmeshes.forEach((mesh) => {\n\t\tmesh.listPrimitives().forEach((primitive) => {\n\t\t\tprimitive.listAttributes().forEach((accessor) => {\n\t\t\t\tif (duplicateAttributes.has(accessor)) {\n\t\t\t\t\tprimitive.swap(accessor, duplicateAttributes.get(accessor) as Accessor);\n\t\t\t\t}\n\t\t\t});\n\t\t\tconst indices = primitive.getIndices();\n\t\t\tif (indices && duplicateIndices.has(indices)) {\n\t\t\t\tprimitive.swap(indices, duplicateIndices.get(indices) as Accessor);\n\t\t\t}\n\t\t});\n\t});\n\tArray.from(duplicateIndices.keys()).forEach((indices) => indices.dispose());\n\tArray.from(duplicateAttributes.keys()).forEach((attribute) => attribute.dispose());\n\n\t// Dissolve duplicate animation sampler inputs and outputs.\n\tfor (const animation of doc.getRoot().listAnimations()) {\n\t\tfor (const sampler of animation.listSamplers()) {\n\t\t\tconst input = sampler.getInput();\n\t\t\tconst output = sampler.getOutput();\n\t\t\tif (input && duplicateInputs.has(input)) {\n\t\t\t\tsampler.swap(input, duplicateInputs.get(input) as Accessor);\n\t\t\t}\n\t\t\tif (output && duplicateOutputs.has(output)) {\n\t\t\t\tsampler.swap(output, duplicateOutputs.get(output) as Accessor);\n\t\t\t}\n\t\t}\n\t}\n\tArray.from(duplicateInputs.keys()).forEach((input) => input.dispose());\n\tArray.from(duplicateOutputs.keys()).forEach((output) => output.dispose());\n}\n\nfunction dedupMeshes(logger: ILogger, doc: Document): void {\n\tconst root = doc.getRoot();\n\n\t// Create Reference -> ID lookup table.\n\tconst refs = new Map<Accessor | Material, number>();\n\troot.listAccessors().forEach((accessor, index) => refs.set(accessor, index));\n\troot.listMaterials().forEach((material, index) => refs.set(material, index));\n\n\t// For each mesh, create a hashkey.\n\tconst numMeshes = root.listMeshes().length;\n\tconst uniqueMeshes = new Map<string, Mesh>();\n\tfor (const src of root.listMeshes()) {\n\t\t// For each mesh, create a hashkey.\n\t\tconst srcKeyItems = [];\n\t\tfor (const prim of src.listPrimitives()) {\n\t\t\tsrcKeyItems.push(createPrimitiveKey(prim, refs));\n\t\t}\n\n\t\t// If another mesh exists with the same key, replace all instances with that, and dispose\n\t\t// of the duplicate. If not, just cache it.\n\t\tconst meshKey = srcKeyItems.join(';');\n\t\tif (uniqueMeshes.has(meshKey)) {\n\t\t\tconst targetMesh = uniqueMeshes.get(meshKey)!;\n\t\t\tsrc.listParents().forEach((parent) => {\n\t\t\t\tif (parent.propertyType !== PropertyType.ROOT) {\n\t\t\t\t\tparent.swap(src, targetMesh);\n\t\t\t\t}\n\t\t\t});\n\t\t\tsrc.dispose();\n\t\t} else {\n\t\t\tuniqueMeshes.set(meshKey, src);\n\t\t}\n\t}\n\n\tlogger.debug(`${NAME}: Found ${numMeshes - uniqueMeshes.size} duplicates among ${numMeshes} meshes.`);\n}\n\nfunction dedupImages(logger: ILogger, doc: Document): void {\n\tconst root = doc.getRoot();\n\tconst textures = root.listTextures();\n\tconst duplicates: Map<Texture, Texture> = new Map();\n\n\t// Compare each texture to every other texture — O(n²) — and mark duplicates for replacement.\n\tfor (let i = 0; i < textures.length; i++) {\n\t\tconst a = textures[i];\n\t\tconst aData = a.getImage();\n\n\t\tif (duplicates.has(a)) continue;\n\n\t\tfor (let j = 0; j < textures.length; j++) {\n\t\t\tconst b = textures[j];\n\t\t\tconst bData = b.getImage();\n\n\t\t\tif (a === b) continue;\n\t\t\tif (duplicates.has(b)) continue;\n\n\t\t\t// URIs are intentionally not compared.\n\t\t\tif (a.getMimeType() !== b.getMimeType()) continue;\n\n\t\t\tconst aSize = a.getSize();\n\t\t\tconst bSize = b.getSize();\n\t\t\tif (!aSize || !bSize) continue;\n\t\t\tif (aSize[0] !== bSize[0]) continue;\n\t\t\tif (aSize[1] !== bSize[1]) continue;\n\t\t\tif (!aData || !bData) continue;\n\t\t\tif (BufferUtils.equals(aData, bData)) {\n\t\t\t\tduplicates.set(b, a);\n\t\t\t}\n\t\t}\n\t}\n\n\tlogger.debug(`${NAME}: Found ${duplicates.size} duplicates among ${root.listTextures().length} textures.`);\n\n\tArray.from(duplicates.entries()).forEach(([src, dst]) => {\n\t\tsrc.listParents().forEach((property) => {\n\t\t\tif (!(property instanceof Root)) property.swap(src, dst);\n\t\t});\n\t\tsrc.dispose();\n\t});\n}\n\nfunction dedupMaterials(logger: ILogger, doc: Document): void {\n\tconst root = doc.getRoot();\n\tconst materials = root.listMaterials();\n\tconst duplicates: Map<Material, Material> = new Map();\n\tconst skip = new Set(['name']);\n\n\t// Compare each material to every other material — O(n²) — and mark duplicates for replacement.\n\tfor (let i = 0; i < materials.length; i++) {\n\t\tconst a = materials[i];\n\n\t\tif (duplicates.has(a)) continue;\n\n\t\tfor (let j = 0; j < materials.length; j++) {\n\t\t\tconst b = materials[j];\n\n\t\t\tif (a === b) continue;\n\t\t\tif (duplicates.has(b)) continue;\n\n\t\t\tif (a.equals(b, skip)) {\n\t\t\t\tduplicates.set(b, a);\n\t\t\t}\n\t\t}\n\t}\n\n\tlogger.debug(\n\t\t// eslint-disable-next-line max-len\n\t\t`${NAME}: Found ${duplicates.size} duplicates among ${root.listMaterials().length} materials.`\n\t);\n\n\tArray.from(duplicates.entries()).forEach(([src, dst]) => {\n\t\tsrc.listParents().forEach((property) => {\n\t\t\tif (!(property instanceof Root)) property.swap(src, dst);\n\t\t});\n\t\tsrc.dispose();\n\t});\n}\n\n/** Generates a key unique to the content of a primitive or target. */\nfunction createPrimitiveKey(prim: Primitive | PrimitiveTarget, refs: Map<Accessor | Material, number>): string {\n\tconst primKeyItems = [];\n\tfor (const semantic of prim.listSemantics()) {\n\t\tconst attribute = prim.getAttribute(semantic)!;\n\t\tprimKeyItems.push(semantic + ':' + refs.get(attribute));\n\t}\n\tif (prim instanceof Primitive) {\n\t\tconst indices = prim.getIndices();\n\t\tif (indices) {\n\t\t\tprimKeyItems.push('indices:' + refs.get(indices));\n\t\t}\n\t\tconst material = prim.getMaterial();\n\t\tif (material) {\n\t\t\tprimKeyItems.push('material:' + refs.get(material));\n\t\t}\n\t\tprimKeyItems.push('mode:' + prim.getMode());\n\t\tfor (const target of prim.listTargets()) {\n\t\t\tprimKeyItems.push('target:' + createPrimitiveKey(target, refs));\n\t\t}\n\t}\n\treturn primKeyItems.join(',');\n}\n","import type { Accessor, Document, Primitive, Transform } from '@gltf-transform/core';\nimport { KHRMeshQuantization } from '@gltf-transform/extensions';\nimport { createTransform } from './utils';\n\nconst NAME = 'dequantize';\n\n/** Options for the {@link dequantize} function. */\nexport interface DequantizeOptions {\n\t/**\n\t * Pattern (regex) used to filter vertex attribute semantics for quantization.\n\t * Default: `/^((?!JOINTS_).)*$/`.\n\t */\n\tpattern?: RegExp;\n}\n\nconst DEQUANTIZE_DEFAULTS: DequantizeOptions = {\n\tpattern: /^((?!JOINTS_).)*$/,\n};\n\n/**\n * Dequantize {@link Primitive Primitives}, removing {@link KHRMeshQuantization `KHR_mesh_quantization`}\n * if present. Dequantization will increase the size of the mesh on disk and in memory, but may be\n * necessary for compatibility with applications that don't support quantization.\n */\nexport function dequantize(_options: DequantizeOptions = DEQUANTIZE_DEFAULTS): Transform {\n\tconst options = { ...DEQUANTIZE_DEFAULTS, ..._options } as Required<DequantizeOptions>;\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tdequantizePrimitive(prim, options);\n\t\t\t}\n\t\t}\n\t\tdoc.createExtension(KHRMeshQuantization).dispose();\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\nfunction dequantizePrimitive(prim: Primitive, options: Required<DequantizeOptions>): void {\n\tfor (const semantic of prim.listSemantics()) {\n\t\tdequantizeAttribute(semantic, prim.getAttribute(semantic)!, options);\n\t}\n\tfor (const target of prim.listTargets()) {\n\t\tfor (const semantic of target.listSemantics()) {\n\t\t\tdequantizeAttribute(semantic, target.getAttribute(semantic)!, options);\n\t\t}\n\t}\n}\n\nfunction dequantizeAttribute(semantic: string, attribute: Accessor, options: Required<DequantizeOptions>): void {\n\tif (!attribute.getArray()) return;\n\tif (!options.pattern.test(semantic)) return;\n\tif (attribute.getComponentSize() >= 4) return;\n\n\tconst srcArray = attribute.getArray()!;\n\tconst dstArray = new Float32Array(srcArray.length);\n\n\tfor (let i = 0, il = attribute.getCount(), el = [] as number[]; i < il; i++) {\n\t\tel = attribute.getElement(i, el);\n\t\tattribute.setArray(dstArray).setElement(i, el).setArray(srcArray);\n\t}\n\n\tattribute.setArray(dstArray).setNormalized(false);\n}\n","import type { Document, Transform } from '@gltf-transform/core';\nimport { KHRDracoMeshCompression } from '@gltf-transform/extensions';\nimport { createTransform } from './utils';\n\nconst NAME = 'draco';\n\nexport interface DracoOptions {\n\tmethod?: 'edgebreaker' | 'sequential';\n\tencodeSpeed?: number;\n\tdecodeSpeed?: number;\n\tquantizePosition?: number;\n\tquantizeNormal?: number;\n\tquantizeColor?: number;\n\tquantizeTexcoord?: number;\n\tquantizeGeneric?: number;\n\tquantizationVolume?: 'mesh' | 'scene';\n}\n\nexport const DRACO_DEFAULTS: DracoOptions = {\n\tmethod: 'edgebreaker',\n\tencodeSpeed: 5,\n\tdecodeSpeed: 5,\n\tquantizePosition: 14,\n\tquantizeNormal: 10,\n\tquantizeColor: 8,\n\tquantizeTexcoord: 12,\n\tquantizeGeneric: 12,\n\tquantizationVolume: 'mesh',\n};\n\n/**\n * Applies Draco compression using {@link KHRDracoMeshCompression KHR_draco_mesh_compression}.\n * This type of compression can reduce the size of triangle geometry.\n *\n * This function is a thin wrapper around the {@link KHRDracoMeshCompression} extension itself.\n */\nexport const draco = (_options: DracoOptions = DRACO_DEFAULTS): Transform => {\n\tconst options = { ...DRACO_DEFAULTS, ..._options } as Required<DracoOptions>;\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tdoc.createExtension(KHRDracoMeshCompression)\n\t\t\t.setRequired(true)\n\t\t\t.setEncoderOptions({\n\t\t\t\tmethod:\n\t\t\t\t\toptions.method === 'edgebreaker'\n\t\t\t\t\t\t? KHRDracoMeshCompression.EncoderMethod.EDGEBREAKER\n\t\t\t\t\t\t: KHRDracoMeshCompression.EncoderMethod.SEQUENTIAL,\n\t\t\t\tencodeSpeed: options.encodeSpeed,\n\t\t\t\tdecodeSpeed: options.decodeSpeed,\n\t\t\t\tquantizationBits: {\n\t\t\t\t\tPOSITION: options.quantizePosition,\n\t\t\t\t\tNORMAL: options.quantizeNormal,\n\t\t\t\t\tCOLOR: options.quantizeColor,\n\t\t\t\t\tTEX_COORD: options.quantizeTexcoord,\n\t\t\t\t\tGENERIC: options.quantizeGeneric,\n\t\t\t\t},\n\t\t\t\tquantizationVolume: options.quantizationVolume,\n\t\t\t});\n\t});\n};\n","import {\n\tAnimationChannel,\n\tDocument,\n\tGraph,\n\tProperty,\n\tPropertyType,\n\tRoot,\n\tTransform,\n\tNode,\n\tScene,\n\tExtensionProperty,\n\tMaterial,\n\tPrimitive,\n\tPrimitiveTarget,\n\tTexture,\n\tTextureInfo,\n} from '@gltf-transform/core';\nimport { createTransform } from './utils';\n\nconst NAME = 'prune';\n\nexport interface PruneOptions {\n\t/** List of {@link PropertyType} identifiers to be de-duplicated.*/\n\tpropertyTypes?: string[];\n\t/** Whether to keep empty leaf nodes. */\n\tkeepLeaves?: boolean;\n\t/** Whether to keep unused vertex attributes, such as UVs without an assigned texture. */\n\tkeepAttributes?: boolean;\n}\nconst PRUNE_DEFAULTS: Required<PruneOptions> = {\n\tpropertyTypes: [\n\t\tPropertyType.NODE,\n\t\tPropertyType.SKIN,\n\t\tPropertyType.MESH,\n\t\tPropertyType.CAMERA,\n\t\tPropertyType.PRIMITIVE,\n\t\tPropertyType.PRIMITIVE_TARGET,\n\t\tPropertyType.ANIMATION,\n\t\tPropertyType.MATERIAL,\n\t\tPropertyType.TEXTURE,\n\t\tPropertyType.ACCESSOR,\n\t\tPropertyType.BUFFER,\n\t],\n\tkeepLeaves: false,\n\tkeepAttributes: true,\n};\n\n/**\n * Removes properties from the file if they are not referenced by a {@link Scene}. Commonly helpful\n * for cleaning up after other operations, e.g. allowing a node to be detached and any unused\n * meshes, materials, or other resources to be removed automatically.\n *\n * Example:\n *\n * ```\n * document.getRoot().listMaterials(); // → [Material, Material]\n *\n * await document.transform(prune());\n *\n * document.getRoot().listMaterials(); // → [Material]\n * ```\n *\n * No options are currently implemented for this function.\n */\nexport const prune = function (_options: PruneOptions = PRUNE_DEFAULTS): Transform {\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst options = { ...PRUNE_DEFAULTS, ..._options } as Required<PruneOptions>;\n\tconst propertyTypes = new Set(options.propertyTypes);\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\t\tconst graph = doc.getGraph();\n\n\t\tconst disposed: Record<string, number> = {};\n\n\t\t// Prune top-down, so that low-level properties like accessors can be removed if the\n\t\t// properties referencing them are removed.\n\n\t\t// Prune empty Meshes.\n\t\tif (propertyTypes.has(PropertyType.MESH)) {\n\t\t\tfor (const mesh of root.listMeshes()) {\n\t\t\t\tif (mesh.listPrimitives().length > 0) continue;\n\t\t\t\tmesh.dispose();\n\t\t\t\tmarkDisposed(mesh);\n\t\t\t}\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.NODE) && !options.keepLeaves) root.listScenes().forEach(nodeTreeShake);\n\t\tif (propertyTypes.has(PropertyType.NODE)) root.listNodes().forEach(treeShake);\n\t\tif (propertyTypes.has(PropertyType.SKIN)) root.listSkins().forEach(treeShake);\n\t\tif (propertyTypes.has(PropertyType.MESH)) root.listMeshes().forEach(treeShake);\n\t\tif (propertyTypes.has(PropertyType.CAMERA)) root.listCameras().forEach(treeShake);\n\n\t\tif (propertyTypes.has(PropertyType.PRIMITIVE)) {\n\t\t\tindirectTreeShake(graph, PropertyType.PRIMITIVE);\n\t\t}\n\t\tif (propertyTypes.has(PropertyType.PRIMITIVE_TARGET)) {\n\t\t\tindirectTreeShake(graph, PropertyType.PRIMITIVE_TARGET);\n\t\t}\n\n\t\t// Prune unused vertex attributes.\n\t\tif (!options.keepAttributes && propertyTypes.has(PropertyType.ACCESSOR)) {\n\t\t\tfor (const mesh of root.listMeshes()) {\n\t\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\t\tconst required = listRequiredSemantics(doc, prim.getMaterial());\n\t\t\t\t\tconst unused = listUnusedSemantics(prim, required);\n\t\t\t\t\tpruneAttributes(prim, unused);\n\t\t\t\t\tprim.listTargets().forEach((target) => pruneAttributes(target, unused));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Pruning animations is a bit more complicated:\n\t\t// (1) Remove channels without target nodes.\n\t\t// (2) Remove animations without channels.\n\t\t// (3) Remove samplers orphaned in the process.\n\t\tif (propertyTypes.has(PropertyType.ANIMATION)) {\n\t\t\tfor (const anim of root.listAnimations()) {\n\t\t\t\tfor (const channel of anim.listChannels()) {\n\t\t\t\t\tif (!channel.getTargetNode()) {\n\t\t\t\t\t\tchannel.dispose();\n\t\t\t\t\t\tmarkDisposed(channel);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!anim.listChannels().length) {\n\t\t\t\t\tconst samplers = anim.listSamplers();\n\t\t\t\t\ttreeShake(anim);\n\t\t\t\t\tsamplers.forEach(treeShake);\n\t\t\t\t} else {\n\t\t\t\t\tanim.listSamplers().forEach(treeShake);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.MATERIAL)) root.listMaterials().forEach(treeShake);\n\t\tif (propertyTypes.has(PropertyType.TEXTURE)) root.listTextures().forEach(treeShake);\n\t\tif (propertyTypes.has(PropertyType.ACCESSOR)) root.listAccessors().forEach(treeShake);\n\t\tif (propertyTypes.has(PropertyType.BUFFER)) root.listBuffers().forEach(treeShake);\n\n\t\t// TODO(bug): This process does not identify unused ExtensionProperty instances. That could\n\t\t// be a future enhancement, either tracking unlinked properties as if they were connected\n\t\t// to the Graph, or iterating over a property list provided by the Extension. Properties in\n\t\t// use by an Extension are correctly preserved, in the meantime.\n\n\t\tif (Object.keys(disposed).length) {\n\t\t\tconst str = Object.keys(disposed)\n\t\t\t\t.map((t) => `${t} (${disposed[t]})`)\n\t\t\t\t.join(', ');\n\t\t\tlogger.info(`${NAME}: Removed types... ${str}`);\n\t\t} else {\n\t\t\tlogger.info(`${NAME}: No unused properties found.`);\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\n\t\t//\n\n\t\t/** Disposes of the given property if it is unused. */\n\t\tfunction treeShake(prop: Property): void {\n\t\t\t// Consider a property unused if it has no references from another property, excluding\n\t\t\t// types Root and AnimationChannel.\n\t\t\tconst parents = prop.listParents().filter((p) => !(p instanceof Root || p instanceof AnimationChannel));\n\t\t\tif (!parents.length) {\n\t\t\t\tprop.dispose();\n\t\t\t\tmarkDisposed(prop);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * For property types the Root does not maintain references to, we'll need to search the\n\t\t * graph. It's possible that objects may have been constructed without any outbound links,\n\t\t * but since they're not on the graph they don't need to be tree-shaken.\n\t\t */\n\t\tfunction indirectTreeShake(graph: Graph<Property>, propertyType: string): void {\n\t\t\tgraph\n\t\t\t\t.listEdges()\n\t\t\t\t.map((edge) => edge.getParent())\n\t\t\t\t.filter((parent) => parent.propertyType === propertyType)\n\t\t\t\t.forEach(treeShake);\n\t\t}\n\n\t\t/** Iteratively prunes leaf Nodes without contents. */\n\t\tfunction nodeTreeShake(prop: Node | Scene): void {\n\t\t\tprop.listChildren().forEach(nodeTreeShake);\n\n\t\t\tif (prop instanceof Scene) return;\n\n\t\t\tconst isUsed = graph.listParentEdges(prop).some((e) => {\n\t\t\t\tconst ptype = e.getParent().propertyType;\n\t\t\t\treturn ptype !== PropertyType.ROOT && ptype !== PropertyType.SCENE && ptype !== PropertyType.NODE;\n\t\t\t});\n\t\t\tconst isEmpty = graph.listChildren(prop).length === 0;\n\t\t\tif (isEmpty && !isUsed) {\n\t\t\t\tprop.dispose();\n\t\t\t\tmarkDisposed(prop);\n\t\t\t}\n\t\t}\n\n\t\tfunction pruneAttributes(prim: Primitive | PrimitiveTarget, unused: string[]) {\n\t\t\tfor (const semantic of unused) {\n\t\t\t\tprim.setAttribute(semantic, null);\n\t\t\t}\n\t\t}\n\n\t\t/** Records properties disposed by type. */\n\t\tfunction markDisposed(prop: Property): void {\n\t\t\tdisposed[prop.propertyType] = disposed[prop.propertyType] || 0;\n\t\t\tdisposed[prop.propertyType]++;\n\t\t}\n\t});\n};\n\n/**\n * Lists vertex attribute semantics that are unused when rendering a given primitive.\n */\nfunction listUnusedSemantics(prim: Primitive | PrimitiveTarget, required: Set<string>): string[] {\n\tconst unused = [];\n\tfor (const semantic of prim.listSemantics()) {\n\t\tif (semantic === 'TANGENT' && !required.has(semantic)) {\n\t\t\tunused.push(semantic);\n\t\t} else if (semantic.startsWith('TEXCOORD_') && !required.has(semantic)) {\n\t\t\tunused.push(semantic);\n\t\t} else if (semantic.startsWith('COLOR_') && semantic !== 'COLOR_0') {\n\t\t\tunused.push(semantic);\n\t\t}\n\t}\n\treturn unused;\n}\n\n/**\n * Lists vertex attribute semantics required by a material. Does not include\n * attributes that would be used unconditionally, like POSITION or NORMAL.\n */\nfunction listRequiredSemantics(\n\tdocument: Document,\n\tmaterial: Material | ExtensionProperty | null,\n\tsemantics = new Set<string>()\n): Set<string> {\n\tif (!material) return semantics;\n\n\tconst graph = document.getGraph();\n\n\tconst edges = graph.listChildEdges(material);\n\tconst textureNames = new Set<string>();\n\n\tfor (const edge of edges) {\n\t\tif (edge.getChild() instanceof Texture) {\n\t\t\ttextureNames.add(edge.getName());\n\t\t}\n\t}\n\n\tfor (const edge of edges) {\n\t\tconst name = edge.getName();\n\t\tconst child = edge.getChild();\n\n\t\tif (child instanceof TextureInfo) {\n\t\t\tif (textureNames.has(name.replace(/Info$/, ''))) {\n\t\t\t\tsemantics.add(`TEXCOORD_${child.getTexCoord()}`);\n\t\t\t}\n\t\t}\n\n\t\tif (child instanceof Texture && name.match(/normalTexture/i)) {\n\t\t\tsemantics.add('TANGENT');\n\t\t}\n\n\t\tif (child instanceof ExtensionProperty) {\n\t\t\tlistRequiredSemantics(document, child, semantics);\n\t\t}\n\n\t\t// TODO(#748): Does KHR_materials_anisotropy imply required vertex attributes?\n\t}\n\n\treturn semantics;\n}\n","import { Document, Node, PropertyType, Transform } from '@gltf-transform/core';\nimport { clearNodeParent } from './clear-node-parent';\nimport { prune } from './prune';\nimport { createTransform } from './utils';\n\nconst NAME = 'flatten';\n\n/** Options for the {@link flatten} function. */\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface FlattenOptions {}\n\nexport const FLATTEN_DEFAULTS: Required<FlattenOptions> = {};\n\n/**\n * Flattens the scene graph, leaving {@link Node Nodes} with\n * {@link Mesh Meshes}, {@link Camera Cameras}, and other attachments\n * as direct children of the {@link Scene}. Skeletons and their\n * descendants are left in their original Node structure.\n *\n * {@link Animation} targeting a Node or its parents will\n * prevent that Node from being moved.\n *\n * Example:\n *\n * ```ts\n * import { flatten } from '@gltf-transform/functions';\n *\n * await document.transform(flatten());\n * ```\n */\nexport function flatten(_options: FlattenOptions = FLATTEN_DEFAULTS): Transform {\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst options = { ...FLATTEN_DEFAULTS, ..._options } as Required<FlattenOptions>;\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst root = document.getRoot();\n\t\tconst logger = document.getLogger();\n\n\t\t// (1) Mark joints.\n\t\tconst joints = new Set<Node>();\n\t\tfor (const skin of root.listSkins()) {\n\t\t\tfor (const joint of skin.listJoints()) {\n\t\t\t\tjoints.add(joint);\n\t\t\t}\n\t\t}\n\n\t\t// (2) Mark animated nodes.\n\t\tconst animated = new Set<Node>();\n\t\tfor (const animation of root.listAnimations()) {\n\t\t\tfor (const channel of animation.listChannels()) {\n\t\t\t\tconst node = channel.getTargetNode();\n\t\t\t\tif (node) {\n\t\t\t\t\tanimated.add(node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// (3) Mark descendants of joints and animated nodes.\n\t\tconst hasJointParent = new Set<Node>();\n\t\tconst hasAnimatedParent = new Set<Node>();\n\t\tfor (const scene of root.listScenes()) {\n\t\t\tscene.traverse((node) => {\n\t\t\t\tconst parent = node.getParent();\n\t\t\t\tif (!(parent instanceof Node)) return;\n\t\t\t\tif (joints.has(parent) || hasJointParent.has(parent)) {\n\t\t\t\t\thasJointParent.add(node);\n\t\t\t\t}\n\t\t\t\tif (animated.has(parent) || hasAnimatedParent.has(parent)) {\n\t\t\t\t\thasAnimatedParent.add(node);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// (4) For each affected node, in top-down order, clear parents.\n\t\tfor (const scene of root.listScenes()) {\n\t\t\tscene.traverse((node) => {\n\t\t\t\tif (animated.has(node)) return;\n\t\t\t\tif (hasJointParent.has(node)) return;\n\t\t\t\tif (hasAnimatedParent.has(node)) return;\n\n\t\t\t\tclearNodeParent(node);\n\t\t\t});\n\t\t}\n\n\t\t// TODO(feat): Transform animation channels, accounting for previously inherited transforms.\n\t\tif (animated.size) {\n\t\t\tlogger.debug(`${NAME}: Flattening node hierarchies with TRS animation not yet supported.`);\n\t\t}\n\n\t\t// (5) Clean up leaf nodes.\n\t\tawait document.transform(prune({ propertyTypes: [PropertyType.NODE], keepLeaves: false }));\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n","import {\n\tAccessor,\n\tDocument,\n\tExtensionProperty,\n\tGLTF,\n\tImageUtils,\n\tTexture,\n\tgetBounds,\n\tPropertyType,\n} from '@gltf-transform/core';\nimport { getGLPrimitiveCount } from './utils';\nimport { KHR_DF_MODEL_ETC1S, KHR_DF_MODEL_UASTC, read as readKTX } from 'ktx-parse';\n\n/** Inspects the contents of a glTF file and returns a JSON report. */\nexport function inspect(doc: Document): InspectReport {\n\treturn {\n\t\tscenes: listScenes(doc),\n\t\tmeshes: listMeshes(doc),\n\t\tmaterials: listMaterials(doc),\n\t\ttextures: listTextures(doc),\n\t\tanimations: listAnimations(doc),\n\t};\n}\n\n/** List scenes. */\nfunction listScenes(doc: Document): InspectPropertyReport<InspectSceneReport> {\n\tconst scenes = doc\n\t\t.getRoot()\n\t\t.listScenes()\n\t\t.map((scene) => {\n\t\t\tconst root = scene.listChildren()[0];\n\t\t\tconst sceneBounds = getBounds(scene);\n\t\t\treturn {\n\t\t\t\tname: scene.getName(),\n\t\t\t\trootName: root ? root.getName() : '',\n\t\t\t\tbboxMin: toPrecision(sceneBounds.min),\n\t\t\t\tbboxMax: toPrecision(sceneBounds.max),\n\t\t\t};\n\t\t});\n\treturn { properties: scenes };\n}\n\n/** List meshes. */\nfunction listMeshes(doc: Document): InspectPropertyReport<InspectMeshReport> {\n\tconst meshes: InspectMeshReport[] = doc\n\t\t.getRoot()\n\t\t.listMeshes()\n\t\t.map((mesh) => {\n\t\t\tconst instances = mesh.listParents().filter((parent) => parent.propertyType !== PropertyType.ROOT).length;\n\t\t\tlet glPrimitives = 0;\n\t\t\tlet verts = 0;\n\t\t\tconst semantics = new Set<string>();\n\t\t\tconst meshIndices = new Set<string>();\n\t\t\tconst meshAccessors: Set<Accessor> = new Set();\n\n\t\t\tmesh.listPrimitives().forEach((prim) => {\n\t\t\t\tfor (const semantic of prim.listSemantics()) {\n\t\t\t\t\tconst attr = prim.getAttribute(semantic)!;\n\t\t\t\t\tsemantics.add(semantic + ':' + accessorToTypeLabel(attr));\n\t\t\t\t\tmeshAccessors.add(attr);\n\t\t\t\t}\n\t\t\t\tfor (const targ of prim.listTargets()) {\n\t\t\t\t\ttarg.listAttributes().forEach((attr) => meshAccessors.add(attr));\n\t\t\t\t}\n\t\t\t\tconst indices = prim.getIndices();\n\t\t\t\tif (indices) {\n\t\t\t\t\tmeshIndices.add(accessorToTypeLabel(indices));\n\t\t\t\t\tmeshAccessors.add(indices);\n\t\t\t\t}\n\t\t\t\tverts += prim.listAttributes()[0].getCount();\n\t\t\t\tglPrimitives += getGLPrimitiveCount(prim);\n\t\t\t});\n\n\t\t\tlet size = 0;\n\t\t\tArray.from(meshAccessors).forEach((a) => (size += a.getArray()!.byteLength));\n\n\t\t\tconst modes = mesh.listPrimitives().map((prim) => MeshPrimitiveModeLabels[prim.getMode()]);\n\n\t\t\treturn {\n\t\t\t\tname: mesh.getName(),\n\t\t\t\tmode: Array.from(new Set(modes)),\n\t\t\t\tprimitives: mesh.listPrimitives().length,\n\t\t\t\tglPrimitives: glPrimitives,\n\t\t\t\tvertices: verts,\n\t\t\t\tindices: Array.from(meshIndices).sort(),\n\t\t\t\tattributes: Array.from(semantics).sort(),\n\t\t\t\tinstances: instances,\n\t\t\t\tsize: size,\n\t\t\t};\n\t\t});\n\n\treturn { properties: meshes };\n}\n\n/** List materials. */\nfunction listMaterials(doc: Document): InspectPropertyReport<InspectMaterialReport> {\n\tconst materials: InspectMaterialReport[] = doc\n\t\t.getRoot()\n\t\t.listMaterials()\n\t\t.map((material) => {\n\t\t\tconst instances = material\n\t\t\t\t.listParents()\n\t\t\t\t.filter((parent) => parent.propertyType !== PropertyType.ROOT).length;\n\n\t\t\t// Find all texture slots attached to this material or its extensions.\n\t\t\tconst extensions = new Set<ExtensionProperty>(material.listExtensions());\n\t\t\tconst slots = doc\n\t\t\t\t.getGraph()\n\t\t\t\t.listEdges()\n\t\t\t\t.filter((ref) => {\n\t\t\t\t\tconst child = ref.getChild();\n\t\t\t\t\tconst parent = ref.getParent();\n\t\t\t\t\tif (child instanceof Texture && parent === material) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (child instanceof Texture && parent instanceof ExtensionProperty && extensions.has(parent)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t})\n\t\t\t\t.map((ref) => ref.getName());\n\n\t\t\treturn {\n\t\t\t\tname: material.getName(),\n\t\t\t\tinstances,\n\t\t\t\ttextures: slots,\n\t\t\t\talphaMode: material.getAlphaMode(),\n\t\t\t\tdoubleSided: material.getDoubleSided(),\n\t\t\t};\n\t\t});\n\n\treturn { properties: materials };\n}\n\n/** List textures. */\nfunction listTextures(doc: Document): InspectPropertyReport<InspectTextureReport> {\n\tconst textures: InspectTextureReport[] = doc\n\t\t.getRoot()\n\t\t.listTextures()\n\t\t.map((texture) => {\n\t\t\tconst instances = texture\n\t\t\t\t.listParents()\n\t\t\t\t.filter((parent) => parent.propertyType !== PropertyType.ROOT).length;\n\n\t\t\tconst slots = doc\n\t\t\t\t.getGraph()\n\t\t\t\t.listParentEdges(texture)\n\t\t\t\t.filter((edge) => edge.getParent().propertyType !== PropertyType.ROOT)\n\t\t\t\t.map((edge) => edge.getName());\n\n\t\t\tconst resolution = ImageUtils.getSize(texture.getImage()!, texture.getMimeType());\n\n\t\t\tlet compression = '';\n\t\t\tif (texture.getMimeType() === 'image/ktx2') {\n\t\t\t\tconst container = readKTX(texture.getImage()!);\n\t\t\t\tconst dfd = container.dataFormatDescriptor[0];\n\t\t\t\tif (dfd.colorModel === KHR_DF_MODEL_ETC1S) {\n\t\t\t\t\tcompression = 'ETC1S';\n\t\t\t\t} else if (dfd.colorModel === KHR_DF_MODEL_UASTC) {\n\t\t\t\t\tcompression = 'UASTC';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tname: texture.getName(),\n\t\t\t\turi: texture.getURI(),\n\t\t\t\tslots: Array.from(new Set(slots)),\n\t\t\t\tinstances,\n\t\t\t\tmimeType: texture.getMimeType(),\n\t\t\t\tcompression,\n\t\t\t\tresolution: resolution ? resolution.join('x') : '',\n\t\t\t\tsize: texture.getImage()!.byteLength,\n\t\t\t\tgpuSize: ImageUtils.getVRAMByteLength(texture.getImage()!, texture.getMimeType()),\n\t\t\t};\n\t\t});\n\n\treturn { properties: textures };\n}\n\n/** List animations. */\nfunction listAnimations(doc: Document): InspectPropertyReport<InspectAnimationReport> {\n\tconst animations: InspectAnimationReport[] = doc\n\t\t.getRoot()\n\t\t.listAnimations()\n\t\t.map((anim) => {\n\t\t\tlet minTime = Infinity;\n\t\t\tlet maxTime = -Infinity;\n\t\t\tanim.listSamplers().forEach((sampler) => {\n\t\t\t\tconst input = sampler.getInput();\n\t\t\t\tif (!input) return;\n\t\t\t\tminTime = Math.min(minTime, input.getMin([])[0]);\n\t\t\t\tmaxTime = Math.max(maxTime, input.getMax([])[0]);\n\t\t\t});\n\n\t\t\tlet size = 0;\n\t\t\tlet keyframes = 0;\n\t\t\tconst accessors: Set<Accessor> = new Set();\n\t\t\tanim.listSamplers().forEach((sampler) => {\n\t\t\t\tconst input = sampler.getInput();\n\t\t\t\tconst output = sampler.getOutput();\n\t\t\t\tif (!input) return;\n\t\t\t\tkeyframes += input.getCount();\n\t\t\t\taccessors.add(input);\n\t\t\t\tif (!output) return;\n\t\t\t\taccessors.add(output);\n\t\t\t});\n\t\t\tArray.from(accessors).forEach((accessor) => {\n\t\t\t\tsize += accessor.getArray()!.byteLength;\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tname: anim.getName(),\n\t\t\t\tchannels: anim.listChannels().length,\n\t\t\t\tsamplers: anim.listSamplers().length,\n\t\t\t\tduration: Math.round((maxTime - minTime) * 1000) / 1000,\n\t\t\t\tkeyframes: keyframes,\n\t\t\t\tsize: size,\n\t\t\t};\n\t\t});\n\n\treturn { properties: animations };\n}\n\nexport interface InspectReport {\n\tscenes: InspectPropertyReport<InspectSceneReport>;\n\tmeshes: InspectPropertyReport<InspectMeshReport>;\n\tmaterials: InspectPropertyReport<InspectMaterialReport>;\n\ttextures: InspectPropertyReport<InspectTextureReport>;\n\tanimations: InspectPropertyReport<InspectAnimationReport>;\n}\n\nexport interface InspectPropertyReport<T> {\n\tproperties: T[];\n\terrors?: string[];\n\twarnings?: string[];\n}\n\nexport interface InspectSceneReport {\n\tname: string;\n\trootName: string;\n\tbboxMin: number[];\n\tbboxMax: number[];\n}\n\nexport interface InspectMeshReport {\n\tname: string;\n\tprimitives: number;\n\tmode: string[];\n\tvertices: number;\n\tglPrimitives: number;\n\tindices: string[];\n\tattributes: string[];\n\tinstances: number;\n\tsize: number;\n}\n\nexport interface InspectMaterialReport {\n\tname: string;\n\tinstances: number;\n\ttextures: string[];\n\talphaMode: GLTF.MaterialAlphaMode;\n\tdoubleSided: boolean;\n}\n\nexport interface InspectTextureReport {\n\tname: string;\n\turi: string;\n\tslots: string[];\n\tinstances: number;\n\tmimeType: string;\n\tresolution: string;\n\tcompression: string;\n\tsize: number;\n\tgpuSize: number | null;\n}\n\nexport interface InspectAnimationReport {\n\tname: string;\n\tchannels: number;\n\tsamplers: number;\n\tkeyframes: number;\n\tduration: number;\n\tsize: number;\n}\n\nconst MeshPrimitiveModeLabels = [\n\t'POINTS',\n\t'LINES',\n\t'LINE_LOOP',\n\t'LINE_STRIP',\n\t'TRIANGLES',\n\t'TRIANGLE_STRIP',\n\t'TRIANGLE_FAN',\n];\n\nconst NumericTypeLabels: Record<string, string> = {\n\tFloat32Array: 'f32',\n\tUint32Array: 'u32',\n\tUint16Array: 'u16',\n\tUint8Array: 'u8',\n\tInt32Array: 'i32',\n\tInt16Array: 'i16',\n\tInt8Array: 'i8',\n};\n\n/** Maps values in a vector to a finite precision. */\nfunction toPrecision(v: number[]): number[] {\n\tfor (let i = 0; i < v.length; i++) {\n\t\tif ((v[i] as number).toFixed) v[i] = Number(v[i].toFixed(5));\n\t}\n\treturn v;\n}\n\nfunction accessorToTypeLabel(accessor: Accessor): string {\n\tconst array = accessor.getArray()!;\n\tconst base = NumericTypeLabels[array.constructor.name] || '?';\n\tconst suffix = accessor.getNormalized() ? '_norm' : '';\n\treturn base + suffix;\n}\n","import { Document, ILogger, MathUtils, Mesh, Node, Transform, vec3, vec4 } from '@gltf-transform/core';\nimport { InstancedMesh, EXTMeshGPUInstancing } from '@gltf-transform/extensions';\nimport { createTransform } from './utils';\n\nconst NAME = 'instance';\n\nexport interface InstanceOptions {\n\t/** Minimum number of meshes considered eligible for instancing. Default: 2. */\n\tmin?: number;\n}\n\nconst INSTANCE_DEFAULTS: Required<InstanceOptions> = {\n\tmin: 2,\n};\n\n/**\n * Creates GPU instances (with `EXT_mesh_gpu_instancing`) for shared {@link Mesh} references. In\n * engines supporting the extension, reused Meshes will be drawn with GPU instancing, greatly\n * reducing draw calls and improving performance in many cases. If you're not sure that identical\n * Meshes share vertex data and materials (\"linked duplicates\"), run {@link dedup} first to link them.\n *\n * Example:\n *\n * ```javascript\n * import { dedup, instance } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \tdedup(),\n * \tinstance({min: 2}),\n * );\n * ```\n */\nexport function instance(_options: InstanceOptions = INSTANCE_DEFAULTS): Transform {\n\tconst options = { ...INSTANCE_DEFAULTS, ..._options } as Required<InstanceOptions>;\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\t\tconst batchExtension = doc.createExtension(EXTMeshGPUInstancing);\n\n\t\tif (root.listAnimations().length) {\n\t\t\tlogger.warn(`${NAME}: Instancing is not currently supported for animated models.`);\n\t\t\tlogger.debug(`${NAME}: Complete.`);\n\t\t\treturn;\n\t\t}\n\n\t\tlet numBatches = 0;\n\t\tlet numInstances = 0;\n\n\t\tfor (const scene of root.listScenes()) {\n\t\t\t// Gather a one-to-many Mesh/Node mapping, identifying what we can instance.\n\t\t\tconst meshInstances = new Map<Mesh, Set<Node>>();\n\t\t\tscene.traverse((node) => {\n\t\t\t\tconst mesh = node.getMesh();\n\t\t\t\tif (!mesh) return;\n\t\t\t\tmeshInstances.set(mesh, (meshInstances.get(mesh) || new Set<Node>()).add(node));\n\t\t\t});\n\n\t\t\t// For each Mesh, create an InstancedMesh and collect transforms.\n\t\t\tconst modifiedNodes = [];\n\t\t\tfor (const mesh of Array.from(meshInstances.keys())) {\n\t\t\t\tconst nodes = Array.from(meshInstances.get(mesh)!);\n\t\t\t\tif (nodes.length < options.min) continue;\n\t\t\t\tif (nodes.some((node) => node.getSkin())) continue;\n\n\t\t\t\tconst batch = createBatch(doc, batchExtension, mesh, nodes.length);\n\t\t\t\tconst batchTranslation = batch.getAttribute('TRANSLATION')!;\n\t\t\t\tconst batchRotation = batch.getAttribute('ROTATION')!;\n\t\t\t\tconst batchScale = batch.getAttribute('SCALE')!;\n\n\t\t\t\tconst batchNode = doc.createNode().setMesh(mesh).setExtension('EXT_mesh_gpu_instancing', batch);\n\t\t\t\tscene.addChild(batchNode);\n\n\t\t\t\tlet needsTranslation = false;\n\t\t\t\tlet needsRotation = false;\n\t\t\t\tlet needsScale = false;\n\n\t\t\t\t// For each Node, write TRS properties into instance attributes.\n\t\t\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\t\t\tlet t: vec3, r: vec4, s: vec3;\n\t\t\t\t\tconst node = nodes[i];\n\n\t\t\t\t\tbatchTranslation.setElement(i, (t = node.getWorldTranslation()));\n\t\t\t\t\tbatchRotation.setElement(i, (r = node.getWorldRotation()));\n\t\t\t\t\tbatchScale.setElement(i, (s = node.getWorldScale()));\n\n\t\t\t\t\tif (!MathUtils.eq(t, [0, 0, 0])) needsTranslation = true;\n\t\t\t\t\tif (!MathUtils.eq(r, [0, 0, 0, 1])) needsRotation = true;\n\t\t\t\t\tif (!MathUtils.eq(s, [1, 1, 1])) needsScale = true;\n\n\t\t\t\t\t// Mark the node for cleanup.\n\t\t\t\t\tnode.setMesh(null);\n\t\t\t\t\tmodifiedNodes.push(node);\n\t\t\t\t}\n\n\t\t\t\tif (!needsTranslation) batchTranslation.dispose();\n\t\t\t\tif (!needsRotation) batchRotation.dispose();\n\t\t\t\tif (!needsScale) batchScale.dispose();\n\n\t\t\t\tpruneUnusedNodes(modifiedNodes, logger);\n\n\t\t\t\tnumBatches++;\n\t\t\t\tnumInstances += nodes.length;\n\t\t\t}\n\t\t}\n\n\t\tif (numBatches > 0) {\n\t\t\tlogger.info(`${NAME}: Created ${numBatches} batches, with ${numInstances} total instances.`);\n\t\t} else {\n\t\t\tlogger.info(`${NAME}: No meshes with ≥${options.min} parent nodes were found.`);\n\t\t}\n\n\t\tif (batchExtension.listProperties().length === 0) {\n\t\t\tbatchExtension.dispose();\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\nfunction pruneUnusedNodes(nodes: Node[], logger: ILogger): void {\n\tlet node: Node | undefined;\n\tlet unusedNodes = 0;\n\twhile ((node = nodes.pop())) {\n\t\tif (\n\t\t\tnode.listChildren().length ||\n\t\t\tnode.getCamera() ||\n\t\t\tnode.getMesh() ||\n\t\t\tnode.getSkin() ||\n\t\t\tnode.listExtensions().length\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst nodeParent = node.getParent();\n\t\tif (nodeParent instanceof Node) {\n\t\t\tnodes.push(nodeParent);\n\t\t}\n\t\tnode.dispose();\n\t\tunusedNodes++;\n\t}\n\n\tlogger.debug(`${NAME}: Removed ${unusedNodes} unused nodes.`);\n}\n\nfunction createBatch(doc: Document, batchExtension: EXTMeshGPUInstancing, mesh: Mesh, count: number): InstancedMesh {\n\tconst buffer = mesh.listPrimitives()[0].getAttribute('POSITION')!.getBuffer();\n\n\tconst batchTranslation = doc\n\t\t.createAccessor()\n\t\t.setType('VEC3')\n\t\t.setArray(new Float32Array(3 * count))\n\t\t.setBuffer(buffer);\n\tconst batchRotation = doc\n\t\t.createAccessor()\n\t\t.setType('VEC4')\n\t\t.setArray(new Float32Array(4 * count))\n\t\t.setBuffer(buffer);\n\tconst batchScale = doc\n\t\t.createAccessor()\n\t\t.setType('VEC3')\n\t\t.setArray(new Float32Array(3 * count))\n\t\t.setBuffer(buffer);\n\n\treturn batchExtension\n\t\t.createInstancedMesh()\n\t\t.setAttribute('TRANSLATION', batchTranslation)\n\t\t.setAttribute('ROTATION', batchRotation)\n\t\t.setAttribute('SCALE', batchScale);\n}\n","import { Document, Primitive, ComponentTypeToTypedArray } from '@gltf-transform/core';\nimport { createIndices, createPrimGroupKey } from './utils';\n\ninterface JoinPrimitiveOptions {\n\tskipValidation?: boolean;\n}\n\nconst JOIN_PRIMITIVE_DEFAULTS: Required<JoinPrimitiveOptions> = {\n\tskipValidation: false,\n};\n\n/**\n * Given a list of compatible Mesh {@link Primitive Primitives}, returns new Primitive\n * containing their vertex data. Compatibility requires that all Primitives share the\n * same {@link Material Materials}, draw mode, and vertex attribute types. Primitives\n * using morph targets cannot currently be joined.\n *\n * Example:\n *\n * ```javascript\n * import { joinPrimitives } from '@gltf-transform/functions';\n *\n * // Succeeds if Primitives are compatible, or throws an error.\n * const result = joinPrimitives(mesh.listPrimitives());\n *\n * for (const prim of mesh.listPrimitives()) {\n * \tprim.dispose();\n * }\n *\n * mesh.addPrimitive(result);\n * ```\n */\nexport function joinPrimitives(prims: Primitive[], options: JoinPrimitiveOptions = {}): Primitive {\n\toptions = { ...JOIN_PRIMITIVE_DEFAULTS, ...options };\n\tconst templatePrim = prims[0]!;\n\tconst document = Document.fromGraph(templatePrim.getGraph())!;\n\n\t// (1) Validation.\n\tif (!options.skipValidation && new Set(prims.map(createPrimGroupKey)).size > 1) {\n\t\tthrow new Error(\n\t\t\t'' +\n\t\t\t\t'Requires ≥2 Primitives, sharing the same Material ' +\n\t\t\t\t'and Mode, with compatible vertex attributes and indices.'\n\t\t);\n\t}\n\n\tconst remapList = [] as Uint32Array[]; // remap[srcIndex] → dstIndex, by prim\n\tconst countList = [] as number[]; // vertex count, by prim\n\tconst indicesList = [] as (Uint32Array | Uint16Array)[]; // indices, by prim\n\n\tlet dstVertexCount = 0;\n\tlet dstIndicesCount = 0;\n\n\t// (2) Build remap lists.\n\tfor (const srcPrim of prims) {\n\t\tconst indices = _getOrCreateIndices(srcPrim);\n\t\tconst remap = [];\n\t\tlet count = 0;\n\t\tfor (let i = 0; i < indices.length; i++) {\n\t\t\tconst index = indices[i];\n\t\t\tif (remap[index] === undefined) {\n\t\t\t\tremap[index] = dstVertexCount++;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tdstIndicesCount++;\n\t\t}\n\t\tremapList.push(new Uint32Array(remap));\n\t\tcountList.push(count);\n\t\tindicesList.push(indices);\n\t}\n\n\t// (3) Allocate joined attributes.\n\tconst dstPrim = document.createPrimitive().setMode(templatePrim.getMode()).setMaterial(templatePrim.getMaterial());\n\tfor (const semantic of templatePrim.listSemantics()) {\n\t\tconst tplAttribute = templatePrim.getAttribute(semantic)!;\n\t\tconst AttributeArray = ComponentTypeToTypedArray[tplAttribute.getComponentType()];\n\t\tconst dstAttribute = document\n\t\t\t.createAccessor()\n\t\t\t.setType(tplAttribute.getType())\n\t\t\t.setBuffer(tplAttribute.getBuffer())\n\t\t\t.setNormalized(tplAttribute.getNormalized())\n\t\t\t.setArray(new AttributeArray(dstVertexCount * tplAttribute.getElementSize()));\n\t\tdstPrim.setAttribute(semantic, dstAttribute);\n\t}\n\n\t// (4) Allocate joined indices.\n\tconst dstIndicesArray = templatePrim.getIndices() ? createIndices(dstVertexCount) : null;\n\tconst dstIndices =\n\t\tdstIndicesArray &&\n\t\tdocument\n\t\t\t.createAccessor()\n\t\t\t.setBuffer(templatePrim.getIndices()!.getBuffer())\n\t\t\t.setArray(createIndices(dstIndicesCount, dstVertexCount));\n\tdstPrim.setIndices(dstIndices);\n\n\t// (5) Remap attributes into joined Primitive.\n\tlet dstNextIndex = 0;\n\tfor (let primIndex = 0; primIndex < remapList.length; primIndex++) {\n\t\tconst srcPrim = prims[primIndex];\n\t\tconst remap = remapList[primIndex];\n\t\tconst indicesArray = indicesList[primIndex];\n\n\t\tconst primStartIndex = dstNextIndex;\n\t\tlet primNextIndex = primStartIndex;\n\n\t\tfor (const semantic of dstPrim.listSemantics()) {\n\t\t\tconst srcAttribute = srcPrim.getAttribute(semantic)!;\n\t\t\tconst dstAttribute = dstPrim.getAttribute(semantic)!;\n\t\t\tconst el = [] as number[];\n\n\t\t\tprimNextIndex = primStartIndex;\n\t\t\tfor (let i = 0; i < indicesArray.length; i++) {\n\t\t\t\tconst index = indicesArray[i];\n\t\t\t\tsrcAttribute.getElement(index, el);\n\t\t\t\tdstAttribute.setElement(remap[index], el);\n\t\t\t\tif (dstIndices) {\n\t\t\t\t\tdstIndices.setScalar(primNextIndex++, remap[index]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdstNextIndex = primNextIndex;\n\t}\n\n\treturn dstPrim;\n}\n\nfunction _getOrCreateIndices(prim: Primitive): Uint16Array | Uint32Array {\n\tconst indices = prim.getIndices();\n\tif (indices) return indices.getArray() as Uint32Array | Uint16Array;\n\tconst position = prim.getAttribute('POSITION')!;\n\treturn createIndices(position.getCount());\n}\n","import {\n\tAnimationChannel,\n\tDocument,\n\tmat4,\n\tMesh,\n\tNode,\n\tPrimitive,\n\tPropertyType,\n\tScene,\n\tTransform,\n} from '@gltf-transform/core';\nimport { invert, multiply } from 'gl-matrix/mat4';\nimport { joinPrimitives } from './join-primitives';\nimport { prune } from './prune';\nimport { transformPrimitive } from './transform-primitive';\nimport { createPrimGroupKey, createTransform, formatLong, isUsed } from './utils';\n\nconst NAME = 'join';\n\nconst { ROOT, NODE, MESH, PRIMITIVE, ACCESSOR } = PropertyType;\n\n// prettier-ignore\nconst _matrix = [\n\t0, 0, 0, 0,\n\t0, 0, 0, 0,\n\t0, 0, 0, 0,\n\t0, 0, 0, 0,\n] as mat4;\n\n/** Options for the {@link join} function. */\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface JoinOptions {\n\t/**\n\t * Prevents joining distinct {@link Mesh Meshes} and {@link Node Nodes}.\n\t * Joins only Primitives found within the same parent Mesh. To preserve\n\t * only _named_ Nodes and Meshes, use\n\t * {@link JoinOptions.keepNamed keepNamed} instead. Default: false.\n\t */\n\tkeepMeshes: boolean;\n\t/**\n\t * Prevents joining _named_ {@link Mesh Meshes} and {@link Node Nodes}.\n\t * If {@link JoinOptions.keepMeshes keepMeshes} is enabled, keepNamed will\n\t * have no effect. Default: false.\n\t */\n\tkeepNamed: boolean;\n}\n\nexport const JOIN_DEFAULTS: Required<JoinOptions> = {\n\tkeepMeshes: false,\n\tkeepNamed: false,\n};\n\n/**\n * Joins compatible {@link Primitive Primitives} and reduces draw calls.\n * Primitives are eligible for joining if they are members of the same\n * {@link Mesh} or, optionally, attached to sibling {@link Node Nodes}\n * in the scene hierarchy. For best results, apply {@link dedup} and\n * {@link flatten} first to maximize the number of Primitives that\n * can be joined.\n *\n * NOTE: In a Scene that heavily reuses the same Mesh data, joining may\n * increase vertex count. Consider alternatives, like\n * {@link instance instancing} with {@link EXTMeshGPUInstancing}.\n *\n * Example:\n *\n * ```ts\n * import { PropertyType } from '@gltf-transform/core';\n * import { join, flatten, dedup } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \tdedup({ propertyTypes: [PropertyType.MATERIAL] }),\n * \tflatten(),\n * \tjoin({ keepNamed: false }),\n * );\n * ```\n */\nexport function join(_options: JoinOptions = JOIN_DEFAULTS): Transform {\n\tconst options = { ...JOIN_DEFAULTS, ..._options } as Required<JoinOptions>;\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst root = document.getRoot();\n\t\tconst logger = document.getLogger();\n\n\t\t// Join.\n\t\tfor (const scene of root.listScenes()) {\n\t\t\t_joinLevel(document, scene, options);\n\t\t\tscene.traverse((node) => _joinLevel(document, node, options));\n\t\t}\n\n\t\t// Clean up.\n\t\tawait document.transform(\n\t\t\tprune({\n\t\t\t\tpropertyTypes: [NODE, MESH, PRIMITIVE, ACCESSOR],\n\t\t\t\tkeepLeaves: false,\n\t\t\t\tkeepAttributes: true,\n\t\t\t})\n\t\t);\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\ninterface IJoinGroup {\n\tkey: string;\n\tprims: Primitive[];\n\tprimMeshes: Mesh[];\n\tprimNodes: Node[];\n\tdstNode: Node;\n\tdstMesh?: Mesh | undefined;\n}\n\nfunction _joinLevel(document: Document, parent: Node | Scene, options: Required<JoinOptions>) {\n\tconst logger = document.getLogger();\n\tconst groups = {} as Record<string, IJoinGroup>;\n\n\t// Scan for compatible Primitives.\n\tconst children = parent.listChildren();\n\tfor (let nodeIndex = 0; nodeIndex < children.length; nodeIndex++) {\n\t\tconst node = children[nodeIndex];\n\n\t\t// Skip animated nodes.\n\t\tconst isAnimated = node.listParents().some((p) => p instanceof AnimationChannel);\n\t\tif (isAnimated) continue;\n\n\t\t// Skip nodes without meshes.\n\t\tconst mesh = node.getMesh();\n\t\tif (!mesh) continue;\n\n\t\t// Skip nodes with instancing; unsupported.\n\t\tif (node.getExtension('EXT_mesh_gpu_instancing')) continue;\n\n\t\t// Skip nodes with skinning; unsupported.\n\t\tif (node.getSkin()) continue;\n\n\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t// Skip prims with morph targets; unsupported.\n\t\t\tif (prim.listTargets().length > 0) continue;\n\n\t\t\t// Skip prims with volumetric materials; unsupported.\n\t\t\tconst material = prim.getMaterial();\n\t\t\tif (material && material.getExtension('KHR_materials_volume')) continue;\n\n\t\t\tlet key = createPrimGroupKey(prim);\n\n\t\t\tconst isNamed = mesh.getName() || node.getName();\n\t\t\tif (options.keepMeshes || (options.keepNamed && isNamed)) {\n\t\t\t\tkey += `|${nodeIndex}`;\n\t\t\t}\n\n\t\t\tif (!(key in groups)) {\n\t\t\t\tgroups[key] = {\n\t\t\t\t\tprims: [] as Primitive[],\n\t\t\t\t\tprimMeshes: [] as Mesh[],\n\t\t\t\t\tprimNodes: [] as Node[],\n\t\t\t\t\tdstNode: node,\n\t\t\t\t\tdstMesh: undefined,\n\t\t\t\t} as IJoinGroup;\n\t\t\t}\n\n\t\t\tconst group = groups[key];\n\t\t\tgroup.prims.push(prim);\n\t\t\tgroup.primNodes.push(node);\n\t\t}\n\t}\n\n\t// Discard single-Primitive groups.\n\tconst joinGroups = Object.values(groups).filter(({ prims }) => prims.length > 1);\n\n\t// Unlink all affected Meshes at current level, before modifying Primitives.\n\tconst srcNodes = new Set<Node>(joinGroups.flatMap((group) => group.primNodes));\n\tfor (const node of srcNodes) {\n\t\tconst mesh = node.getMesh()!;\n\t\tconst isSharedMesh = mesh.listParents().some((parent) => {\n\t\t\treturn parent.propertyType !== ROOT && node !== parent;\n\t\t});\n\t\tif (isSharedMesh) {\n\t\t\tnode.setMesh(mesh.clone());\n\t\t}\n\t}\n\n\t// Update Meshes in groups.\n\tfor (const group of joinGroups) {\n\t\tconst { dstNode, primNodes } = group;\n\t\tgroup.dstMesh = dstNode.getMesh()!;\n\t\tgroup.primMeshes = primNodes.map((node) => node.getMesh()!);\n\t}\n\n\t// Join Primitives.\n\tfor (const group of joinGroups) {\n\t\tconst { prims, primNodes, primMeshes, dstNode, dstMesh } = group as Required<IJoinGroup>;\n\t\tconst dstMatrix = dstNode.getMatrix();\n\n\t\tfor (let i = 0; i < prims.length; i++) {\n\t\t\tconst primNode = primNodes[i];\n\t\t\tconst primMesh = primMeshes[i];\n\n\t\t\tlet prim = prims[i];\n\t\t\tprimMesh.removePrimitive(prim);\n\n\t\t\t// Primitives may be reused directly, or their attributes may be\n\t\t\t// used in another Primitive with a different Material.\n\t\t\tif (isUsed(prim) || hasSharedAttributes(prim)) {\n\t\t\t\tprim = prims[i] = _deepClonePrimitive(prims[i]);\n\t\t\t}\n\n\t\t\t// Transform Primitive into new local coordinate space.\n\t\t\tif (primNode !== dstNode) {\n\t\t\t\tmultiply(_matrix, invert(_matrix, dstMatrix), primNode.getMatrix());\n\t\t\t\ttransformPrimitive(prim, _matrix);\n\t\t\t}\n\t\t}\n\n\t\tconst dstPrim = joinPrimitives(prims);\n\t\tconst dstVertexCount = dstPrim.listAttributes()[0].getCount();\n\t\tdstMesh.addPrimitive(dstPrim);\n\n\t\tlogger.debug(\n\t\t\t`${NAME}: Joined Primitives (${prims.length}) containing ` +\n\t\t\t\t`${formatLong(dstVertexCount)} vertices under Node \"${dstNode.getName()}\".`\n\t\t);\n\t}\n}\n\nfunction _deepClonePrimitive(src: Primitive): Primitive {\n\tconst dst = src.clone();\n\tfor (const semantic of dst.listSemantics()) {\n\t\tdst.setAttribute(semantic, dst.getAttribute(semantic)!.clone());\n\t}\n\tconst indices = dst.getIndices();\n\tif (indices) dst.setIndices(indices.clone());\n\treturn dst;\n}\n\nfunction hasSharedAttributes(prim: Primitive): boolean {\n\tfor (const attribute of prim.listAttributes()) {\n\t\tfor (const parent of attribute.listParents()) {\n\t\t\tif (parent !== prim && parent.propertyType !== ROOT) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n","import { Accessor, Document, GLTF, Primitive, PropertyType, Transform } from '@gltf-transform/core';\nimport { prune } from './prune';\nimport { createTransform, deepListAttributes, remapAttribute, SetMap } from './utils';\nimport type { MeshoptEncoder } from 'meshoptimizer';\n\nconst NAME = 'reorder';\n\n/** Options for the {@link reorder} function. */\nexport interface ReorderOptions {\n\t/** MeshoptEncoder instance. */\n\tencoder: unknown;\n\t/**\n\t * Whether the order should be optimal for transmission size (recommended for Web)\n\t * or for GPU rendering performance. Default is 'size'.\n\t */\n\ttarget?: 'size' | 'performance';\n}\n\nconst REORDER_DEFAULTS: Required<Omit<ReorderOptions, 'encoder'>> = {\n\ttarget: 'size',\n};\n\n/**\n * Optimizes {@link Mesh} {@link Primitive Primitives} for locality of reference. Choose whether\n * the order should be optimal for transmission size (recommended for Web) or for GPU rendering\n * performance. Requires a MeshoptEncoder instance from the Meshoptimizer library.\n *\n * Example:\n *\n * ```ts\n * import { MeshoptEncoder } from 'meshoptimizer';\n * import { reorder } from '@gltf-transform/functions';\n *\n * await MeshoptEncoder.ready;\n *\n * await document.transform(\n * \treorder({encoder: MeshoptEncoder})\n * );\n * ```\n */\nexport function reorder(_options: ReorderOptions): Transform {\n\tconst options = { ...REORDER_DEFAULTS, ..._options } as Required<ReorderOptions>;\n\tconst encoder = options.encoder as typeof MeshoptEncoder | undefined;\n\n\tif (!encoder) {\n\t\tthrow new Error(`${NAME}: encoder dependency required — install \"meshoptimizer\".`);\n\t}\n\n\treturn createTransform(NAME, async (doc: Document): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\n\t\tawait encoder.ready;\n\n\t\tconst plan = createLayoutPlan(doc);\n\n\t\tfor (const srcIndices of plan.indicesToAttributes.keys()) {\n\t\t\tconst dstIndices = srcIndices.clone();\n\t\t\tlet indicesArray = dstIndices.getArray()!.slice();\n\t\t\tif (!(indicesArray instanceof Uint32Array)) {\n\t\t\t\tindicesArray = new Uint32Array(indicesArray);\n\t\t\t}\n\n\t\t\t// Compute optimal order.\n\t\t\tconst [remap, unique] = encoder.reorderMesh(\n\t\t\t\tindicesArray,\n\t\t\t\tplan.indicesToMode.get(srcIndices) === Primitive.Mode.TRIANGLES,\n\t\t\t\toptions.target === 'size'\n\t\t\t);\n\n\t\t\tdstIndices.setArray(unique <= 65534 ? new Uint16Array(indicesArray) : indicesArray);\n\n\t\t\t// Update affected primitives.\n\t\t\tfor (const srcAttribute of plan.indicesToAttributes.get(srcIndices)) {\n\t\t\t\tconst dstAttribute = srcAttribute.clone();\n\t\t\t\tremapAttribute(dstAttribute, remap, unique);\n\t\t\t\tfor (const prim of plan.attributesToPrimitives.get(srcAttribute)) {\n\t\t\t\t\tif (prim.getIndices() === srcIndices) {\n\t\t\t\t\t\tprim.swap(srcIndices, dstIndices);\n\t\t\t\t\t}\n\t\t\t\t\tif (prim.getIndices() === dstIndices) {\n\t\t\t\t\t\tprim.swap(srcAttribute, dstAttribute);\n\t\t\t\t\t\tfor (const target of prim.listTargets()) {\n\t\t\t\t\t\t\ttarget.swap(srcAttribute, dstAttribute);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Clean up any attributes left unused by earlier cloning.\n\t\tawait doc.transform(prune({ propertyTypes: [PropertyType.ACCESSOR] }));\n\n\t\tif (!plan.indicesToAttributes.size) {\n\t\t\tlogger.warn(`${NAME}: No qualifying primitives found; may need to weld first.`);\n\t\t} else {\n\t\t\tlogger.debug(`${NAME}: Complete.`);\n\t\t}\n\t});\n}\n\ninterface LayoutPlan {\n\tindicesToMode: Map<Accessor, GLTF.MeshPrimitiveMode>;\n\tindicesToAttributes: SetMap<Accessor, Accessor>;\n\tattributesToPrimitives: SetMap<Accessor, Primitive>;\n}\n\n/**\n * Constructs a plan for processing vertex streams, based on unique\n * index:attribute[] groups. Where different indices are used with the same\n * attributes, we'll end up splitting the primitives to not share attributes,\n * which appears to be consistent with the Meshopt implementation.\n */\nexport function createLayoutPlan(document: Document): LayoutPlan {\n\tconst indicesToAttributes = new SetMap<Accessor, Accessor>();\n\tconst indicesToMode = new Map<Accessor, GLTF.MeshPrimitiveMode>();\n\tconst attributesToPrimitives = new SetMap<Accessor, Primitive>();\n\n\tfor (const mesh of document.getRoot().listMeshes()) {\n\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\tconst indices = prim.getIndices();\n\t\t\tif (!indices) continue;\n\n\t\t\tindicesToMode.set(indices, prim.getMode());\n\n\t\t\tfor (const attribute of deepListAttributes(prim)) {\n\t\t\t\tindicesToAttributes.add(indices, attribute);\n\t\t\t\tattributesToPrimitives.add(attribute, prim);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { indicesToAttributes, indicesToMode, attributesToPrimitives };\n}\n","import { Accessor, GLTF, MathUtils, Primitive, PrimitiveTarget, TypedArray, vec4 } from '@gltf-transform/core';\n\n/**\n * Sorts skinning weights from high to low, for each vertex of the input\n * {@link Primitive} or {@link PrimitiveTarget}, and normalizes the weights.\n * Optionally, uses the given 'limit' to remove least-significant joint\n * influences such that no vertex has more than 'limit' influences.\n *\n * Most realtime engines support a limited number of joint influences per vertex,\n * often 4 or 8. Sorting and removing the additional influences can reduce file\n * size and improve compatibility.\n *\n * Example:\n *\n * ```javascript\n * import { sortPrimitiveWeights } from '@gltf-transform/functions';\n *\n * const limit = 4;\n * for (const mesh of document.getRoot().listMeshes()) {\n * \tfor (const prim of mesh.listPrimitives()) {\n * \t\tsortPrimitiveWeights(prim, limit);\n * \t}\n * }\n * ```\n *\n * @param prim Input, to be modified in place.\n * @param limit Maximum number of joint influences per vertex. Must be a multiple of four.\n */\nexport function sortPrimitiveWeights(prim: Primitive | PrimitiveTarget, limit = Infinity) {\n\tif ((Number.isFinite(limit) && limit % 4) || limit <= 0) {\n\t\tthrow new Error(`Limit must be positive multiple of four.`);\n\t}\n\n\tconst vertexCount = prim.getAttribute('POSITION')!.getCount();\n\tconst setCount = prim.listSemantics().filter((name) => name.startsWith('WEIGHTS_')).length;\n\n\t// (1) Sort.\n\n\tconst indices = new Uint16Array(setCount * 4);\n\tconst srcWeights = new Float32Array(setCount * 4);\n\tconst dstWeights = new Float32Array(setCount * 4);\n\tconst srcJoints = new Uint32Array(setCount * 4);\n\tconst dstJoints = new Uint32Array(setCount * 4);\n\n\tfor (let i = 0; i < vertexCount; i++) {\n\t\tgetVertexArray(prim, i, 'WEIGHTS', srcWeights);\n\t\tgetVertexArray(prim, i, 'JOINTS', srcJoints);\n\n\t\t// Sort indices to create a lookup table, indices[dstIndex] → srcIndex,\n\t\t// indexed into the weights and joints arrays.\n\t\tfor (let j = 0; j < setCount * 4; j++) indices[j] = j;\n\t\tindices.sort((a, b) => (srcWeights[a] > srcWeights[b] ? -1 : 1));\n\n\t\t// Sort weights and joints.\n\t\tfor (let j = 0; j < indices.length; j++) {\n\t\t\tdstWeights[j] = srcWeights[indices[j]];\n\t\t\tdstJoints[j] = srcJoints[indices[j]];\n\t\t}\n\n\t\tsetVertexArray(prim, i, 'WEIGHTS', dstWeights);\n\t\tsetVertexArray(prim, i, 'JOINTS', dstJoints);\n\t}\n\n\t// (2) Limit.\n\tfor (let i = setCount; i * 4 > limit; i--) {\n\t\tconst weights = prim.getAttribute(`WEIGHTS_${i - 1}`)!;\n\t\tconst joints = prim.getAttribute(`JOINTS_${i - 1}`)!;\n\t\tprim.setAttribute(`WEIGHTS_${i - 1}`, null);\n\t\tprim.setAttribute(`JOINTS_${i - 1}`, null);\n\t\tif (weights.listParents().length === 1) weights.dispose();\n\t\tif (joints.listParents().length === 1) joints.dispose();\n\t}\n\n\t// (3) Normalize.\n\tnormalizePrimitiveWeights(prim);\n}\n\n// Utilities.\n\ntype PrimLike = Primitive | PrimitiveTarget;\n\nfunction normalizePrimitiveWeights(prim: PrimLike): void {\n\t// Would prefer to warn if unsafe, but no logger accessible in this scope.\n\tif (!isNormalizeSafe(prim)) return;\n\n\tconst vertexCount = prim.getAttribute('POSITION')!.getCount();\n\tconst setCount = prim.listSemantics().filter((name) => name.startsWith('WEIGHTS_')).length;\n\n\tconst templateAttribute = prim.getAttribute('WEIGHTS_0')!;\n\tconst templateArray = templateAttribute.getArray()!;\n\tconst componentType = templateAttribute.getComponentType();\n\tconst normalized = templateAttribute.getNormalized();\n\tconst normalizedComponentType = normalized ? componentType : undefined;\n\tconst delta = normalized ? MathUtils.decodeNormalizedInt(1, componentType) : Number.EPSILON;\n\tconst joints = new Uint32Array(setCount * 4).fill(0);\n\tconst weights = templateArray.slice(0, setCount * 4).fill(0);\n\n\tfor (let i = 0; i < vertexCount; i++) {\n\t\tgetVertexArray(prim, i, 'JOINTS', joints);\n\t\tgetVertexArray(prim, i, 'WEIGHTS', weights, normalizedComponentType);\n\n\t\tlet weightsSum = sum(weights, normalizedComponentType);\n\t\tif (weightsSum === 0) continue;\n\n\t\t// (1) If sum of weights not within δ of 1, renormalize all weights.\n\t\tif (Math.abs(1 - weightsSum) > delta) {\n\t\t\tfor (let j = 0; j < weights.length; j++) {\n\t\t\t\tif (normalized) {\n\t\t\t\t\tconst intValue = MathUtils.encodeNormalizedInt(weights[j] / weightsSum, componentType);\n\t\t\t\t\tweights[j] = MathUtils.decodeNormalizedInt(intValue, componentType);\n\t\t\t\t} else {\n\t\t\t\t\tweights[j] /= weightsSum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tweightsSum = sum(weights, normalizedComponentType);\n\n\t\t// (2) Sum of normalized weights may still be off by δ. Compensate\n\t\t// in least-significant weight.\n\t\tif (normalized && weightsSum !== 1) {\n\t\t\tfor (let j = weights.length - 1; j >= 0; j--) {\n\t\t\t\tif (weights[j] > 0) {\n\t\t\t\t\tweights[j] += MathUtils.encodeNormalizedInt(1 - weightsSum, componentType);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// (3) Remove joint indices whose weights have fallen to zero.\n\t\tfor (let j = weights.length - 1; j >= 0; j--) {\n\t\t\tif (weights[j] === 0) {\n\t\t\t\tjoints[j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tsetVertexArray(prim, i, 'JOINTS', joints);\n\t\tsetVertexArray(prim, i, 'WEIGHTS', weights, normalizedComponentType);\n\t}\n}\n\n/** Lists all values of a multi-set vertex attribute (WEIGHTS_#, ...) for given vertex. */\nfunction getVertexArray(\n\tprim: PrimLike,\n\tvertexIndex: number,\n\tprefix: string,\n\ttarget: TypedArray,\n\tnormalizedComponentType?: GLTF.AccessorComponentType\n): TypedArray {\n\tlet weights: Accessor | null;\n\tconst el = [0, 0, 0, 0] as vec4;\n\tfor (let i = 0; (weights = prim.getAttribute(`${prefix}_${i}`)); i++) {\n\t\tweights.getElement(vertexIndex, el);\n\t\tfor (let j = 0; j < 4; j++) {\n\t\t\tif (normalizedComponentType) {\n\t\t\t\ttarget[i * 4 + j] = MathUtils.encodeNormalizedInt(el[j], normalizedComponentType);\n\t\t\t} else {\n\t\t\t\ttarget[i * 4 + j] = el[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn target;\n}\n\n/** Sets all values of a multi-set vertex attribute (WEIGHTS_#, ...) for given vertex. */\nfunction setVertexArray(\n\tprim: PrimLike,\n\tvertexIndex: number,\n\tprefix: string,\n\tvalues: TypedArray,\n\tnormalizedComponentType?: GLTF.AccessorComponentType\n): void {\n\tlet weights: Accessor | null;\n\tconst el = [0, 0, 0, 0] as vec4;\n\tfor (let i = 0; (weights = prim.getAttribute(`${prefix}_${i}`)); i++) {\n\t\tfor (let j = 0; j < 4; j++) {\n\t\t\tif (normalizedComponentType) {\n\t\t\t\tel[j] = MathUtils.decodeNormalizedInt(values[i * 4 + j], normalizedComponentType);\n\t\t\t} else {\n\t\t\t\tel[j] = values[i * 4 + j];\n\t\t\t}\n\t\t}\n\t\tweights.setElement(vertexIndex, el);\n\t}\n}\n\n/** Sum an array of numbers. */\nfunction sum(values: TypedArray, normalizedComponentType?: GLTF.AccessorComponentType): number {\n\tlet sum = 0;\n\tfor (let i = 0; i < values.length; i++) {\n\t\tif (normalizedComponentType) {\n\t\t\tsum += MathUtils.decodeNormalizedInt(values[i], normalizedComponentType);\n\t\t} else {\n\t\t\tsum += values[i];\n\t\t}\n\t}\n\treturn sum;\n}\n\n/** Returns true if attribute normalization is supported for this primitive. */\nfunction isNormalizeSafe(prim: PrimLike): boolean {\n\tconst attributes = prim\n\t\t.listSemantics()\n\t\t.filter((name) => name.startsWith('WEIGHTS_'))\n\t\t.map((name) => prim.getAttribute(name)!);\n\tconst normList = attributes.map((a) => a.getNormalized());\n\tconst typeList = attributes.map((a) => a.getComponentType());\n\treturn new Set(normList).size === 1 && new Set(typeList).size === 1;\n}\n","import {\n\tAccessor,\n\tAnimationChannel,\n\tbbox,\n\tDocument,\n\tILogger,\n\tmat4,\n\tMesh,\n\tNode,\n\tPrimitive,\n\tPrimitiveTarget,\n\tPropertyType,\n\tSkin,\n\tTransform,\n\tvec2,\n\tvec3,\n\tvec4,\n} from '@gltf-transform/core';\nimport { dedup } from './dedup';\nimport { fromRotationTranslationScale, fromScaling, invert, multiply as multiplyMat4 } from 'gl-matrix/mat4';\nimport { max, min, scale, transformMat4 } from 'gl-matrix/vec3';\nimport { KHRMeshQuantization } from '@gltf-transform/extensions';\nimport type { Volume } from '@gltf-transform/extensions';\nimport { prune } from './prune';\nimport { createTransform } from './utils';\nimport { sortPrimitiveWeights } from './sort-primitive-weights';\n\nconst NAME = 'quantize';\n\ntype TypedArrayConstructor =\n\t| Int8ArrayConstructor\n\t| Int16ArrayConstructor\n\t| Uint8ArrayConstructor\n\t| Uint16ArrayConstructor;\nconst SIGNED_INT = [Int8Array, Int16Array, Int32Array] as TypedArrayConstructor[];\n\nconst { TRANSLATION, ROTATION, SCALE, WEIGHTS } = AnimationChannel.TargetPath;\nconst TRS_CHANNELS = [TRANSLATION, ROTATION, SCALE];\n\n/** Options for the {@link quantize} function. */\nexport interface QuantizeOptions {\n\t/** Pattern (regex) used to filter vertex attribute semantics for quantization. Default: all. */\n\tpattern?: RegExp;\n\t/** Bounds for quantization grid. */\n\tquantizationVolume?: 'mesh' | 'scene';\n\t/** Quantization bits for `POSITION` attributes. */\n\tquantizePosition?: number;\n\t/** Quantization bits for `NORMAL` attributes. */\n\tquantizeNormal?: number;\n\t/** Quantization bits for `TEXCOORD_*` attributes. */\n\tquantizeTexcoord?: number;\n\t/** Quantization bits for `COLOR_*` attributes. */\n\tquantizeColor?: number;\n\t/** Quantization bits for `WEIGHT_*` attributes. */\n\tquantizeWeight?: number;\n\t/** Quantization bits for application-specific (`_*`) attributes. */\n\tquantizeGeneric?: number;\n\t/** Normalize weight attributes. */\n\tnormalizeWeights?: boolean;\n}\n\nexport const QUANTIZE_DEFAULTS: Required<QuantizeOptions> = {\n\tpattern: /.*/,\n\tquantizationVolume: 'mesh',\n\tquantizePosition: 14,\n\tquantizeNormal: 10,\n\tquantizeTexcoord: 12,\n\tquantizeColor: 8,\n\tquantizeWeight: 8,\n\tquantizeGeneric: 12,\n\tnormalizeWeights: true,\n};\n\n/**\n * References:\n * - https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n * - http://www.aclockworkberry.com/normal-unpacking-quantization-errors/\n * - https://www.mathworks.com/help/dsp/ref/uniformencoder.html\n * - https://oroboro.com/compressed-unit-vectors/\n */\n\n/**\n * Quantizes vertex attributes with `KHR_mesh_quantization`, reducing the size and memory footprint\n * of the file.\n */\nconst quantize = (_options: QuantizeOptions = QUANTIZE_DEFAULTS): Transform => {\n\tconst options = { ...QUANTIZE_DEFAULTS, ..._options } as Required<QuantizeOptions>;\n\n\treturn createTransform(NAME, async (doc: Document): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\n\t\tdoc.createExtension(KHRMeshQuantization).setRequired(true);\n\n\t\t// Compute vertex position quantization volume.\n\t\tlet nodeTransform: VectorTransform<vec3> | undefined = undefined;\n\t\tif (options.quantizationVolume === 'scene') {\n\t\t\tnodeTransform = getNodeTransform(expandBounds(root.listMeshes().map(getPositionQuantizationVolume)));\n\t\t}\n\n\t\t// Quantize mesh primitives.\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tif (options.quantizationVolume === 'mesh') {\n\t\t\t\tnodeTransform = getNodeTransform(getPositionQuantizationVolume(mesh));\n\t\t\t}\n\n\t\t\tif (nodeTransform && options.pattern.test('POSITION')) {\n\t\t\t\ttransformMeshParents(doc, mesh, nodeTransform);\n\t\t\t\ttransformMeshMaterials(mesh, 1 / nodeTransform.scale);\n\t\t\t}\n\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tquantizePrimitive(doc, prim, nodeTransform!, options);\n\t\t\t\tfor (const target of prim.listTargets()) {\n\t\t\t\t\tquantizePrimitive(doc, target, nodeTransform!, options);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tawait doc.transform(\n\t\t\tprune({ propertyTypes: [PropertyType.ACCESSOR, PropertyType.SKIN, PropertyType.MATERIAL] }),\n\t\t\tdedup({ propertyTypes: [PropertyType.ACCESSOR, PropertyType.MATERIAL] })\n\t\t);\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n};\n\nfunction quantizePrimitive(\n\tdoc: Document,\n\tprim: Primitive | PrimitiveTarget,\n\tnodeTransform: VectorTransform<vec3>,\n\toptions: Required<QuantizeOptions>\n): void {\n\tconst logger = doc.getLogger();\n\n\tfor (const semantic of prim.listSemantics()) {\n\t\tif (!options.pattern.test(semantic)) continue;\n\n\t\tconst srcAttribute = prim.getAttribute(semantic)!;\n\t\tconst { bits, ctor } = getQuantizationSettings(semantic, srcAttribute, logger, options);\n\n\t\tif (!ctor) continue;\n\t\tif (bits < 8 || bits > 16) throw new Error(`${NAME}: Requires bits = 8–16.`);\n\t\tif (srcAttribute.getComponentSize() <= bits / 8) continue;\n\n\t\tconst dstAttribute = srcAttribute.clone();\n\n\t\t// Remap position data.\n\t\tif (semantic === 'POSITION') {\n\t\t\tconst scale = nodeTransform.scale;\n\t\t\tconst transform: mat4 = [] as unknown as mat4;\n\t\t\t// Morph targets are relative offsets, don't translate them.\n\t\t\tprim instanceof Primitive\n\t\t\t\t? invert(transform, fromTransform(nodeTransform))\n\t\t\t\t: fromScaling(transform, [1 / scale, 1 / scale, 1 / scale]);\n\t\t\tfor (let i = 0, el: vec3 = [0, 0, 0], il = dstAttribute.getCount(); i < il; i++) {\n\t\t\t\tdstAttribute.getElement(i, el);\n\t\t\t\tdstAttribute.setElement(i, transformMat4(el, el, transform) as vec3);\n\t\t\t}\n\t\t}\n\n\t\t// Quantize the vertex attribute.\n\t\tquantizeAttribute(dstAttribute, ctor, bits);\n\t\tprim.swap(srcAttribute, dstAttribute);\n\t}\n\n\t// Normalize skinning weights.\n\tif (options.normalizeWeights && prim.getAttribute('WEIGHTS_0')) {\n\t\tsortPrimitiveWeights(prim, Infinity);\n\t}\n\n\tif (\n\t\tprim instanceof Primitive &&\n\t\tprim.getIndices() &&\n\t\tprim.listAttributes().length &&\n\t\tprim.listAttributes()[0]!.getCount() < 65535\n\t) {\n\t\tconst indices = prim.getIndices()!;\n\t\tindices.setArray(new Uint16Array(indices.getArray()!));\n\t}\n}\n\n/** Computes node quantization transforms in local space. */\nfunction getNodeTransform(volume: bbox): VectorTransform<vec3> {\n\tconst { min, max } = volume;\n\n\t// Scaling factor transforms [-1,1] box to the mesh AABB in local space.\n\t// See: https://github.com/donmccurdy/glTF-Transform/issues/328\n\tconst scale = Math.max(\n\t\t(max[0] - min[0]) / 2, // Divide because interval [-1,1] has length 2.\n\t\t(max[1] - min[1]) / 2,\n\t\t(max[2] - min[2]) / 2\n\t);\n\n\t// Original center of the mesh, in local space.\n\tconst offset: vec3 = [\n\t\tmin[0] + (max[0] - min[0]) / 2,\n\t\tmin[1] + (max[1] - min[1]) / 2,\n\t\tmin[2] + (max[2] - min[2]) / 2,\n\t];\n\n\treturn { offset, scale };\n}\n\n/** Applies corrective scale and offset to nodes referencing a quantized Mesh. */\nfunction transformMeshParents(doc: Document, mesh: Mesh, nodeTransform: VectorTransform<vec3>): void {\n\tconst transformMatrix = fromTransform(nodeTransform);\n\tfor (const parent of mesh.listParents()) {\n\t\tif (!(parent instanceof Node)) continue;\n\n\t\tconst animChannels = parent.listParents().filter((p) => p instanceof AnimationChannel) as AnimationChannel[];\n\t\tconst isAnimated = animChannels.some((channel) => TRS_CHANNELS.includes(channel.getTargetPath()!));\n\t\tconst isParentNode = parent.listChildren().length > 0;\n\n\t\tif (parent.getSkin()) {\n\t\t\tparent.setSkin(transformSkin(parent.getSkin()!, nodeTransform));\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet targetNode: Node;\n\t\tif (isParentNode || isAnimated) {\n\t\t\ttargetNode = doc.createNode('').setMesh(mesh);\n\t\t\tparent.addChild(targetNode).setMesh(null);\n\t\t\tanimChannels\n\t\t\t\t.filter((channel) => channel.getTargetPath() === WEIGHTS)\n\t\t\t\t.forEach((channel) => channel.setTargetNode(targetNode));\n\t\t} else {\n\t\t\ttargetNode = parent;\n\t\t}\n\n\t\tconst nodeMatrix = targetNode.getMatrix();\n\t\tmultiplyMat4(nodeMatrix, nodeMatrix, transformMatrix);\n\t\ttargetNode.setMatrix(nodeMatrix);\n\t}\n}\n\n/** Applies corrective scale and offset to skin IBMs. */\nfunction transformSkin(skin: Skin, nodeTransform: VectorTransform<vec3>): Skin {\n\tskin = skin.clone();\n\tconst transformMatrix = fromTransform(nodeTransform);\n\tconst inverseBindMatrices = skin.getInverseBindMatrices()!.clone();\n\tconst ibm = [] as unknown as mat4;\n\tfor (let i = 0, count = inverseBindMatrices.getCount(); i < count; i++) {\n\t\tinverseBindMatrices.getElement(i, ibm);\n\t\tmultiplyMat4(ibm, ibm, transformMatrix);\n\t\tinverseBindMatrices.setElement(i, ibm);\n\t}\n\treturn skin.setInverseBindMatrices(inverseBindMatrices);\n}\n\n/** Applies corrective scale to volumetric materials, which give thickness in local units. */\nfunction transformMeshMaterials(mesh: Mesh, scale: number) {\n\tfor (const prim of mesh.listPrimitives()) {\n\t\tlet material = prim.getMaterial();\n\t\tif (!material) continue;\n\n\t\tlet volume = material.getExtension<Volume>('KHR_materials_volume');\n\t\tif (!volume || volume.getThicknessFactor() <= 0) continue;\n\n\t\t// prune()+dedup() will clean this up later.\n\t\tvolume = volume.clone().setThicknessFactor(volume.getThicknessFactor() * scale);\n\t\tmaterial = material.clone().setExtension('KHR_materials_volume', volume);\n\t\tprim.setMaterial(material);\n\t}\n}\n\n/**\n * Quantizes an attribute to the given parameters.\n *\n * Uniformly remap 32-bit floats to reduced-precision 8- or 16-bit integers, so\n * that there are only 2^N unique values, for N within [8, 16].\n *\n * See: https://github.com/donmccurdy/glTF-Transform/issues/208\n */\nfunction quantizeAttribute(attribute: Accessor, ctor: TypedArrayConstructor, bits: number): void {\n\tconst dstArray = new ctor(attribute.getArray()!.length);\n\n\tconst signBits = SIGNED_INT.includes(ctor) ? 1 : 0;\n\tconst quantBits = bits - signBits;\n\tconst storageBits = ctor.BYTES_PER_ELEMENT * 8 - signBits;\n\n\tconst scale = Math.pow(2, quantBits) - 1;\n\tconst lo = storageBits - quantBits;\n\tconst hi = 2 * quantBits - storageBits;\n\n\tfor (let i = 0, di = 0, el: number[] = []; i < attribute.getCount(); i++) {\n\t\tattribute.getElement(i, el);\n\t\tfor (let j = 0; j < el.length; j++) {\n\t\t\t// Map [0.0 ... 1.0] to [0 ... scale].\n\t\t\tlet value = Math.round(Math.abs(el[j]) * scale);\n\n\t\t\t// Replicate msb to missing lsb.\n\t\t\tvalue = (value << lo) | (value >> hi);\n\n\t\t\t// Restore sign.\n\t\t\tdstArray[di++] = value * Math.sign(el[j]);\n\t\t}\n\t}\n\n\t// TODO(feat): Support sparse accessors, https://github.com/donmccurdy/glTF-Transform/issues/795\n\tattribute.setArray(dstArray).setNormalized(true).setSparse(false);\n}\n\nfunction getQuantizationSettings(\n\tsemantic: string,\n\tattribute: Accessor,\n\tlogger: ILogger,\n\toptions: Required<QuantizeOptions>\n): { bits: number; ctor?: TypedArrayConstructor } {\n\tconst min = attribute.getMinNormalized([]);\n\tconst max = attribute.getMaxNormalized([]);\n\n\tlet bits: number;\n\tlet ctor: TypedArrayConstructor;\n\n\tif (semantic === 'POSITION') {\n\t\tbits = options.quantizePosition;\n\t\tctor = bits <= 8 ? Int8Array : Int16Array;\n\t} else if (semantic === 'NORMAL' || semantic === 'TANGENT') {\n\t\tbits = options.quantizeNormal;\n\t\tctor = bits <= 8 ? Int8Array : Int16Array;\n\t} else if (semantic.startsWith('COLOR_')) {\n\t\tbits = options.quantizeColor;\n\t\tctor = bits <= 8 ? Uint8Array : Uint16Array;\n\t} else if (semantic.startsWith('TEXCOORD_')) {\n\t\tif (min.some((v) => v < 0) || max.some((v) => v > 1)) {\n\t\t\tlogger.warn(`${NAME}: Skipping ${semantic}; out of [0,1] range.`);\n\t\t\treturn { bits: -1 };\n\t\t}\n\t\tbits = options.quantizeTexcoord;\n\t\tctor = bits <= 8 ? Uint8Array : Uint16Array;\n\t} else if (semantic.startsWith('JOINTS_')) {\n\t\tbits = Math.max(...attribute.getMax([])) <= 255 ? 8 : 16;\n\t\tctor = bits <= 8 ? Uint8Array : Uint16Array;\n\t\tif (attribute.getComponentSize() > bits / 8) {\n\t\t\tattribute.setArray(new ctor(attribute.getArray()!));\n\t\t}\n\t\treturn { bits: -1 };\n\t} else if (semantic.startsWith('WEIGHTS_')) {\n\t\tif (min.some((v) => v < 0) || max.some((v) => v > 1)) {\n\t\t\tlogger.warn(`${NAME}: Skipping ${semantic}; out of [0,1] range.`);\n\t\t\treturn { bits: -1 };\n\t\t}\n\t\tbits = options.quantizeWeight;\n\t\tctor = bits <= 8 ? Uint8Array : Uint16Array;\n\t} else if (semantic.startsWith('_')) {\n\t\tif (min.some((v) => v < -1) || max.some((v) => v > 1)) {\n\t\t\tlogger.warn(`${NAME}: Skipping ${semantic}; out of [-1,1] range.`);\n\t\t\treturn { bits: -1 };\n\t\t}\n\t\tbits = options.quantizeGeneric;\n\t\tctor = min.some((v) => v < 0)\n\t\t\t? (ctor = bits <= 8 ? Int8Array : Int16Array)\n\t\t\t: (ctor = bits <= 8 ? Uint8Array : Uint16Array);\n\t} else {\n\t\tthrow new Error(`${NAME}: Unexpected semantic, \"${semantic}\".`);\n\t}\n\n\treturn { bits, ctor };\n}\n\nfunction getPositionQuantizationVolume(mesh: Mesh): bbox {\n\tconst positions: Accessor[] = [];\n\tconst relativePositions: Accessor[] = [];\n\tfor (const prim of mesh.listPrimitives()) {\n\t\tconst attribute = prim.getAttribute('POSITION');\n\t\tif (attribute) positions.push(attribute);\n\t\tfor (const target of prim.listTargets()) {\n\t\t\tconst attribute = target.getAttribute('POSITION');\n\t\t\tif (attribute) relativePositions.push(attribute);\n\t\t}\n\t}\n\n\tif (positions.length === 0) {\n\t\tthrow new Error(`${NAME}: Missing \"POSITION\" attribute.`);\n\t}\n\n\tconst bbox = flatBounds<vec3>(positions, 3);\n\n\t// Morph target quantization volume is computed differently. First, ensure that the origin\n\t// <0, 0, 0> is in the quantization volume. Because we can't offset target positions (they're\n\t// relative deltas), default remapping will only map to a [-2, 2] AABB. Double the bounding box\n\t// to ensure scaling puts them within a [-1, 1] AABB instead.\n\tif (relativePositions.length > 0) {\n\t\tconst { min: relMin, max: relMax } = flatBounds<vec3>(relativePositions, 3);\n\t\tmin(bbox.min, bbox.min, min(relMin, scale(relMin, relMin, 2), [0, 0, 0]));\n\t\tmax(bbox.max, bbox.max, max(relMax, scale(relMax, relMax, 2), [0, 0, 0]));\n\t}\n\n\treturn bbox;\n}\n\n/** Computes total min and max of all Accessors in a list. */\nfunction flatBounds<T = vec2 | vec3>(accessors: Accessor[], elementSize: number): { min: T; max: T } {\n\tconst min: number[] = new Array(elementSize).fill(Infinity);\n\tconst max: number[] = new Array(elementSize).fill(-Infinity);\n\n\tconst tmpMin: number[] = [];\n\tconst tmpMax: number[] = [];\n\n\tfor (const accessor of accessors) {\n\t\taccessor.getMinNormalized(tmpMin);\n\t\taccessor.getMaxNormalized(tmpMax);\n\t\tfor (let i = 0; i < elementSize; i++) {\n\t\t\tmin[i] = Math.min(min[i], tmpMin[i]);\n\t\t\tmax[i] = Math.max(max[i], tmpMax[i]);\n\t\t}\n\t}\n\n\treturn { min, max } as unknown as { min: T; max: T };\n}\n\nfunction expandBounds(bboxes: bbox[]): bbox {\n\tconst result = bboxes[0];\n\tfor (const bbox of bboxes) {\n\t\tmin(result.min, result.min, bbox.min);\n\t\tmax(result.max, result.max, bbox.max);\n\t}\n\treturn result;\n}\n\ninterface VectorTransform<T = vec2 | vec3 | vec4> {\n\toffset: T;\n\tscale: number;\n}\n\nfunction fromTransform(transform: VectorTransform<vec3>): mat4 {\n\treturn fromRotationTranslationScale([] as unknown as mat4, [0, 0, 0, 1], transform.offset, [\n\t\ttransform.scale,\n\t\ttransform.scale,\n\t\ttransform.scale,\n\t]) as mat4;\n}\n\nexport { quantize };\n","import type { Document, Transform } from '@gltf-transform/core';\nimport { EXTMeshoptCompression } from '@gltf-transform/extensions';\nimport type { MeshoptEncoder } from 'meshoptimizer';\nimport { reorder } from './reorder';\nimport { quantize } from './quantize';\nimport { createTransform } from './utils';\n\nexport interface MeshoptOptions {\n\tencoder: unknown;\n\tlevel?: 'medium' | 'high';\n}\n\nexport const MESHOPT_DEFAULTS: Required<Omit<MeshoptOptions, 'encoder'>> = { level: 'high' };\n\nconst NAME = 'meshopt';\n\n/**\n * Applies Meshopt compression using {@link EXTMeshoptCompression EXT_meshopt_compression}.\n * This type of compression can reduce the size of point, line, and triangle geometry,\n * morph targets, and animation data.\n *\n * This function is a thin wrapper around {@link reorder}, {@link quantize}, and\n * {@link EXTMeshoptCompression}, and exposes relatively few configuration options.\n * To access more options (like quantization bits) direct use of the underlying\n * functions is recommended.\n *\n * Example:\n *\n * ```javascript\n * import { MeshoptEncoder } from 'meshoptimizer';\n * import { reorder } from '@gltf-transform/functions';\n *\n * await MeshoptEncoder.ready;\n *\n * await document.transform(\n *   reorder({encoder: MeshoptEncoder, level: 'medium'})\n * );\n * ```\n */\nexport const meshopt = (_options: MeshoptOptions): Transform => {\n\tconst options = { ...MESHOPT_DEFAULTS, ..._options } as Required<MeshoptOptions>;\n\tconst encoder = options.encoder as typeof MeshoptEncoder | undefined;\n\n\tif (!encoder) {\n\t\tthrow new Error(`${NAME}: encoder dependency required — install \"meshoptimizer\".`);\n\t}\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tawait document.transform(\n\t\t\treorder({\n\t\t\t\tencoder: encoder,\n\t\t\t\ttarget: 'size',\n\t\t\t}),\n\t\t\tquantize({\n\t\t\t\t// IMPORTANT: Vertex attributes should be quantized in 'high' mode IFF they are\n\t\t\t\t// _not_ filtered in 'packages/extensions/src/ext-meshopt-compression/encoder.ts'.\n\t\t\t\tpattern: options.level === 'medium' ? /.*/ : /^(POSITION|TEXCOORD|JOINTS|WEIGHTS)(_\\d+)?$/,\n\t\t\t\tquantizePosition: 14,\n\t\t\t\tquantizeTexcoord: 12,\n\t\t\t\tquantizeColor: 8,\n\t\t\t\tquantizeNormal: 8,\n\t\t\t})\n\t\t);\n\n\t\tdocument\n\t\t\t.createExtension(EXTMeshoptCompression)\n\t\t\t.setRequired(true)\n\t\t\t.setEncoderOptions({\n\t\t\t\tmethod:\n\t\t\t\t\toptions.level === 'medium'\n\t\t\t\t\t\t? EXTMeshoptCompression.EncoderMethod.QUANTIZE\n\t\t\t\t\t\t: EXTMeshoptCompression.EncoderMethod.FILTER,\n\t\t\t});\n\t});\n};\n","import type { Document, Texture, Transform } from '@gltf-transform/core';\nimport {\n\tKHRMaterialsIOR,\n\tKHRMaterialsPBRSpecularGlossiness,\n\tKHRMaterialsSpecular,\n\tPBRSpecularGlossiness,\n} from '@gltf-transform/extensions';\nimport { createTransform, rewriteTexture } from './utils';\n\nconst NAME = 'metalRough';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface MetalRoughOptions {}\n\nconst METALROUGH_DEFAULTS: Required<MetalRoughOptions> = {};\n\n/**\n * Convert {@link Material}s from spec/gloss PBR workflow to metal/rough PBR workflow,\n * removing `KHR_materials_pbrSpecularGlossiness` and adding `KHR_materials_ior` and\n * `KHR_materials_specular`. The metal/rough PBR workflow is preferred for most use cases,\n * and is a prerequisite for other advanced PBR extensions provided by glTF.\n *\n * No options are currently implemented for this function.\n */\nexport function metalRough(_options: MetalRoughOptions = METALROUGH_DEFAULTS): Transform {\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst options = { ...METALROUGH_DEFAULTS, ..._options } as Required<MetalRoughOptions>;\n\n\treturn createTransform(NAME, async (doc: Document): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\n\t\tconst extensionsUsed = doc\n\t\t\t.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.map((ext) => ext.extensionName);\n\t\tif (!extensionsUsed.includes('KHR_materials_pbrSpecularGlossiness')) {\n\t\t\tlogger.warn(`${NAME}: KHR_materials_pbrSpecularGlossiness not found on document.`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst iorExtension = doc.createExtension(KHRMaterialsIOR);\n\t\tconst specExtension = doc.createExtension(KHRMaterialsSpecular);\n\t\tconst specGlossExtension = doc.createExtension(KHRMaterialsPBRSpecularGlossiness);\n\n\t\tconst inputTextures = new Set<Texture | null>();\n\n\t\tfor (const material of doc.getRoot().listMaterials()) {\n\t\t\tconst specGloss = material.getExtension<PBRSpecularGlossiness>('KHR_materials_pbrSpecularGlossiness');\n\t\t\tif (!specGloss) continue;\n\n\t\t\t// Create specular extension.\n\t\t\tconst specular = specExtension\n\t\t\t\t.createSpecular()\n\t\t\t\t.setSpecularFactor(1.0)\n\t\t\t\t.setSpecularColorFactor(specGloss.getSpecularFactor());\n\n\t\t\t// Stash textures that might become unused, to check and clean up later.\n\t\t\tinputTextures.add(specGloss.getSpecularGlossinessTexture());\n\t\t\tinputTextures.add(material.getBaseColorTexture());\n\t\t\tinputTextures.add(material.getMetallicRoughnessTexture());\n\n\t\t\t// Set up a metal/rough PBR material with IOR=Infinity (or 0), metallic=0. This\n\t\t\t// representation is precise and reliable, but perhaps less convenient for artists\n\t\t\t// than deriving a metalness value. Unfortunately we can't do that without imprecise\n\t\t\t// heuristics, and perhaps user tuning.\n\t\t\t// See: https://github.com/KhronosGroup/glTF/pull/1719#issuecomment-674365677\n\t\t\tmaterial\n\t\t\t\t.setBaseColorFactor(specGloss.getDiffuseFactor())\n\t\t\t\t.setMetallicFactor(0)\n\t\t\t\t.setRoughnessFactor(1)\n\t\t\t\t.setExtension('KHR_materials_ior', iorExtension.createIOR().setIOR(1000))\n\t\t\t\t.setExtension('KHR_materials_specular', specular);\n\n\t\t\t// Move diffuse -> baseColor.\n\t\t\tconst diffuseTexture = specGloss.getDiffuseTexture();\n\t\t\tif (diffuseTexture) {\n\t\t\t\tmaterial.setBaseColorTexture(diffuseTexture);\n\t\t\t\tmaterial.getBaseColorTextureInfo()!.copy(specGloss.getDiffuseTextureInfo()!);\n\t\t\t}\n\n\t\t\t// Move specular + gloss -> specular + roughness.\n\t\t\tconst sgTexture = specGloss.getSpecularGlossinessTexture();\n\t\t\tif (sgTexture) {\n\t\t\t\t// specularGlossiness -> specular.\n\t\t\t\tconst sgTextureInfo = specGloss.getSpecularGlossinessTextureInfo()!;\n\t\t\t\tconst specularTexture = doc.createTexture();\n\t\t\t\tawait rewriteTexture(sgTexture, specularTexture, (pixels, i, j) => {\n\t\t\t\t\tpixels.set(i, j, 3, 255); // Remove glossiness.\n\t\t\t\t});\n\t\t\t\tspecular.setSpecularTexture(specularTexture);\n\t\t\t\tspecular.setSpecularColorTexture(specularTexture);\n\t\t\t\tspecular.getSpecularTextureInfo()!.copy(sgTextureInfo);\n\t\t\t\tspecular.getSpecularColorTextureInfo()!.copy(sgTextureInfo);\n\n\t\t\t\t// specularGlossiness -> roughness.\n\t\t\t\tconst glossinessFactor = specGloss.getGlossinessFactor();\n\t\t\t\tconst metalRoughTexture = doc.createTexture();\n\t\t\t\tawait rewriteTexture(sgTexture, metalRoughTexture, (pixels, i, j) => {\n\t\t\t\t\t// Invert glossiness.\n\t\t\t\t\tconst roughness = 255 - Math.round(pixels.get(i, j, 3) * glossinessFactor);\n\t\t\t\t\tpixels.set(i, j, 0, 0);\n\t\t\t\t\tpixels.set(i, j, 1, roughness);\n\t\t\t\t\tpixels.set(i, j, 2, 0);\n\t\t\t\t\tpixels.set(i, j, 3, 255);\n\t\t\t\t});\n\t\t\t\tmaterial.setMetallicRoughnessTexture(metalRoughTexture);\n\t\t\t\tmaterial.getMetallicRoughnessTextureInfo()!.copy(sgTextureInfo);\n\t\t\t} else {\n\t\t\t\tspecular.setSpecularColorFactor(specGloss.getSpecularFactor());\n\t\t\t\tmaterial.setRoughnessFactor(1 - specGloss.getGlossinessFactor());\n\t\t\t}\n\n\t\t\t// Remove KHR_materials_pbrSpecularGlossiness from the material.\n\t\t\tmaterial.setExtension('KHR_materials_pbrSpecularGlossiness', null);\n\t\t}\n\n\t\t// Remove KHR_materials_pbrSpecularGlossiness from the document.\n\t\tspecGlossExtension.dispose();\n\n\t\t// Clean up unused textures.\n\t\tfor (const tex of inputTextures) {\n\t\t\tif (tex && tex.listParents().length === 1) tex.dispose();\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n","\nimport type { Accessor, Document, ILogger, Transform, TypedArray } from '@gltf-transform/core';\nimport { createTransform, formatDeltaOp } from './utils';\n\nconst NAME = 'unweld';\n\n/** Options for the {@link unweld} function. */\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface UnweldOptions {}\n\nconst UNWELD_DEFAULTS: UnweldOptions = {};\n\n/**\n * De-index {@link Primitive}s, disconnecting any shared vertices. This operation will generally\n * increase the number of vertices in a mesh, but may be helpful for some geometry operations or\n * for creating hard edges.\n *\n * No options are currently implemented for this function.\n */\nexport function unweld(_options: UnweldOptions = UNWELD_DEFAULTS): Transform {\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst options = { ...UNWELD_DEFAULTS, ..._options } as Required<UnweldOptions>;\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst visited = new Map<Accessor, Map<Accessor, Accessor>>();\n\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tconst indices = prim.getIndices();\n\t\t\t\tif (!indices) continue;\n\n\t\t\t\tconst srcVertexCount = prim.getAttribute('POSITION')!.getCount();\n\n\t\t\t\t// Vertex attributes.\n\t\t\t\tfor (const srcAttribute of prim.listAttributes()) {\n\t\t\t\t\tprim.swap(srcAttribute, unweldAttribute(srcAttribute, indices, logger, visited));\n\n\t\t\t\t\t// Clean up.\n\t\t\t\t\tif (srcAttribute.listParents().length === 1) srcAttribute.dispose();\n\t\t\t\t}\n\n\t\t\t\t// Morph target vertex attributes.\n\t\t\t\tfor (const target of prim.listTargets()) {\n\t\t\t\t\tfor (const srcAttribute of target.listAttributes()) {\n\t\t\t\t\t\ttarget.swap(srcAttribute, unweldAttribute(srcAttribute, indices, logger, visited));\n\n\t\t\t\t\t\t// Clean up.\n\t\t\t\t\t\tif (srcAttribute.listParents().length === 1) srcAttribute.dispose();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst dstVertexCount = prim.getAttribute('POSITION')!.getCount();\n\t\t\t\tlogger.debug(`${NAME}: ${formatDeltaOp(srcVertexCount, dstVertexCount)} vertices.`);\n\n\t\t\t\t// Clean up.\n\t\t\t\tprim.setIndices(null);\n\t\t\t\tif (indices.listParents().length === 1) indices.dispose();\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\nfunction unweldAttribute(\n\tsrcAttribute: Accessor,\n\tindices: Accessor,\n\tlogger: ILogger,\n\tvisited: Map<Accessor, Map<Accessor, Accessor>>\n): Accessor {\n\tif (visited.has(srcAttribute) && visited.get(srcAttribute)!.has(indices)) {\n\t\tlogger.debug(`${NAME}: Cache hit for reused attribute, \"${srcAttribute.getName()}\".`);\n\t\treturn visited.get(srcAttribute)!.get(indices)!;\n\t}\n\n\tconst dstAttribute = srcAttribute.clone();\n\tconst ArrayCtor = srcAttribute.getArray()!.constructor as new (len: number) => TypedArray;\n\tdstAttribute.setArray(new ArrayCtor(indices.getCount() * srcAttribute.getElementSize()));\n\n\tconst el: number[] = [];\n\tfor (let i = 0; i < indices.getCount(); i++) {\n\t\tdstAttribute.setElement(i, srcAttribute.getElement(indices.getScalar(i), el));\n\t}\n\n\tif (!visited.has(srcAttribute)) visited.set(srcAttribute, new Map());\n\tvisited.get(srcAttribute)!.set(indices, dstAttribute);\n\n\treturn dstAttribute;\n}\n","import type { Document, Transform, vec3 } from '@gltf-transform/core';\nimport { unweld } from './unweld';\nimport { createTransform } from './utils';\nimport { normalize } from 'gl-matrix/vec3';\n\nconst NAME = 'normals';\n\n/** Options for the {@link normals} function. */\nexport interface NormalsOptions {\n\t/** Whether to overwrite existing `NORMAL` attributes. */\n\toverwrite?: boolean;\n}\n\nconst NORMALS_DEFAULTS: Required<NormalsOptions> = {\n\toverwrite: false,\n};\n\n/**\n * Generates flat vertex normals for mesh primitives.\n *\n * Example:\n *\n * ```ts\n * import { normals } from '@gltf-transform/functions';\n *\n * await document.transform(normals({overwrite: true}));\n * ```\n */\nexport function normals(_options: NormalsOptions = NORMALS_DEFAULTS): Transform {\n\tconst options = { ...NORMALS_DEFAULTS, ..._options } as Required<NormalsOptions>;\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\t\tlet modified = 0;\n\n\t\tawait document.transform(unweld());\n\n\t\tfor (const mesh of document.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tconst position = prim.getAttribute('POSITION')!;\n\t\t\t\tlet normal = prim.getAttribute('NORMAL');\n\n\t\t\t\tif (options.overwrite && normal) {\n\t\t\t\t\tnormal.dispose();\n\t\t\t\t} else if (normal) {\n\t\t\t\t\tlogger.debug(`${NAME}: Skipping primitive: NORMAL found.`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tnormal = document\n\t\t\t\t\t.createAccessor()\n\t\t\t\t\t.setArray(new Float32Array(position.getCount() * 3))\n\t\t\t\t\t.setType('VEC3');\n\n\t\t\t\tconst a = [0, 0, 0] as vec3;\n\t\t\t\tconst b = [0, 0, 0] as vec3;\n\t\t\t\tconst c = [0, 0, 0] as vec3;\n\n\t\t\t\tfor (let i = 0; i < position.getCount(); i += 3) {\n\t\t\t\t\tposition.getElement(i + 0, a);\n\t\t\t\t\tposition.getElement(i + 1, b);\n\t\t\t\t\tposition.getElement(i + 2, c);\n\n\t\t\t\t\tconst faceNormal = computeNormal(a, b, c);\n\n\t\t\t\t\tnormal.setElement(i + 0, faceNormal);\n\t\t\t\t\tnormal.setElement(i + 1, faceNormal);\n\t\t\t\t\tnormal.setElement(i + 2, faceNormal);\n\t\t\t\t}\n\n\t\t\t\tprim.setAttribute('NORMAL', normal);\n\t\t\t\tmodified++;\n\t\t\t}\n\t\t}\n\n\t\tif (!modified) {\n\t\t\tlogger.warn(`${NAME}: No qualifying primitives found. See debug output.`);\n\t\t} else {\n\t\t\tlogger.debug(`${NAME}: Complete.`);\n\t\t}\n\t});\n}\n\n// https://stackoverflow.com/a/23709352/1314762\nfunction computeNormal(a: vec3, b: vec3, c: vec3): vec3 {\n\tconst A = [b[0] - a[0], b[1] - a[1], b[2] - a[2]];\n\tconst B = [c[0] - a[0], c[1] - a[1], c[2] - a[2]];\n\tconst n = [\n\t\tA[1] * B[2] - A[2] * B[1], //\n\t\tA[2] * B[0] - A[0] * B[2],\n\t\tA[0] * B[1] - A[1] * B[0],\n\t] as vec3;\n\treturn normalize([0, 0, 0], n) as vec3;\n}\n","import { Document, ILogger, PropertyType, Transform } from '@gltf-transform/core';\nimport { prune } from './prune';\nimport { createTransform } from './utils';\n\nconst NAME = 'partition';\n\nexport interface PartitionOptions {\n\tanimations?: boolean | Array<string>;\n\tmeshes?: boolean | Array<string>;\n}\n\nconst PARTITION_DEFAULTS: Required<PartitionOptions> = {\n\tanimations: true,\n\tmeshes: true,\n};\n\n/**\n * Partitions the binary payload of a glTF file so separate mesh or animation data is in separate\n * `.bin` {@link Buffer}s. This technique may be useful for engines that support lazy-loading\n * specific binary resources as needed over the application lifecycle.\n *\n * Example:\n *\n * ```ts\n * document.getRoot().listBuffers(); // → [Buffer]\n *\n * await document.transform(partition({meshes: true}));\n *\n * document.getRoot().listBuffers(); // → [Buffer, Buffer, ...]\n * ```\n */\nconst partition = (_options: PartitionOptions = PARTITION_DEFAULTS): Transform => {\n\tconst options = { ...PARTITION_DEFAULTS, ..._options } as Required<PartitionOptions>;\n\n\treturn createTransform(NAME, async (doc: Document): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\n\t\tif (options.meshes !== false) partitionMeshes(doc, logger, options);\n\t\tif (options.animations !== false) partitionAnimations(doc, logger, options);\n\n\t\tif (!options.meshes && !options.animations) {\n\t\t\tlogger.warn(`${NAME}: Select animations or meshes to create a partition.`);\n\t\t}\n\n\t\tawait doc.transform(prune({ propertyTypes: [PropertyType.BUFFER] }));\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n};\n\nfunction partitionMeshes(doc: Document, logger: ILogger, options: PartitionOptions): void {\n\tconst existingURIs = new Set<string>(\n\t\tdoc\n\t\t\t.getRoot()\n\t\t\t.listBuffers()\n\t\t\t.map((b) => b.getURI())\n\t);\n\n\tdoc.getRoot()\n\t\t.listMeshes()\n\t\t.forEach((mesh, meshIndex) => {\n\t\t\tif (Array.isArray(options.meshes) && !options.meshes.includes(mesh.getName())) {\n\t\t\t\tlogger.debug(`${NAME}: Skipping mesh #${meshIndex} with name \"${mesh.getName()}\".`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlogger.debug(`${NAME}: Creating buffer for mesh \"${mesh.getName()}\".`);\n\n\t\t\tconst buffer = doc\n\t\t\t\t.createBuffer(mesh.getName())\n\t\t\t\t.setURI(createBufferURI(mesh.getName() || 'mesh', existingURIs));\n\n\t\t\tmesh.listPrimitives().forEach((primitive) => {\n\t\t\t\tconst indices = primitive.getIndices();\n\t\t\t\tif (indices) indices.setBuffer(buffer);\n\t\t\t\tprimitive.listAttributes().forEach((attribute) => attribute.setBuffer(buffer));\n\t\t\t\tprimitive.listTargets().forEach((primTarget) => {\n\t\t\t\t\tprimTarget.listAttributes().forEach((attribute) => attribute.setBuffer(buffer));\n\t\t\t\t});\n\t\t\t});\n\t\t});\n}\n\nfunction partitionAnimations(doc: Document, logger: ILogger, options: PartitionOptions): void {\n\tconst existingURIs = new Set<string>(\n\t\tdoc\n\t\t\t.getRoot()\n\t\t\t.listBuffers()\n\t\t\t.map((b) => b.getURI())\n\t);\n\n\tdoc.getRoot()\n\t\t.listAnimations()\n\t\t.forEach((anim, animIndex) => {\n\t\t\tif (Array.isArray(options.animations) && !options.animations.includes(anim.getName())) {\n\t\t\t\tlogger.debug(`${NAME}: Skipping animation #${animIndex} with name \"${anim.getName()}\".`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlogger.debug(`${NAME}: Creating buffer for animation \"${anim.getName()}\".`);\n\n\t\t\tconst buffer = doc\n\t\t\t\t.createBuffer(anim.getName())\n\t\t\t\t.setURI(createBufferURI(anim.getName() || 'animation', existingURIs));\n\n\t\t\tanim.listSamplers().forEach((sampler) => {\n\t\t\t\tconst input = sampler.getInput();\n\t\t\t\tconst output = sampler.getOutput();\n\t\t\t\tif (input) input.setBuffer(buffer);\n\t\t\t\tif (output) output.setBuffer(buffer);\n\t\t\t});\n\t\t});\n}\n\nfunction createBufferURI(basename: string, existing: Set<string>): string {\n\tlet uri = `${basename}.bin`;\n\tlet i = 1;\n\twhile (existing.has(uri)) uri = `${basename}_${i++}.bin`;\n\treturn uri;\n}\n\nexport { partition };\n","import * as glMatrix from \"./common.js\";\nimport * as mat3 from \"./mat3.js\";\nimport * as vec3 from \"./vec3.js\";\nimport * as vec4 from \"./vec4.js\";\n/**\n * Quaternion\n * @module quat\n */\n\n/**\n * Creates a new identity quat\n *\n * @returns {quat} a new quaternion\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  out[3] = 1;\n  return out;\n}\n/**\n * Set a quat to the identity quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\n\nexport function identity(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n/**\n * Sets a quat from the given angle and rotation axis,\n * then returns it.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyVec3} axis the axis around which to rotate\n * @param {Number} rad the angle in radians\n * @returns {quat} out\n **/\n\nexport function setAxisAngle(out, axis, rad) {\n  rad = rad * 0.5;\n  var s = Math.sin(rad);\n  out[0] = s * axis[0];\n  out[1] = s * axis[1];\n  out[2] = s * axis[2];\n  out[3] = Math.cos(rad);\n  return out;\n}\n/**\n * Gets the rotation axis and angle for a given\n *  quaternion. If a quaternion is created with\n *  setAxisAngle, this method will return the same\n *  values as providied in the original parameter list\n *  OR functionally equivalent values.\n * Example: The quaternion formed by axis [0, 0, 1] and\n *  angle -90 is the same as the quaternion formed by\n *  [0, 0, 1] and 270. This method favors the latter.\n * @param  {vec3} out_axis  Vector receiving the axis of rotation\n * @param  {ReadonlyQuat} q     Quaternion to be decomposed\n * @return {Number}     Angle, in radians, of the rotation\n */\n\nexport function getAxisAngle(out_axis, q) {\n  var rad = Math.acos(q[3]) * 2.0;\n  var s = Math.sin(rad / 2.0);\n\n  if (s > glMatrix.EPSILON) {\n    out_axis[0] = q[0] / s;\n    out_axis[1] = q[1] / s;\n    out_axis[2] = q[2] / s;\n  } else {\n    // If s is zero, return any axis (no rotation - axis does not matter)\n    out_axis[0] = 1;\n    out_axis[1] = 0;\n    out_axis[2] = 0;\n  }\n\n  return rad;\n}\n/**\n * Gets the angular distance between two unit quaternions\n *\n * @param  {ReadonlyQuat} a     Origin unit quaternion\n * @param  {ReadonlyQuat} b     Destination unit quaternion\n * @return {Number}     Angle, in radians, between the two quaternions\n */\n\nexport function getAngle(a, b) {\n  var dotproduct = dot(a, b);\n  return Math.acos(2 * dotproduct * dotproduct - 1);\n}\n/**\n * Multiplies two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {quat} out\n */\n\nexport function multiply(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  out[0] = ax * bw + aw * bx + ay * bz - az * by;\n  out[1] = ay * bw + aw * by + az * bx - ax * bz;\n  out[2] = az * bw + aw * bz + ax * by - ay * bx;\n  out[3] = aw * bw - ax * bx - ay * by - az * bz;\n  return out;\n}\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\n\nexport function rotateX(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw + aw * bx;\n  out[1] = ay * bw + az * bx;\n  out[2] = az * bw - ay * bx;\n  out[3] = aw * bw - ax * bx;\n  return out;\n}\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\n\nexport function rotateY(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var by = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw - az * by;\n  out[1] = ay * bw + aw * by;\n  out[2] = az * bw + ax * by;\n  out[3] = aw * bw - ay * by;\n  return out;\n}\n/**\n * Rotates a quaternion by the given angle about the Z axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\n\nexport function rotateZ(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bz = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw + ay * bz;\n  out[1] = ay * bw - ax * bz;\n  out[2] = az * bw + aw * bz;\n  out[3] = aw * bw - az * bz;\n  return out;\n}\n/**\n * Calculates the W component of a quat from the X, Y, and Z components.\n * Assumes that quaternion is 1 unit in length.\n * Any existing W component will be ignored.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate W component of\n * @returns {quat} out\n */\n\nexport function calculateW(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\n  return out;\n}\n/**\n * Calculate the exponential of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @returns {quat} out\n */\n\nexport function exp(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  var r = Math.sqrt(x * x + y * y + z * z);\n  var et = Math.exp(w);\n  var s = r > 0 ? et * Math.sin(r) / r : 0;\n  out[0] = x * s;\n  out[1] = y * s;\n  out[2] = z * s;\n  out[3] = et * Math.cos(r);\n  return out;\n}\n/**\n * Calculate the natural logarithm of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @returns {quat} out\n */\n\nexport function ln(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  var r = Math.sqrt(x * x + y * y + z * z);\n  var t = r > 0 ? Math.atan2(r, w) / r : 0;\n  out[0] = x * t;\n  out[1] = y * t;\n  out[2] = z * t;\n  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);\n  return out;\n}\n/**\n * Calculate the scalar power of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @param {Number} b amount to scale the quaternion by\n * @returns {quat} out\n */\n\nexport function pow(out, a, b) {\n  ln(out, a);\n  scale(out, out, b);\n  exp(out, out);\n  return out;\n}\n/**\n * Performs a spherical linear interpolation between two quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\n\nexport function slerp(out, a, b, t) {\n  // benchmarks:\n  //    http://jsperf.com/quaternion-slerp-implementations\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  var omega, cosom, sinom, scale0, scale1; // calc cosine\n\n  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)\n\n  if (cosom < 0.0) {\n    cosom = -cosom;\n    bx = -bx;\n    by = -by;\n    bz = -bz;\n    bw = -bw;\n  } // calculate coefficients\n\n\n  if (1.0 - cosom > glMatrix.EPSILON) {\n    // standard case (slerp)\n    omega = Math.acos(cosom);\n    sinom = Math.sin(omega);\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\n    scale1 = Math.sin(t * omega) / sinom;\n  } else {\n    // \"from\" and \"to\" quaternions are very close\n    //  ... so we can do a linear interpolation\n    scale0 = 1.0 - t;\n    scale1 = t;\n  } // calculate final values\n\n\n  out[0] = scale0 * ax + scale1 * bx;\n  out[1] = scale0 * ay + scale1 * by;\n  out[2] = scale0 * az + scale1 * bz;\n  out[3] = scale0 * aw + scale1 * bw;\n  return out;\n}\n/**\n * Generates a random unit quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\n\nexport function random(out) {\n  // Implementation of http://planning.cs.uiuc.edu/node198.html\n  // TODO: Calling random 3 times is probably not the fastest solution\n  var u1 = glMatrix.RANDOM();\n  var u2 = glMatrix.RANDOM();\n  var u3 = glMatrix.RANDOM();\n  var sqrt1MinusU1 = Math.sqrt(1 - u1);\n  var sqrtU1 = Math.sqrt(u1);\n  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);\n  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);\n  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);\n  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);\n  return out;\n}\n/**\n * Calculates the inverse of a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate inverse of\n * @returns {quat} out\n */\n\nexport function invert(out, a) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n  out[0] = -a0 * invDot;\n  out[1] = -a1 * invDot;\n  out[2] = -a2 * invDot;\n  out[3] = a3 * invDot;\n  return out;\n}\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate conjugate of\n * @returns {quat} out\n */\n\nexport function conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Creates a quaternion from the given 3x3 rotation matrix.\n *\n * NOTE: The resultant quaternion is not normalized, so you should be sure\n * to renormalize the quaternion yourself where necessary.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyMat3} m rotation matrix\n * @returns {quat} out\n * @function\n */\n\nexport function fromMat3(out, m) {\n  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n  // article \"Quaternion Calculus and Fast Animation\".\n  var fTrace = m[0] + m[4] + m[8];\n  var fRoot;\n\n  if (fTrace > 0.0) {\n    // |w| > 1/2, may as well choose w > 1/2\n    fRoot = Math.sqrt(fTrace + 1.0); // 2w\n\n    out[3] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot; // 1/(4w)\n\n    out[0] = (m[5] - m[7]) * fRoot;\n    out[1] = (m[6] - m[2]) * fRoot;\n    out[2] = (m[1] - m[3]) * fRoot;\n  } else {\n    // |w| <= 1/2\n    var i = 0;\n    if (m[4] > m[0]) i = 1;\n    if (m[8] > m[i * 3 + i]) i = 2;\n    var j = (i + 1) % 3;\n    var k = (i + 2) % 3;\n    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n    out[i] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot;\n    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n  }\n\n  return out;\n}\n/**\n * Creates a quaternion from the given euler angle x, y, z.\n *\n * @param {quat} out the receiving quaternion\n * @param {x} Angle to rotate around X axis in degrees.\n * @param {y} Angle to rotate around Y axis in degrees.\n * @param {z} Angle to rotate around Z axis in degrees.\n * @returns {quat} out\n * @function\n */\n\nexport function fromEuler(out, x, y, z) {\n  var halfToRad = 0.5 * Math.PI / 180.0;\n  x *= halfToRad;\n  y *= halfToRad;\n  z *= halfToRad;\n  var sx = Math.sin(x);\n  var cx = Math.cos(x);\n  var sy = Math.sin(y);\n  var cy = Math.cos(y);\n  var sz = Math.sin(z);\n  var cz = Math.cos(z);\n  out[0] = sx * cy * cz - cx * sy * sz;\n  out[1] = cx * sy * cz + sx * cy * sz;\n  out[2] = cx * cy * sz - sx * sy * cz;\n  out[3] = cx * cy * cz + sx * sy * sz;\n  return out;\n}\n/**\n * Returns a string representation of a quatenion\n *\n * @param {ReadonlyQuat} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"quat(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n/**\n * Creates a new quat initialized with values from an existing quaternion\n *\n * @param {ReadonlyQuat} a quaternion to clone\n * @returns {quat} a new quaternion\n * @function\n */\n\nexport var clone = vec4.clone;\n/**\n * Creates a new quat initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} a new quaternion\n * @function\n */\n\nexport var fromValues = vec4.fromValues;\n/**\n * Copy the values from one quat to another\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the source quaternion\n * @returns {quat} out\n * @function\n */\n\nexport var copy = vec4.copy;\n/**\n * Set the components of a quat to the given values\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} out\n * @function\n */\n\nexport var set = vec4.set;\n/**\n * Adds two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {quat} out\n * @function\n */\n\nexport var add = vec4.add;\n/**\n * Alias for {@link quat.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Scales a quat by a scalar number\n *\n * @param {quat} out the receiving vector\n * @param {ReadonlyQuat} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {quat} out\n * @function\n */\n\nexport var scale = vec4.scale;\n/**\n * Calculates the dot product of two quat's\n *\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\n\nexport var dot = vec4.dot;\n/**\n * Performs a linear interpolation between two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n * @function\n */\n\nexport var lerp = vec4.lerp;\n/**\n * Calculates the length of a quat\n *\n * @param {ReadonlyQuat} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport var length = vec4.length;\n/**\n * Alias for {@link quat.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Calculates the squared length of a quat\n *\n * @param {ReadonlyQuat} a vector to calculate squared length of\n * @returns {Number} squared length of a\n * @function\n */\n\nexport var squaredLength = vec4.squaredLength;\n/**\n * Alias for {@link quat.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Normalize a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quaternion to normalize\n * @returns {quat} out\n * @function\n */\n\nexport var normalize = vec4.normalize;\n/**\n * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyQuat} a The first quaternion.\n * @param {ReadonlyQuat} b The second quaternion.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport var exactEquals = vec4.exactEquals;\n/**\n * Returns whether or not the quaternions have approximately the same elements in the same position.\n *\n * @param {ReadonlyQuat} a The first vector.\n * @param {ReadonlyQuat} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport var equals = vec4.equals;\n/**\n * Sets a quaternion to represent the shortest rotation from one\n * vector to another.\n *\n * Both vectors are assumed to be unit length.\n *\n * @param {quat} out the receiving quaternion.\n * @param {ReadonlyVec3} a the initial vector\n * @param {ReadonlyVec3} b the destination vector\n * @returns {quat} out\n */\n\nexport var rotationTo = function () {\n  var tmpvec3 = vec3.create();\n  var xUnitVec3 = vec3.fromValues(1, 0, 0);\n  var yUnitVec3 = vec3.fromValues(0, 1, 0);\n  return function (out, a, b) {\n    var dot = vec3.dot(a, b);\n\n    if (dot < -0.999999) {\n      vec3.cross(tmpvec3, xUnitVec3, a);\n      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);\n      vec3.normalize(tmpvec3, tmpvec3);\n      setAxisAngle(out, tmpvec3, Math.PI);\n      return out;\n    } else if (dot > 0.999999) {\n      out[0] = 0;\n      out[1] = 0;\n      out[2] = 0;\n      out[3] = 1;\n      return out;\n    } else {\n      vec3.cross(tmpvec3, a, b);\n      out[0] = tmpvec3[0];\n      out[1] = tmpvec3[1];\n      out[2] = tmpvec3[2];\n      out[3] = 1 + dot;\n      return normalize(out, out);\n    }\n  };\n}();\n/**\n * Performs a spherical linear interpolation with two control points\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {ReadonlyQuat} c the third operand\n * @param {ReadonlyQuat} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\n\nexport var sqlerp = function () {\n  var temp1 = create();\n  var temp2 = create();\n  return function (out, a, b, c, d, t) {\n    slerp(temp1, a, d, t);\n    slerp(temp2, b, c, t);\n    slerp(out, temp1, temp2, 2 * t * (1 - t));\n    return out;\n  };\n}();\n/**\n * Sets the specified quaternion with values corresponding to the given\n * axes. Each axis is a vec3 and is expected to be unit length and\n * perpendicular to all other specified axes.\n *\n * @param {ReadonlyVec3} view  the vector representing the viewing direction\n * @param {ReadonlyVec3} right the vector representing the local \"right\" direction\n * @param {ReadonlyVec3} up    the vector representing the local \"up\" direction\n * @returns {quat} out\n */\n\nexport var setAxes = function () {\n  var matr = mat3.create();\n  return function (out, view, right, up) {\n    matr[0] = right[0];\n    matr[3] = right[1];\n    matr[6] = right[2];\n    matr[1] = up[0];\n    matr[4] = up[1];\n    matr[7] = up[2];\n    matr[2] = -view[0];\n    matr[5] = -view[1];\n    matr[8] = -view[2];\n    return normalize(out, fromMat3(out, matr));\n  };\n}();","import {\n\tAccessor,\n\tAnimationSampler,\n\tDocument,\n\tGLTF,\n\tMathUtils,\n\tPropertyType,\n\tRoot,\n\tTransform,\n\tTransformContext,\n} from '@gltf-transform/core';\nimport quat, { getAngle, slerp } from 'gl-matrix/quat';\nimport { dedup } from './dedup';\nimport { createTransform, isTransformPending } from './utils';\n\nconst NAME = 'resample';\n\nexport interface ResampleOptions {\n\ttolerance?: number;\n}\n\nconst RESAMPLE_DEFAULTS: Required<ResampleOptions> = { tolerance: 1e-4 };\n\n/**\n * Resample {@link Animation}s, losslessly deduplicating keyframes to reduce file size. Duplicate\n * keyframes are commonly present in animation 'baked' by the authoring software to apply IK\n * constraints or other software-specific features. Based on THREE.KeyframeTrack.optimize().\n *\n * Example: (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n */\nexport const resample = (_options: ResampleOptions = RESAMPLE_DEFAULTS): Transform => {\n\tconst options = { ...RESAMPLE_DEFAULTS, ..._options } as Required<ResampleOptions>;\n\n\treturn createTransform(NAME, async (document: Document, context?: TransformContext): Promise<void> => {\n\t\tconst accessorsVisited = new Set<Accessor>();\n\t\tconst srcAccessorCount = document.getRoot().listAccessors().length;\n\t\tconst logger = document.getLogger();\n\n\t\tlet didSkipMorphTargets = false;\n\n\t\tfor (const animation of document.getRoot().listAnimations()) {\n\t\t\t// Skip morph targets, see https://github.com/donmccurdy/glTF-Transform/issues/290.\n\t\t\tconst samplerTargetPaths = new Map<AnimationSampler, GLTF.AnimationChannelTargetPath>();\n\t\t\tfor (const channel of animation.listChannels()) {\n\t\t\t\tsamplerTargetPaths.set(channel.getSampler()!, channel.getTargetPath()!);\n\t\t\t}\n\n\t\t\tfor (const sampler of animation.listSamplers()) {\n\t\t\t\tif (samplerTargetPaths.get(sampler) === 'weights') {\n\t\t\t\t\tdidSkipMorphTargets = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (sampler.getInterpolation() === 'STEP' || sampler.getInterpolation() === 'LINEAR') {\n\t\t\t\t\taccessorsVisited.add(sampler.getInput()!);\n\t\t\t\t\taccessorsVisited.add(sampler.getOutput()!);\n\t\t\t\t\toptimize(sampler, samplerTargetPaths.get(sampler)!, options);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const accessor of Array.from(accessorsVisited.values())) {\n\t\t\tconst used = accessor.listParents().some((p) => !(p instanceof Root));\n\t\t\tif (!used) accessor.dispose();\n\t\t}\n\n\t\t// Resampling may result in duplicate input or output sampler\n\t\t// accessors. Find and remove the duplicates after processing.\n\t\tconst dstAccessorCount = document.getRoot().listAccessors().length;\n\t\tif (dstAccessorCount > srcAccessorCount && !isTransformPending(context, NAME, 'dedup')) {\n\t\t\tawait document.transform(dedup({ propertyTypes: [PropertyType.ACCESSOR] }));\n\t\t}\n\n\t\tif (didSkipMorphTargets) {\n\t\t\tlogger.warn(`${NAME}: Skipped optimizing morph target keyframes, not yet supported.`);\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n};\n\nfunction optimize(sampler: AnimationSampler, path: GLTF.AnimationChannelTargetPath, options: ResampleOptions): void {\n\tconst input = sampler.getInput()!.clone().setSparse(false);\n\tconst output = sampler.getOutput()!.clone().setSparse(false);\n\n\tconst tolerance = options.tolerance as number;\n\tconst interpolation = sampler.getInterpolation();\n\n\tconst lastIndex = input.getCount() - 1;\n\tconst tmp: number[] = [];\n\tconst value: number[] = [];\n\tconst valueNext: number[] = [];\n\tconst valuePrev: number[] = [];\n\n\tlet writeIndex = 1;\n\n\tfor (let i = 1; i < lastIndex; ++i) {\n\t\tconst timePrev = input.getScalar(writeIndex - 1);\n\t\tconst time = input.getScalar(i);\n\t\tconst timeNext = input.getScalar(i + 1);\n\t\tconst t = (time - timePrev) / (timeNext - timePrev);\n\n\t\tlet keep = false;\n\n\t\t// Remove unnecessary adjacent keyframes.\n\t\tif (time !== timeNext && (i !== 1 || time !== input.getScalar(0))) {\n\t\t\toutput.getElement(writeIndex - 1, valuePrev);\n\t\t\toutput.getElement(i, value);\n\t\t\toutput.getElement(i + 1, valueNext);\n\n\t\t\tif (interpolation === 'LINEAR' && path === 'rotation') {\n\t\t\t\t// Prune keyframes colinear with prev/next keyframes.\n\t\t\t\tconst sample = slerp(tmp as quat, valuePrev as quat, valueNext as quat, t) as number[];\n\t\t\t\tconst angle = getAngle(valuePrev as quat, value as quat) + getAngle(value as quat, valueNext as quat);\n\t\t\t\tkeep = !MathUtils.eq(value, sample, tolerance) || angle + Number.EPSILON >= Math.PI;\n\t\t\t} else if (interpolation === 'LINEAR') {\n\t\t\t\t// Prune keyframes colinear with prev/next keyframes.\n\t\t\t\tconst sample = vlerp(tmp, valuePrev, valueNext, t);\n\t\t\t\tkeep = !MathUtils.eq(value, sample, tolerance);\n\t\t\t} else if (interpolation === 'STEP') {\n\t\t\t\t// Prune keyframes identical to prev/next keyframes.\n\t\t\t\tkeep = !MathUtils.eq(value, valuePrev) || !MathUtils.eq(value, valueNext);\n\t\t\t}\n\t\t}\n\n\t\t// In-place compaction.\n\t\tif (keep) {\n\t\t\tif (i !== writeIndex) {\n\t\t\t\tinput.setScalar(writeIndex, input.getScalar(i));\n\t\t\t\toutput.setElement(writeIndex, output.getElement(i, tmp));\n\t\t\t}\n\t\t\twriteIndex++;\n\t\t}\n\t}\n\n\t// Flush last keyframe (compaction looks ahead).\n\tif (lastIndex > 0) {\n\t\tinput.setScalar(writeIndex, input.getScalar(lastIndex));\n\t\toutput.setElement(writeIndex, output.getElement(lastIndex, tmp));\n\t\twriteIndex++;\n\t}\n\n\t// If the sampler was optimized, truncate and save the results. If not, clean up.\n\tif (writeIndex !== input.getCount()) {\n\t\tinput.setArray(input.getArray()!.slice(0, writeIndex));\n\t\toutput.setArray(output.getArray()!.slice(0, writeIndex * output.getElementSize()));\n\t\tsampler.setInput(input);\n\t\tsampler.setOutput(output);\n\t} else {\n\t\tinput.dispose();\n\t\toutput.dispose();\n\t}\n}\n\nfunction lerp(v0: number, v1: number, t: number): number {\n\treturn v0 * (1 - t) + v1 * t;\n}\n\nfunction vlerp(out: number[], a: number[], b: number[], t: number): number[] {\n\tfor (let i = 0; i < a.length; i++) out[i] = lerp(a[i], b[i], t);\n\treturn out;\n}\n","import { Accessor, AnimationChannel, AnimationSampler, Document, Transform } from '@gltf-transform/core';\nimport { createTransform } from './utils';\n\nconst NAME = 'sequence';\n\nexport interface SequenceOptions {\n\t/** Frames per second, where one node is shown each frame. Default 10. */\n\tfps?: number;\n\t/** Pattern (regex) used to filter nodes for the sequence. Required. */\n\tpattern: RegExp;\n\t/** Name of the new animation. */\n\tname?: string;\n\t/** Whether to sort the nodes by name, or use original order. Default true. */\n\tsort?: boolean;\n}\n\nconst SEQUENCE_DEFAULTS: Required<SequenceOptions> = {\n\tname: '',\n\tfps: 10,\n\tpattern: /.*/,\n\tsort: true,\n};\n\n/**\n * Creates an {@link Animation} displaying each of the specified {@link Node}s sequentially.\n */\nexport function sequence (_options: SequenceOptions = SEQUENCE_DEFAULTS): Transform {\n\tconst options = {...SEQUENCE_DEFAULTS, ..._options} as Required<SequenceOptions>;\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\t\tconst fps = options.fps;\n\n\t\t// Collect sequence nodes.\n\t\tconst sequenceNodes = root.listNodes()\n\t\t\t.filter((node) => node.getName().match(options.pattern));\n\n\t\t// Sort by node name.\n\t\tif (options.sort) {\n\t\t\tsequenceNodes.sort((a, b) => a.getName() > b.getName() ? 1 : -1);\n\t\t}\n\n\t\t// Create animation cycling visibility of each node.\n\t\tconst anim = doc.createAnimation(options.name);\n\t\tconst animBuffer = root.listBuffers()[0];\n\t\tsequenceNodes.forEach((node, i) => {\n\t\t\t// Create keyframe tracks that show each node for a single frame.\n\t\t\tlet inputArray;\n\t\t\tlet outputArray;\n\t\t\tif (i === 0) {\n\t\t\t\tinputArray = [i / fps, (i + 1) / fps];\n\t\t\t\toutputArray = [1, 1, 1, 0, 0, 0];\n\t\t\t} else if (i === sequenceNodes.length - 1) {\n\t\t\t\tinputArray = [(i - 1) / fps, i / fps];\n\t\t\t\toutputArray = [0, 0, 0, 1, 1, 1];\n\t\t\t} else {\n\t\t\t\tinputArray = [(i - 1) / fps, i / fps, (i + 1) / fps];\n\t\t\t\toutputArray = [0, 0, 0, 1, 1, 1, 0, 0, 0];\n\t\t\t}\n\n\t\t\t// Append channel to animation sequence.\n\t\t\tconst input = doc.createAccessor()\n\t\t\t\t.setArray(new Float32Array(inputArray))\n\t\t\t\t.setBuffer(animBuffer);\n\t\t\tconst output = doc.createAccessor()\n\t\t\t\t.setArray(new Float32Array(outputArray))\n\t\t\t\t.setBuffer(animBuffer)\n\t\t\t\t.setType(Accessor.Type.VEC3);\n\t\t\tconst sampler = doc.createAnimationSampler()\n\t\t\t\t.setInterpolation(AnimationSampler.Interpolation.STEP)\n\t\t\t\t.setInput(input)\n\t\t\t\t.setOutput(output);\n\t\t\tconst channel = doc.createAnimationChannel()\n\t\t\t\t.setTargetNode(node)\n\t\t\t\t.setTargetPath(AnimationChannel.TargetPath.SCALE)\n\t\t\t\t.setSampler(sampler);\n\t\t\tanim.addSampler(sampler).addChannel(channel);\n\t\t});\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\n\t});\n\n}\n","import {\n\tAccessor,\n\tDocument,\n\tPrimitive,\n\tPrimitiveTarget,\n\tPropertyType,\n\tTransform,\n\tTransformContext,\n\tTypedArray,\n\tvec3,\n} from '@gltf-transform/core';\nimport { dedup } from './dedup';\nimport { createIndices, createTransform, formatDeltaOp, isTransformPending } from './utils';\n\nconst NAME = 'weld';\n\nconst Tolerance = {\n\tDEFAULT: 0.0001,\n\tTEXCOORD: 0.0001, // [0, 1]\n\tCOLOR: 0.01, // [0, 1]\n\tNORMAL: 0.5, // [-1, 1]\n\tJOINTS: 0.0, // [0, ∞]\n\tWEIGHTS: 0.01, // [0, ∞]\n};\n\n/** Options for the {@link weld} function. */\nexport interface WeldOptions {\n\t/** Tolerance, as a fraction of primitive AABB, used when merging similar vertices. */\n\ttolerance?: number;\n\t/** Whether to overwrite existing indices. */\n\toverwrite?: boolean;\n}\n\nexport const WELD_DEFAULTS: Required<WeldOptions> = {\n\ttolerance: Tolerance.DEFAULT,\n\toverwrite: true,\n};\n\n/**\n * Index {@link Primitive Primitives} and (optionally) merge similar vertices. When merged\n * and indexed, data is shared more efficiently between vertices. File size can\n * be reduced, and the GPU can sometimes use the vertex cache more efficiently.\n *\n * When welding, the 'tolerance' threshold determines which vertices qualify for\n * welding based on distance between the vertices as a fraction of the primitive's\n * bounding box (AABB). For example, tolerance=0.01 welds vertices within +/-1%\n * of the AABB's longest dimension. Other vertex attributes are also compared\n * during welding, with attribute-specific thresholds. For --tolerance=0, geometry\n * is indexed in place, without merging.\n *\n * Example:\n *\n * ```javascript\n * import { weld } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \tweld({ tolerance: 0.001 })\n * );\n * ```\n */\nexport function weld(_options: WeldOptions = WELD_DEFAULTS): Transform {\n\tconst options = { ...WELD_DEFAULTS, ..._options } as Required<WeldOptions>;\n\n\tif (options.tolerance > 0.1 || options.tolerance < 0) {\n\t\tthrow new Error(`${NAME}: Requires 0 ≤ tolerance ≤ 0.1`);\n\t}\n\n\treturn createTransform(NAME, async (doc: Document, context?: TransformContext): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tweldPrimitive(doc, prim, options);\n\t\t\t}\n\t\t}\n\n\t\t// TODO(perf): Suppose we just invoked simplify(), and dedup is not explicitly\n\t\t// in the transform stack .... now we are going to run it twice!\n\t\tif (!isTransformPending(context, NAME, 'dedup')) {\n\t\t\tawait doc.transform(dedup({ propertyTypes: [PropertyType.ACCESSOR] }));\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\n/**\n * Index a {@link Primitive} and (optionally) weld similar vertices. When merged\n * and indexed, data is shared more efficiently between vertices. File size can\n * be reduced, and the GPU can sometimes use the vertex cache more efficiently.\n *\n * When welding, the 'tolerance' threshold determines which vertices qualify for\n * welding based on distance between the vertices as a fraction of the primitive's\n * bounding box (AABB). For example, tolerance=0.01 welds vertices within +/-1%\n * of the AABB's longest dimension. Other vertex attributes are also compared\n * during welding, with attribute-specific thresholds. For --tolerance=0, geometry\n * is indexed in place, without merging.\n *\n * Example:\n *\n * ```javascript\n * import { weldPrimitive } from '@gltf-transform/functions';\n *\n * const mesh = document.getRoot().listMeshes()\n * \t.find((mesh) => mesh.getName() === 'Gizmo');\n *\n * for (const prim of mesh.listPrimitives()) {\n *   weldPrimitive(document, prim, {tolerance: 0.0001});\n * }\n * ```\n */\nexport function weldPrimitive(doc: Document, prim: Primitive, options: Required<WeldOptions>): void {\n\tif (prim.getIndices() && !options.overwrite) return;\n\tif (prim.getMode() === Primitive.Mode.POINTS) return;\n\tif (options.tolerance === 0) {\n\t\t_indexPrimitive(doc, prim);\n\t} else {\n\t\t_weldPrimitive(doc, prim, options);\n\t}\n}\n\n/** @internal Adds indices, if missing. Does not merge vertices. */\nfunction _indexPrimitive(doc: Document, prim: Primitive): void {\n\t// No need to overwrite here, even if options.overwrite=true.\n\tif (prim.getIndices()) return;\n\n\tconst attr = prim.listAttributes()[0];\n\tconst numVertices = attr.getCount();\n\tconst buffer = attr.getBuffer();\n\tconst indices = doc\n\t\t.createAccessor()\n\t\t.setBuffer(buffer)\n\t\t.setType(Accessor.Type.SCALAR)\n\t\t.setArray(createIndices(numVertices));\n\tprim.setIndices(indices);\n}\n\n/** @internal Weld and merge, combining vertices that are similar on all vertex attributes. */\nfunction _weldPrimitive(doc: Document, prim: Primitive, options: Required<WeldOptions>): void {\n\tconst logger = doc.getLogger();\n\n\tconst srcPosition = prim.getAttribute('POSITION')!;\n\tconst srcIndices = prim.getIndices() || doc.createAccessor().setArray(createIndices(srcPosition.getCount()));\n\tconst uniqueIndices = new Uint32Array(new Set(srcIndices.getArray()!));\n\n\t// (1) Compute per-attribute tolerances, pre-sort vertices.\n\n\tconst tolerance = Math.max(options.tolerance, Number.EPSILON);\n\tconst attributeTolerance: Record<string, number> = {};\n\tfor (const semantic of prim.listSemantics()) {\n\t\tconst attribute = prim.getAttribute(semantic)!;\n\t\tattributeTolerance[semantic] = getAttributeTolerance(semantic, attribute, tolerance);\n\t}\n\n\tlogger.debug(`${NAME}: Tolerance thresholds: ${formatKV(attributeTolerance)}`);\n\n\tconst posA: vec3 = [0, 0, 0];\n\tconst posB: vec3 = [0, 0, 0];\n\n\tuniqueIndices.sort((a, b) => {\n\t\tsrcPosition.getElement(a, posA);\n\t\tsrcPosition.getElement(b, posB);\n\t\treturn posA[0] > posB[0] ? 1 : -1;\n\t});\n\n\t// (2) Compare and identify vertices to weld. Use sort to keep iterations below O(n²),\n\n\tconst weldMap = createIndices(uniqueIndices.length); // oldIndex → oldCommonIndex\n\tconst writeMap = createIndices(uniqueIndices.length); // oldIndex → newIndex\n\n\tconst srcVertexCount = srcPosition.getCount();\n\tlet dstVertexCount = 0;\n\tlet backIters = 0;\n\n\tfor (let i = 0; i < uniqueIndices.length; i++) {\n\t\tconst a = uniqueIndices[i];\n\n\t\tfor (let j = i - 1; j >= 0; j--) {\n\t\t\tconst b = weldMap[uniqueIndices[j]];\n\n\t\t\tsrcPosition.getElement(a, posA);\n\t\t\tsrcPosition.getElement(b, posB);\n\n\t\t\t// Sort order allows early exit on X-axis distance.\n\t\t\tif (Math.abs(posA[0] - posB[0]) > attributeTolerance['POSITION']) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbackIters++;\n\n\t\t\t// Weld if base attributes and morph target attributes match.\n\t\t\tconst isBaseMatch = prim.listSemantics().every((semantic) => {\n\t\t\t\tconst attribute = prim.getAttribute(semantic)!;\n\t\t\t\tconst tolerance = attributeTolerance[semantic];\n\t\t\t\treturn compareAttributes(attribute, a, b, tolerance, semantic);\n\t\t\t});\n\t\t\tconst isTargetMatch = prim.listTargets().every((target) => {\n\t\t\t\treturn target.listSemantics().every((semantic) => {\n\t\t\t\t\tconst attribute = target.getAttribute(semantic)!;\n\t\t\t\t\tconst tolerance = attributeTolerance[semantic];\n\t\t\t\t\treturn compareAttributes(attribute, a, b, tolerance, semantic);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tif (isBaseMatch && isTargetMatch) {\n\t\t\t\tweldMap[a] = b;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Output the vertex if we didn't find a match, else record the index of the match.\n\t\tif (weldMap[a] === a) {\n\t\t\twriteMap[a] = dstVertexCount++; // note: reorders the primitive on x-axis sort.\n\t\t} else {\n\t\t\twriteMap[a] = writeMap[weldMap[a]];\n\t\t}\n\t}\n\n\tlogger.debug(`${NAME}: Iterations per vertex: ${Math.round(backIters / uniqueIndices.length)} (avg)`);\n\tlogger.debug(`${NAME}: ${formatDeltaOp(srcVertexCount, dstVertexCount)} vertices.`);\n\n\t// (3) Update indices.\n\n\tconst dstIndicesCount = srcIndices.getCount(); // # primitives does not change.\n\tconst dstIndicesArray = createIndices(dstIndicesCount, uniqueIndices.length);\n\tfor (let i = 0; i < dstIndicesCount; i++) {\n\t\tdstIndicesArray[i] = writeMap[srcIndices.getScalar(i)];\n\t}\n\tprim.setIndices(srcIndices.clone().setArray(dstIndicesArray));\n\tif (srcIndices.listParents().length === 1) srcIndices.dispose();\n\n\t// (4) Update vertex attributes.\n\n\tfor (const srcAttr of prim.listAttributes()) {\n\t\tswapAttributes(prim, srcAttr, writeMap, dstVertexCount);\n\t}\n\tfor (const target of prim.listTargets()) {\n\t\tfor (const srcAttr of target.listAttributes()) {\n\t\t\tswapAttributes(target, srcAttr, writeMap, dstVertexCount);\n\t\t}\n\t}\n}\n\n/** Creates a new TypedArray of the same type as an original, with a new length. */\nfunction createArrayOfType<T extends TypedArray>(array: T, length: number): T {\n\tconst ArrayCtor = array.constructor as new (length: number) => T;\n\treturn new ArrayCtor(length);\n}\n\n/** Replaces an {@link Attribute}, creating a new one with the given elements. */\nfunction swapAttributes(\n\tparent: Primitive | PrimitiveTarget,\n\tsrcAttr: Accessor,\n\treorder: Uint32Array | Uint16Array,\n\tdstCount: number\n): void {\n\tconst dstAttrArray = createArrayOfType(srcAttr.getArray()!, dstCount * srcAttr.getElementSize());\n\tconst dstAttr = srcAttr.clone().setArray(dstAttrArray);\n\tconst done = new Uint8Array(dstCount);\n\n\tfor (let i = 0, el = [] as number[]; i < reorder.length; i++) {\n\t\tif (!done[reorder[i]]) {\n\t\t\tdstAttr.setElement(reorder[i], srcAttr.getElement(i, el));\n\t\t\tdone[reorder[i]] = 1;\n\t\t}\n\t}\n\n\tparent.swap(srcAttr, dstAttr);\n\n\t// Clean up.\n\tif (srcAttr.listParents().length === 1) srcAttr.dispose();\n}\n\nconst _a = [] as number[];\nconst _b = [] as number[];\n\n/** Computes a per-attribute tolerance, based on domain and usage of the attribute. */\nfunction getAttributeTolerance(semantic: string, attribute: Accessor, tolerance: number): number {\n\t// Attributes like NORMAL and COLOR_# do not vary in range like POSITION,\n\t// so do not apply the given tolerance factor to these attributes.\n\tif (semantic === 'NORMAL' || semantic === 'TANGENT') return Tolerance.NORMAL;\n\tif (semantic.startsWith('COLOR_')) return Tolerance.COLOR;\n\tif (semantic.startsWith('TEXCOORD_')) return Tolerance.TEXCOORD;\n\tif (semantic.startsWith('JOINTS_')) return Tolerance.JOINTS;\n\tif (semantic.startsWith('WEIGHTS_')) return Tolerance.WEIGHTS;\n\n\t_a.length = _b.length = 0;\n\tattribute.getMinNormalized(_a);\n\tattribute.getMaxNormalized(_b);\n\tconst range = Math.max(..._b) - Math.min(..._a) || 1;\n\treturn tolerance * range;\n}\n\n/** Compares two vertex attributes against a tolerance threshold. */\nfunction compareAttributes(attribute: Accessor, a: number, b: number, tolerance: number, _semantic: string): boolean {\n\tattribute.getElement(a, _a);\n\tattribute.getElement(b, _b);\n\tfor (let i = 0, il = attribute.getElementSize(); i < il; i++) {\n\t\tif (Math.abs(_a[i] - _b[i]) > tolerance) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nfunction formatKV(kv: Record<string, unknown>): string {\n\treturn Object.entries(kv)\n\t\t.map(([k, v]) => `${k}=${v}`)\n\t\t.join(', ');\n}\n","import { Accessor, Document, Primitive, PropertyType, Transform, TransformContext } from '@gltf-transform/core';\nimport {\n\tcreateTransform,\n\tformatDeltaOp,\n\tdeepListAttributes,\n\tremapAttribute,\n\tdeepSwapAttribute,\n\tisTransformPending,\n} from './utils';\nimport { weld } from './weld';\nimport type { MeshoptSimplifier } from 'meshoptimizer';\nimport { dedup } from './dedup';\n\nconst NAME = 'simplify';\n\n/** Options for the {@link simplify} function. */\nexport interface SimplifyOptions {\n\t/** MeshoptSimplifier instance. */\n\tsimplifier: unknown;\n\t/** Target ratio (0–1) of vertices to keep. Default: 0.5 (50%). */\n\tratio?: number;\n\t/** Limit on error, as a fraction of mesh radius. Default: 0.01 (1%). */\n\terror?: number;\n\t/**\n\t * Whether to lock topological borders of the mesh. May be necessary when\n\t * adjacent 'chunks' of a large mesh (e.g. terrain) share a border, helping\n\t * to ensure no seams appear.\n\t */\n\tlockBorder?: boolean;\n}\n\nexport const SIMPLIFY_DEFAULTS: Required<Omit<SimplifyOptions, 'simplifier'>> = {\n\tratio: 0.5,\n\terror: 0.001,\n\tlockBorder: false,\n};\n\n/**\n * Simplification algorithm, based on meshoptimizer, producing meshes with fewer\n * triangles and vertices. Simplification is lossy, but the algorithm aims to\n * preserve visual quality as much as possible for given parameters.\n *\n * The algorithm aims to reach the target 'ratio', while minimizing error. If\n * error exceeds the specified 'error' threshold, the algorithm will quit\n * before reaching the target ratio. Examples:\n *\n * - ratio=0.5, error=0.001: Aims for 50% simplification, constrained to 0.1% error.\n * - ratio=0.5, error=1: Aims for 50% simplification, unconstrained by error.\n * - ratio=0.0, error=0.01: Aims for maximum simplification, constrained to 1% error.\n *\n * Topology, particularly split vertices, will also limit the simplifier. For\n * best results, apply a {@link weld} operation before simplification.\n *\n * Example:\n *\n * ```javascript\n * import { simplify, weld } from '@gltf-transform/functions';\n * import { MeshoptSimplifier } from 'meshoptimizer';\n *\n * await document.transform(\n *   weld({ tolerance: 0.0001 }),\n *   simplify({ simplifier: MeshoptSimplifier, ratio: 0.75, error: 0.001 })\n * );\n * ```\n *\n * References:\n * - https://github.com/zeux/meshoptimizer/blob/master/js/README.md#simplifier\n */\nexport const simplify = (_options: SimplifyOptions): Transform => {\n\tconst options = { ...SIMPLIFY_DEFAULTS, ..._options } as Required<SimplifyOptions>;\n\n\tconst simplifier = options.simplifier as typeof MeshoptSimplifier | undefined;\n\n\tif (!simplifier) {\n\t\tthrow new Error(`${NAME}: simplifier dependency required — install \"meshoptimizer\".`);\n\t}\n\n\treturn createTransform(NAME, async (document: Document, context?: TransformContext): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\n\t\tawait simplifier.ready;\n\t\tawait document.transform(weld({ overwrite: false }));\n\n\t\t// Simplify mesh primitives.\n\t\tfor (const mesh of document.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tif (prim.getMode() !== Primitive.Mode.TRIANGLES) {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`${NAME}: Skipping primitive of mesh \"${mesh.getName()}\": Requires TRIANGLES draw mode.`\n\t\t\t\t\t);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsimplifyPrimitive(document, prim, options);\n\t\t\t}\n\t\t}\n\n\t\t// Where multiple primitive indices point into the same vertex streams, simplification\n\t\t// may write duplicate streams. Find and remove the duplicates after processing.\n\t\tif (!isTransformPending(context, NAME, 'dedup')) {\n\t\t\tawait document.transform(dedup({ propertyTypes: [PropertyType.ACCESSOR] }));\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n};\n\nexport function simplifyPrimitive(document: Document, prim: Primitive, _options: SimplifyOptions): Primitive {\n\tconst options = { ...SIMPLIFY_DEFAULTS, ..._options } as Required<SimplifyOptions>;\n\tconst simplifier = options.simplifier as typeof MeshoptSimplifier;\n\n\tconst logger = document.getLogger();\n\tconst position = prim.getAttribute('POSITION')!;\n\tconst srcIndices = prim.getIndices()!;\n\tconst srcVertexCount = position.getCount();\n\n\tlet positionArray = position.getArray()!;\n\tlet indicesArray = srcIndices.getArray()!;\n\n\t// (1) Gather attributes and indices in Meshopt-compatible format.\n\n\tif (position.getComponentType() !== Accessor.ComponentType.FLOAT) {\n\t\tif (position.getNormalized()) {\n\t\t\tconst src = positionArray;\n\t\t\tconst dst = new Float32Array(src.length);\n\n\t\t\t// Dequantize.\n\t\t\tfor (let i = 0, il = position.getCount(), el = [] as number[]; i < il; i++) {\n\t\t\t\tel = position.getElement(i, el);\n\t\t\t\tposition.setArray(dst).setElement(i, el).setArray(src);\n\t\t\t}\n\n\t\t\tpositionArray = dst;\n\t\t} else {\n\t\t\tpositionArray = new Float32Array(positionArray);\n\t\t}\n\t}\n\n\tif (srcIndices.getComponentType() !== Accessor.ComponentType.UNSIGNED_INT) {\n\t\tindicesArray = new Uint32Array(indicesArray);\n\t}\n\n\t// (2) Run simplification.\n\n\tconst targetCount = Math.floor((options.ratio * srcVertexCount) / 3) * 3;\n\tconst [dstIndicesArray, error] = simplifier.simplify(\n\t\tindicesArray as Uint32Array,\n\t\tpositionArray as Float32Array,\n\t\t3,\n\t\ttargetCount,\n\t\toptions.error,\n\t\toptions.lockBorder ? ['LockBorder'] : []\n\t);\n\n\tconst [remap, unique] = simplifier.compactMesh(dstIndicesArray);\n\n\tlogger.debug(`${NAME}: ${formatDeltaOp(position.getCount(), unique)} vertices, error: ${error.toFixed(4)}.`);\n\n\t// (3) Write vertex attributes.\n\n\tfor (const srcAttribute of deepListAttributes(prim)) {\n\t\tconst dstAttribute = srcAttribute.clone();\n\t\tremapAttribute(dstAttribute, remap, unique);\n\t\tdeepSwapAttribute(prim, srcAttribute, dstAttribute);\n\t\tif (srcAttribute.listParents().length === 1) srcAttribute.dispose();\n\t}\n\n\t// (4) Write indices.\n\n\tconst dstIndices = srcIndices.clone();\n\tdstIndices.setArray(srcVertexCount <= 65534 ? new Uint16Array(dstIndicesArray) : dstIndicesArray);\n\tprim.setIndices(dstIndices);\n\tif (srcIndices.listParents().length === 1) srcIndices.dispose();\n\n\treturn prim;\n}\n","import { Document, MathUtils, Transform } from '@gltf-transform/core';\nimport { createTransform } from './utils';\n\nconst NAME = 'sparse';\n\n/** Options for the {@link sparse} function. */\nexport interface SparseOptions {\n\t/**\n\t * Threshold ratio used to determine when an accessor should be sparse.\n\t * Default: 1 / 3.\n\t */\n\tratio: number;\n}\n\nconst SPARSE_DEFAULTS: Required<SparseOptions> = {\n\tratio: 1 / 3,\n};\n\n/**\n * Scans all {@link Accessor Accessors} in the Document, detecting whether each Accessor\n * would benefit from sparse data storage. Currently, sparse data storage is used only\n * when many values (≥ ratio) are zeroes. Particularly for assets using morph target\n * (\"shape key\") animation, sparse data storage may significantly reduce file sizes.\n *\n * Example:\n *\n * ```ts\n * import { sparse } from '@gltf-transform/functions';\n *\n * accessor.getArray(); // → [ 0, 0, 0, 0, 0, 25.0, 0, 0, ... ]\n * accessor.getSparse(); // → false\n *\n * await document.transform(sparse({ratio: 1 / 10}));\n *\n * accessor.getSparse(); // → true\n * ```\n *\n * @experimental\n */\nexport function sparse(_options: SparseOptions = SPARSE_DEFAULTS): Transform {\n\tconst options = { ...SPARSE_DEFAULTS, ..._options } as Required<SparseOptions>;\n\n\tconst ratio = options.ratio;\n\tif (ratio < 0 || ratio > 1) {\n\t\tthrow new Error(`${NAME}: Ratio must be between 0 and 1.`);\n\t}\n\n\treturn createTransform(NAME, (document: Document): void => {\n\t\tconst root = document.getRoot();\n\t\tconst logger = document.getLogger();\n\n\t\tlet modifiedCount = 0;\n\n\t\tfor (const accessor of root.listAccessors()) {\n\t\t\tconst count = accessor.getCount();\n\t\t\tconst base = Array(accessor.getElementSize()).fill(0);\n\t\t\tconst el = Array(accessor.getElementSize()).fill(0);\n\n\t\t\tlet nonZeroCount = 0;\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\taccessor.getElement(i, el);\n\t\t\t\tif (!MathUtils.eq(el, base, 0)) nonZeroCount++;\n\t\t\t\tif (nonZeroCount / count >= ratio) break;\n\t\t\t}\n\n\t\t\tconst sparse = nonZeroCount / count < ratio;\n\t\t\tif (sparse !== accessor.getSparse()) {\n\t\t\t\taccessor.setSparse(sparse);\n\t\t\t\tmodifiedCount++;\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Updated ${modifiedCount} accessors.`);\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n","import { Document, Texture } from '@gltf-transform/core';\nimport { Material, TextureChannel, PropertyType } from '@gltf-transform/core';\n\n/**\n * Returns a list of {@link TextureChannel TextureChannels} used by the given\n * texture. Determination is based only on the _role_ of the textures, e.g.\n * a texture used for the `occlusionTexture` will have (at least) a red channel\n * in use. See {@link getTextureChannelMask} for bitmask alternative.\n *\n * Example:\n *\n * ```js\n * const channels = listTextureChannels(texture);\n * if (channels.includes(TextureChannel.R)) {\n *   console.log('texture red channel used');\n * }\n */\nexport function listTextureChannels(texture: Texture): TextureChannel[] {\n\tconst mask = getTextureChannelMask(texture);\n\tconst channels = [];\n\tif (mask & TextureChannel.R) channels.push(TextureChannel.R);\n\tif (mask & TextureChannel.G) channels.push(TextureChannel.G);\n\tif (mask & TextureChannel.B) channels.push(TextureChannel.B);\n\tif (mask & TextureChannel.A) channels.push(TextureChannel.A);\n\treturn channels;\n}\n\n/**\n * Returns bitmask of all {@link TextureChannel TextureChannels} used by the\n * given texture. Determination is based only on the _role_ of the textures, e.g.\n * a texture used for the `occlusionTexture` will have (at least) a red channel.\n * See {@link listTextureChannels} for an array alternative.\n *\n * Example:\n *\n * ```js\n * const mask = getTextureChannelMask(texture);\n * if (mask & TextureChannel.R) {\n *   console.log('texture red channel used');\n * }\n * ```\n */\nexport function getTextureChannelMask(texture: Texture): number {\n\tconst document = Document.fromGraph(texture.getGraph())!;\n\tlet mask = 0x0000;\n\tfor (const edge of document.getGraph().listParentEdges(texture)) {\n\t\tconst parent = edge.getParent();\n\t\tlet { channels } = edge.getAttributes() as { channels: number | undefined };\n\n\t\tif (\n\t\t\tchannels &&\n\t\t\tedge.getName() === 'baseColorTexture' &&\n\t\t\tparent instanceof Material &&\n\t\t\tparent.getAlphaMode() === Material.AlphaMode.OPAQUE\n\t\t) {\n\t\t\tchannels &= ~TextureChannel.A;\n\t\t}\n\n\t\tif (channels) {\n\t\t\tmask |= channels;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (parent.propertyType !== PropertyType.ROOT) {\n\t\t\tdocument.getLogger().warn(`Missing attribute \".channels\" on edge, \"${edge.getName()}\".`);\n\t\t}\n\t}\n\treturn mask;\n}\n","import { Document, Texture } from '@gltf-transform/core';\n\n/**\n * Returns names of all texture slots using the given texture.\n *\n * Example:\n *\n * ```js\n * const slots = listTextureSlots(texture);\n * // → ['occlusionTexture', 'metallicRoughnesTexture']\n * ```\n */\nexport function listTextureSlots(texture: Texture): string[] {\n\tconst document = Document.fromGraph(texture.getGraph())!;\n\tconst root = document.getRoot();\n\tconst slots = texture\n\t\t.getGraph()\n\t\t.listParentEdges(texture)\n\t\t.filter((edge) => edge.getParent() !== root)\n\t\t.map((edge) => edge.getName());\n\treturn Array.from(new Set(slots));\n}\n","import ndarray from 'ndarray';\nimport { lanczos2, lanczos3 } from 'ndarray-lanczos';\nimport { getPixels, savePixels } from 'ndarray-pixels';\nimport type { Document, Transform, vec2 } from '@gltf-transform/core';\nimport { listTextureSlots } from './list-texture-slots';\nimport { createTransform } from './utils';\n\nconst NAME = 'textureResize';\n\n/** Options for the {@link textureResize} function. */\nexport interface TextureResizeOptions {\n\t/**\n\t * Maximum width/height to enforce, preserving aspect ratio. For example,\n\t * a 4096x8192 texture, resized with limit [2048, 2048] will be reduced\n\t * to 1024x2048.\n\t */\n\tsize: vec2;\n\t/** Resampling filter method. LANCZOS3 is sharper, LANCZOS2 is smoother. */\n\tfilter?: TextureResizeFilter;\n\t/** Pattern identifying textures to resize, matched to name or URI. */\n\tpattern?: RegExp | null;\n\t/** Pattern to match slots usage for resizing. */\n\tslots?: RegExp | null;\n}\n\n/** Resampling filter methods. LANCZOS3 is sharper, LANCZOS2 is smoother. */\nexport enum TextureResizeFilter {\n\t/** Lanczos3 (sharp) */\n\tLANCZOS3 = 'lanczos3',\n\t/** Lanczos2 (smooth) */\n\tLANCZOS2 = 'lanczos2',\n}\n\nexport const TEXTURE_RESIZE_DEFAULTS: TextureResizeOptions = {\n\tsize: [2048, 2048],\n\tfilter: TextureResizeFilter.LANCZOS3,\n\tpattern: null,\n\tslots: null,\n};\n\n/**\n * Resize PNG or JPEG {@link Texture Textures}, with {@link https://en.wikipedia.org/wiki/Lanczos_algorithm Lanczos filtering}.\n *\n * Implementation provided by {@link https://github.com/donmccurdy/ndarray-lanczos ndarray-lanczos}\n * package, which works in Web and Node.js environments. For a faster and more robust implementation\n * based on Sharp (available only in Node.js), use {@link textureCompress} with the 'resize' option.\n */\nexport function textureResize(_options: TextureResizeOptions = TEXTURE_RESIZE_DEFAULTS): Transform {\n\tconst options = { ...TEXTURE_RESIZE_DEFAULTS, ..._options } as Required<TextureResizeOptions>;\n\n\treturn createTransform(NAME, async (doc: Document): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\n\t\tfor (const texture of doc.getRoot().listTextures()) {\n\t\t\tconst name = texture.getName();\n\t\t\tconst uri = texture.getURI();\n\t\t\tconst match = !options.pattern || options.pattern.test(name) || options.pattern.test(uri);\n\t\t\tif (!match) {\n\t\t\t\tlogger.debug(`${NAME}: Skipping, excluded by \"pattern\" parameter.`);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (texture.getMimeType() !== 'image/png' && texture.getMimeType() !== 'image/jpeg') {\n\t\t\t\tlogger.warn(`${NAME}: Skipping, unsupported texture type \"${texture.getMimeType()}\".`);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst slots = listTextureSlots(texture);\n\t\t\tif (options.slots && !slots.some((slot) => options.slots?.test(slot))) {\n\t\t\t\tlogger.debug(`${NAME}: Skipping, [${slots.join(', ')}] excluded by \"slots\" parameter.`);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst [maxWidth, maxHeight] = options.size;\n\t\t\tconst [srcWidth, srcHeight] = texture.getSize()!;\n\n\t\t\tif (srcWidth <= maxWidth && srcHeight <= maxHeight) {\n\t\t\t\tlogger.debug(`${NAME}: Skipping, not within size range.`);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet dstWidth = srcWidth;\n\t\t\tlet dstHeight = srcHeight;\n\n\t\t\tif (dstWidth > maxWidth) {\n\t\t\t\tdstHeight = Math.floor(dstHeight * (maxWidth / dstWidth));\n\t\t\t\tdstWidth = maxWidth;\n\t\t\t}\n\n\t\t\tif (dstHeight > maxHeight) {\n\t\t\t\tdstWidth = Math.floor(dstWidth * (maxHeight / dstHeight));\n\t\t\t\tdstHeight = maxHeight;\n\t\t\t}\n\n\t\t\tconst srcImage = texture.getImage()!;\n\t\t\tconst srcPixels = (await getPixels(srcImage, texture.getMimeType())) as ndarray.NdArray<Uint8ClampedArray>;\n\t\t\tconst dstPixels = ndarray(new Uint8Array(dstWidth * dstHeight * 4), [dstWidth, dstHeight, 4]);\n\n\t\t\tlogger.debug(`${NAME}: Resizing \"${uri || name}\", ${srcPixels.shape} → ${dstPixels.shape}...`);\n\t\t\tlogger.debug(`${NAME}: Slots → [${slots.join(', ')}]`);\n\n\t\t\ttry {\n\t\t\t\toptions.filter === TextureResizeFilter.LANCZOS3\n\t\t\t\t\t? lanczos3(srcPixels, dstPixels)\n\t\t\t\t\t: lanczos2(srcPixels, dstPixels);\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof Error) {\n\t\t\t\t\tlogger.warn(`${NAME}: Failed to resize \"${uri || name}\": \"${e.message}\".`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\ttexture.setImage(await savePixels(dstPixels, texture.getMimeType()));\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n","import { BufferUtils, Document, ImageUtils, Texture, TextureChannel, Transform, vec2 } from '@gltf-transform/core';\nimport { EXTTextureAVIF, EXTTextureWebP } from '@gltf-transform/extensions';\nimport { getTextureChannelMask } from './list-texture-channels';\nimport { listTextureSlots } from './list-texture-slots';\nimport type sharp from 'sharp';\nimport { createTransform, formatBytes } from './utils';\nimport { TextureResizeFilter } from './texture-resize';\n\nconst NAME = 'textureCompress';\n\ntype Format = (typeof FORMATS)[number];\nconst FORMATS = ['jpeg', 'png', 'webp', 'avif'] as const;\nconst SUPPORTED_MIME_TYPES = ['image/jpeg', 'image/png', 'image/webp', 'image/avif'];\n\nexport interface TextureCompressOptions {\n\t/** Instance of the Sharp encoder, which must be installed from the\n\t * 'sharp' package and provided by the caller.\n\t */\n\tencoder: unknown;\n\t/**\n\t * Target image format. If specified, included textures in other formats\n\t * will be converted. Default: original format.\n\t */\n\ttargetFormat?: Format;\n\t/**\n\t * Resizes textures to given maximum width/height, preserving aspect ratio.\n\t * For example, a 4096x8192 texture, resized with limit [2048, 2048] will\n\t * be reduced to 1024x2048.\n\t */\n\tresize?: vec2;\n\t/** Interpolation used if resizing. Default: TextureResizeFilter.LANCZOS3. */\n\tresizeFilter?: TextureResizeFilter;\n\t/** Pattern identifying textures to compress, matched to name or URI. */\n\tpattern?: RegExp | null;\n\t/** Pattern matching the format(s) to be compressed or converted. */\n\tformats?: RegExp | null;\n\t/** Pattern matching the material texture slot(s) to be compressed or converted. */\n\tslots?: RegExp | null;\n\n\t/** Quality, 1-100. Default: auto. */\n\tquality?: number | null;\n\t/** Level of CPU effort to reduce file size, 0-100. PNG, WebP, and AVIF only. Default: auto. */\n\teffort?: number | null;\n\t/** Use lossless compression mode. WebP and AVIF only. Default: false. */\n\tlossless?: boolean;\n\t/** Use near lossless compression mode. WebP only. Default: false. */\n\tnearLossless?: boolean;\n}\n\nexport const TEXTURE_COMPRESS_DEFAULTS: Required<Omit<TextureCompressOptions, 'resize' | 'targetFormat' | 'encoder'>> =\n\t{\n\t\tresizeFilter: TextureResizeFilter.LANCZOS3,\n\t\tpattern: null,\n\t\tformats: null,\n\t\tslots: null,\n\t\tquality: null,\n\t\teffort: null,\n\t\tlossless: false,\n\t\tnearLossless: false,\n\t};\n\n/**\n * Optimizes images, optionally resizing or converting to JPEG, PNG, WebP, or AVIF formats.\n *\n * Requires `sharp`, and is available only in Node.js environments.\n *\n * Example:\n *\n * ```javascript\n * import sharp from 'sharp';\n * import { textureCompress } from '@gltf-transform/functions';\n *\n * // (A) Optimize without conversion.\n * await document.transform(\n * \ttextureCompress({encoder: sharp})\n * );\n *\n * // (B) Optimize and convert images to WebP.\n * await document.transform(\n * \ttextureCompress({\n * \t\tencoder: sharp,\n * \t\tcodec: 'webp',\n * \t\tformats: /.*\\/\n * \t})\n * );\n * ```\n */\nexport const textureCompress = function (_options: TextureCompressOptions): Transform {\n\tconst options = { ...TEXTURE_COMPRESS_DEFAULTS, ..._options } as Required<TextureCompressOptions>;\n\tconst encoder = options.encoder as typeof sharp | null;\n\tconst targetFormat = options.targetFormat as Format | undefined;\n\tconst resize = options.resize as vec2 | undefined;\n\tconst resizeFilter = options.resizeFilter as TextureResizeFilter;\n\tconst patternRe = options.pattern;\n\tconst formatsRe = options.formats;\n\tconst slotsRe = options.slots;\n\n\tif (!encoder) {\n\t\tthrow new Error(`${targetFormat}: encoder dependency required — install \"sharp\".`);\n\t}\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\t\tconst textures = document.getRoot().listTextures();\n\n\t\tawait Promise.all(\n\t\t\ttextures.map(async (texture, textureIndex) => {\n\t\t\t\tconst slots = listTextureSlots(texture);\n\t\t\t\tconst channels = getTextureChannelMask(texture);\n\t\t\t\tconst textureLabel =\n\t\t\t\t\ttexture.getURI() ||\n\t\t\t\t\ttexture.getName() ||\n\t\t\t\t\t`${textureIndex + 1}/${document.getRoot().listTextures().length}`;\n\t\t\t\tconst prefix = `${NAME}(${textureLabel})`;\n\n\t\t\t\t// FILTER: Exclude textures that don't match (a) 'slots' or (b) expected formats.\n\n\t\t\t\tif (!SUPPORTED_MIME_TYPES.includes(texture.getMimeType())) {\n\t\t\t\t\tlogger.debug(`${prefix}: Skipping, unsupported texture type \"${texture.getMimeType()}\".`);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (patternRe && !patternRe.test(texture.getName()) && !patternRe.test(texture.getURI())) {\n\t\t\t\t\tlogger.debug(`${prefix}: Skipping, excluded by \"pattern\" parameter.`);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (formatsRe && !formatsRe.test(texture.getMimeType())) {\n\t\t\t\t\tlogger.debug(`${prefix}: Skipping, \"${texture.getMimeType()}\" excluded by \"formats\" parameter.`);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (slotsRe && slots.length && !slots.some((slot) => slotsRe.test(slot))) {\n\t\t\t\t\tlogger.debug(`${prefix}: Skipping, [${slots.join(', ')}] excluded by \"slots\" parameter.`);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (options.targetFormat === 'jpeg' && channels & TextureChannel.A) {\n\t\t\t\t\tlogger.warn(`${prefix}: Skipping, [${slots.join(', ')}] requires alpha channel.`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst srcFormat = getFormat(texture);\n\t\t\t\tconst dstFormat = targetFormat || srcFormat;\n\t\t\t\tconst srcMimeType = texture.getMimeType();\n\t\t\t\tconst dstMimeType = `image/${dstFormat}`;\n\n\t\t\t\tlogger.debug(`${prefix}: Format = ${srcFormat} → ${dstFormat}`);\n\t\t\t\tlogger.debug(`${prefix}: Slots = [${slots.join(', ')}]`);\n\n\t\t\t\t// COMPRESS: Run compression library.\n\n\t\t\t\tlet encoderOptions: sharp.JpegOptions | sharp.PngOptions | sharp.WebpOptions | sharp.AvifOptions = {};\n\n\t\t\t\tswitch (dstFormat) {\n\t\t\t\t\tcase 'jpeg':\n\t\t\t\t\t\tencoderOptions = { quality: options.quality } as sharp.JpegOptions;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'png':\n\t\t\t\t\t\tencoderOptions = {\n\t\t\t\t\t\t\tquality: options.quality,\n\t\t\t\t\t\t\teffort: remap(options.effort, 100, 10),\n\t\t\t\t\t\t} as sharp.PngOptions;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'webp':\n\t\t\t\t\t\tencoderOptions = {\n\t\t\t\t\t\t\tquality: options.quality,\n\t\t\t\t\t\t\teffort: remap(options.effort, 100, 6),\n\t\t\t\t\t\t\tlossless: options.lossless,\n\t\t\t\t\t\t\tnearLossless: options.nearLossless,\n\t\t\t\t\t\t} as sharp.WebpOptions;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'avif':\n\t\t\t\t\t\tencoderOptions = {\n\t\t\t\t\t\t\tquality: options.quality,\n\t\t\t\t\t\t\teffort: remap(options.effort, 100, 9),\n\t\t\t\t\t\t\tlossless: options.lossless,\n\t\t\t\t\t\t} as sharp.AvifOptions;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tconst srcImage = texture.getImage()!;\n\t\t\t\tconst instance = encoder(srcImage).toFormat(dstFormat, encoderOptions);\n\n\t\t\t\t// Resize.\n\t\t\t\tif (resize) {\n\t\t\t\t\tinstance.resize(resize[0], resize[1], {\n\t\t\t\t\t\tfit: 'inside',\n\t\t\t\t\t\tkernel: resizeFilter,\n\t\t\t\t\t\twithoutEnlargement: true,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst dstImage = BufferUtils.toView(await instance.toBuffer());\n\t\t\t\ttexture.setImage(dstImage);\n\n\t\t\t\t// Update path and MIME type if target and source formats differ.\n\t\t\t\tif (srcMimeType !== dstMimeType) {\n\t\t\t\t\tconst srcExtension = ImageUtils.mimeTypeToExtension(srcMimeType);\n\t\t\t\t\tconst dstExtension = ImageUtils.mimeTypeToExtension(dstMimeType);\n\t\t\t\t\tconst dstURI = texture.getURI().replace(new RegExp(`\\\\.${srcExtension}$`), `.${dstExtension}`);\n\t\t\t\t\ttexture.setMimeType(dstMimeType).setURI(dstURI);\n\t\t\t\t}\n\n\t\t\t\tconst srcByteLength = srcImage.byteLength;\n\t\t\t\tconst dstByteLength = dstImage.byteLength;\n\t\t\t\tlogger.debug(`${prefix}: Size = ${formatBytes(srcByteLength)} → ${formatBytes(dstByteLength)}`);\n\t\t\t})\n\t\t);\n\n\t\t// Attach EXT_texture_webp if needed.\n\t\tconst webpExtension = document.createExtension(EXTTextureWebP);\n\t\tif (textures.some((texture) => texture.getMimeType() === 'image/webp')) {\n\t\t\twebpExtension.setRequired(true);\n\t\t} else {\n\t\t\twebpExtension.dispose();\n\t\t}\n\n\t\t// Attach EXT_texture_avif if needed.\n\t\tconst avifExtension = document.createExtension(EXTTextureAVIF);\n\t\tif (textures.some((texture) => texture.getMimeType() === 'image/avif')) {\n\t\t\tavifExtension.setRequired(true);\n\t\t} else {\n\t\t\tavifExtension.dispose();\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n};\n\nfunction getFormat(texture: Texture): Format {\n\tconst mimeType = texture.getMimeType();\n\tconst format = mimeType.split('/').pop() as Format | undefined;\n\tif (!format || !FORMATS.includes(format)) {\n\t\tthrow new Error(`Unknown MIME type \"${mimeType}\".`);\n\t}\n\treturn format;\n}\n\nfunction remap(value: number | null | undefined, srcMax: number, dstMax: number): number | null {\n\tif (value == null) return null;\n\treturn Math.round((value / srcMax) * dstMax);\n}\n","import { Accessor, Document, ILogger, Primitive, Transform, TypedArray, uuid } from '@gltf-transform/core';\nimport { createTransform } from './utils';\n\nconst NAME = 'tangents';\n\n/** Options for the {@link tangents} function. */\nexport interface TangentsOptions {\n\t/**\n\t * Callback function to generate tangents from position, uv, and normal attributes.\n\t * Generally, users will want to provide the `generateTangents` from the\n\t * [mikktspace](https://github.com/donmccurdy/mikktspace-wasm) library, which is not\n\t * included by default.\n\t */\n\tgenerateTangents?: (pos: Float32Array, norm: Float32Array, uv: Float32Array) => Float32Array;\n\t/** Whether to overwrite existing `TANGENT` attributes. */\n\toverwrite?: boolean;\n}\n\nconst TANGENTS_DEFAULTS: Required<Omit<TangentsOptions, 'generateTangents'>> = {\n\toverwrite: false,\n};\n\n/**\n * Generates MikkTSpace vertex tangents for mesh primitives, which may fix rendering issues\n * occuring with some baked normal maps. Requires access to the [mikktspace](https://github.com/donmccurdy/mikktspace-wasm)\n * WASM package, or equivalent.\n *\n * Example:\n *\n * ```ts\n * import { generateTangents } from 'mikktspace';\n * import { tangents } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \ttangents({generateTangents})\n * );\n * ```\n */\nexport function tangents(_options: TangentsOptions = TANGENTS_DEFAULTS): Transform {\n\tif (!_options.generateTangents) {\n\t\tthrow new Error(`${NAME}: generateTangents callback required — install \"mikktspace\".`);\n\t}\n\n\tconst options = { ...TANGENTS_DEFAULTS, ..._options } as Required<TangentsOptions>;\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst attributeIDs = new Map<TypedArray, string>();\n\t\tconst tangentCache = new Map<string, Accessor>();\n\t\tlet modified = 0;\n\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tconst meshName = mesh.getName();\n\t\t\tconst meshPrimitives = mesh.listPrimitives();\n\n\t\t\tfor (let i = 0; i < meshPrimitives.length; i++) {\n\t\t\t\tconst prim = meshPrimitives[i];\n\n\t\t\t\t// Skip primitives for which we can't compute tangents.\n\t\t\t\tif (!filterPrimitive(prim, logger, meshName, i, options.overwrite)) continue;\n\n\t\t\t\tconst texcoordSemantic = getNormalTexcoord(prim);\n\n\t\t\t\t// Nullability conditions checked by filterPrimitive() above.\n\t\t\t\tconst position = prim.getAttribute('POSITION')!.getArray()!;\n\t\t\t\tconst normal = prim.getAttribute('NORMAL')!.getArray()!;\n\t\t\t\tconst texcoord = prim.getAttribute(texcoordSemantic)!.getArray()!;\n\n\t\t\t\t// Compute UUIDs for each attribute.\n\t\t\t\tconst positionID = attributeIDs.get(position) || uuid();\n\t\t\t\tattributeIDs.set(position, positionID);\n\n\t\t\t\tconst normalID = attributeIDs.get(normal) || uuid();\n\t\t\t\tattributeIDs.set(normal, normalID);\n\n\t\t\t\tconst texcoordID = attributeIDs.get(texcoord) || uuid();\n\t\t\t\tattributeIDs.set(texcoord, texcoordID);\n\n\t\t\t\t// Dispose of previous TANGENT accessor if only used by this primitive (and Root).\n\t\t\t\tconst prevTangent = prim.getAttribute('TANGENT');\n\t\t\t\tif (prevTangent && prevTangent.listParents().length === 2) prevTangent.dispose();\n\n\t\t\t\t// If we've already computed tangents for this pos/norm/uv set, reuse them.\n\t\t\t\tconst attributeHash = `${positionID}|${normalID}|${texcoordID}`;\n\t\t\t\tlet tangent = tangentCache.get(attributeHash);\n\t\t\t\tif (tangent) {\n\t\t\t\t\tlogger.debug(`${NAME}: Found cache for primitive ${i} of mesh \"${meshName}\".`);\n\t\t\t\t\tprim.setAttribute('TANGENT', tangent);\n\t\t\t\t\tmodified++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, generate tangents with the 'mikktspace' WASM library.\n\t\t\t\tlogger.debug(`${NAME}: Generating for primitive ${i} of mesh \"${meshName}\".`);\n\t\t\t\tconst tangentBuffer = prim.getAttribute('POSITION')!.getBuffer();\n\t\t\t\tconst tangentArray = options.generateTangents(\n\t\t\t\t\tposition instanceof Float32Array ? position : new Float32Array(position),\n\t\t\t\t\tnormal instanceof Float32Array ? normal : new Float32Array(normal),\n\t\t\t\t\ttexcoord instanceof Float32Array ? texcoord : new Float32Array(texcoord)\n\t\t\t\t);\n\n\t\t\t\t// See: https://github.com/KhronosGroup/glTF-Sample-Models/issues/174\n\t\t\t\tfor (let i = 3; i < tangentArray.length; i += 4) tangentArray[i] *= -1;\n\n\t\t\t\ttangent = doc.createAccessor().setBuffer(tangentBuffer).setArray(tangentArray).setType('VEC4');\n\t\t\t\tprim.setAttribute('TANGENT', tangent);\n\n\t\t\t\ttangentCache.set(attributeHash, tangent);\n\t\t\t\tmodified++;\n\t\t\t}\n\t\t}\n\n\t\tif (!modified) {\n\t\t\tlogger.warn(`${NAME}: No qualifying primitives found. See debug output.`);\n\t\t} else {\n\t\t\tlogger.debug(`${NAME}: Complete.`);\n\t\t}\n\t});\n}\n\nfunction getNormalTexcoord(prim: Primitive): string {\n\tconst material = prim.getMaterial();\n\tif (!material) return 'TEXCOORD_0';\n\n\tconst normalTextureInfo = material.getNormalTextureInfo();\n\tif (!normalTextureInfo) return 'TEXCOORD_0';\n\n\tconst texcoord = normalTextureInfo.getTexCoord();\n\tconst semantic = `TEXCOORD_${texcoord}`;\n\tif (prim.getAttribute(semantic)) return semantic;\n\n\treturn 'TEXCOORD_0';\n}\n\nfunction filterPrimitive(prim: Primitive, logger: ILogger, meshName: string, i: number, overwrite: boolean): boolean {\n\tif (\n\t\tprim.getMode() !== Primitive.Mode.TRIANGLES ||\n\t\t!prim.getAttribute('POSITION') ||\n\t\t!prim.getAttribute('NORMAL') ||\n\t\t!prim.getAttribute('TEXCOORD_0')\n\t) {\n\t\tlogger.debug(\n\t\t\t`${NAME}: Skipping primitive ${i} of mesh \"${meshName}\": primitives must` +\n\t\t\t\t' have attributes=[POSITION, NORMAL, TEXCOORD_0] and mode=TRIANGLES.'\n\t\t);\n\t\treturn false;\n\t}\n\n\tif (prim.getAttribute('TANGENT') && !overwrite) {\n\t\tlogger.debug(`${NAME}: Skipping primitive ${i} of mesh \"${meshName}\": TANGENT found.`);\n\t\treturn false;\n\t}\n\n\tif (prim.getIndices()) {\n\t\t// TODO(feat): Do this automatically for qualifying primitives.\n\t\tlogger.warn(`${NAME}: Skipping primitive ${i} of mesh \"${meshName}\": primitives must` + ' be unwelded.');\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n","import type { Document, Transform } from '@gltf-transform/core';\nimport { KHRMaterialsUnlit } from '@gltf-transform/extensions';\n\nexport const unlit = (): Transform => {\n\treturn (doc: Document): void => {\n\t\tconst unlitExtension = doc.createExtension(KHRMaterialsUnlit) as KHRMaterialsUnlit;\n\t\tconst unlit = unlitExtension.createUnlit();\n\t\tdoc.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tmaterial.setExtension('KHR_materials_unlit', unlit);\n\t\t\t});\n\t};\n};\n","import type { Document, Transform } from '@gltf-transform/core';\nimport { createTransform } from './utils';\n\nconst NAME = 'unpartition';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface UnpartitionOptions {}\nconst UNPARTITION_DEFAULTS: Required<UnpartitionOptions> = {};\n\n/**\n * Removes partitions from the binary payload of a glTF file, so that the asset\n * contains at most one (1) `.bin` {@link Buffer}. This process reverses the\n * changes from a {@link partition} transform.\n *\n * Example:\n *\n * ```ts\n * document.getRoot().listBuffers(); // → [Buffer, Buffer, ...]\n *\n * await document.transform(unpartition());\n *\n * document.getRoot().listBuffers(); // → [Buffer]\n * ```\n */\nconst unpartition = (_options: UnpartitionOptions = UNPARTITION_DEFAULTS): Transform => {\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst options = { ...UNPARTITION_DEFAULTS, ..._options } as Required<UnpartitionOptions>;\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\n\t\tconst buffer = document.getRoot().listBuffers()[0];\n\t\tdocument\n\t\t\t.getRoot()\n\t\t\t.listAccessors()\n\t\t\t.forEach((a) => a.setBuffer(buffer));\n\t\tdocument\n\t\t\t.getRoot()\n\t\t\t.listBuffers()\n\t\t\t.forEach((b, index) => (index > 0 ? b.dispose() : null));\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n};\n\nexport { unpartition };\n","import { Texture, TextureInfo } from '@gltf-transform/core';\n\n/**\n * Lists all {@link TextureInfo} definitions associated with a given {@link Texture}.\n *\n * Example:\n *\n * ```js\n * // Find TextureInfo instances associated with the texture.\n * const results = listTextureInfo(texture);\n *\n * // Find which UV sets (TEXCOORD_0, TEXCOORD_1, ...) are required.\n * const texCoords = results.map((info) => info.getTexCoord());\n * // → [0, 0, 1]\n * ```\n */\nexport function listTextureInfo(texture: Texture): TextureInfo[] {\n\tconst graph = texture.getGraph();\n\tconst results: TextureInfo[] = [];\n\n\tfor (const textureEdge of graph.listParentEdges(texture)) {\n\t\tconst parent = textureEdge.getParent();\n\t\tconst name = textureEdge.getName() + 'Info';\n\n\t\tfor (const edge of graph.listChildEdges(parent)) {\n\t\t\tconst child = edge.getChild();\n\t\t\tif (child instanceof TextureInfo && edge.getName() === name) {\n\t\t\t\tresults.push(child);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn results;\n}\n"],"names":["rewriteTexture","source","target","fn","srcImage","getImage","getPixels","getMimeType","pixels","i","shape","j","savePixels","dstImage","setImage","setMimeType","createTransform","name","Object","defineProperty","value","isTransformPending","context","initial","pending","stack","lastIndexOf","getGLPrimitiveCount","prim","indices","getIndices","position","getAttribute","getMode","Primitive","Mode","POINTS","getCount","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","Error","SetMap","_map","Map","size","has","k","add","v","entry","this","get","Set","set","keys","formatBytes","bytes","decimals","dm","Math","floor","log","parseFloat","pow","toFixed","formatLong","x","toString","replace","formatDeltaOp","a","b","abs","formatDelta","deepListAttributes","accessors","attribute","listAttributes","push","listTargets","Array","from","deepSwapAttribute","src","dst","swap","remapAttribute","remap","dstCount","elementSize","getElementSize","srcCount","srcArray","getArray","dstArray","slice","setArray","createIndices","count","maxIndex","array","Uint16Array","Uint32Array","length","createPrimGroupKey","document","Document","fromGraph","getGraph","material","getMaterial","getRoot","listMaterials","indexOf","listSemantics","sort","map","semantic","getComponentType","join","CENTER_DEFAULTS","pivot","getNodeScene","node","visited","parent","child","getParent","Scene","clearNodeParent","scene","setMatrix","getWorldMatrix","removeChild","addChild","ARRAY_TYPE","Float32Array","invert","out","a00","a01","a02","a03","a10","a11","a12","a13","a20","a21","a22","a23","a30","a31","a32","a33","b00","b01","b02","b03","b04","b05","b06","b07","b08","b09","b10","b11","det","multiply","b0","b1","b2","b3","create","glMatrix.ARRAY_TYPE","fromValues","y","z","min","max","scale","normalize","len","sqrt","transformMat4","m","w","transformMat3","transformPrimitive","matrix","skipIndices","applyMatrix","normal","applyNormalMatrix","tangent","applyTangentMatrix","el","il","getElement","vector","createVec3","index","setNormalized","normalMatrix","createMat3","b21","transpose","normalizeVec3","setElement","v3","v4","createVec4","transformMesh","mesh","overwrite","srcPrim","listPrimitives","listParents","some","p","propertyType","PropertyType","MESH","dstPrim","clone","srcTarget","dstTarget","parents","flatMap","attributes","srcAttribute","PrimitiveTarget","dstAttribute","hypot","arguments","IDENTITY","NAME","DEDUP_DEFAULTS","propertyTypes","ACCESSOR","TEXTURE","MATERIAL","dedup","_options","options","includes","doc","logger","getLogger","indicesAccessors","attributeAccessors","inputAccessors","outputAccessors","meshes","listMeshes","forEach","primitive","accessor","animation","listAnimations","sampler","listSamplers","input","getInput","output","getOutput","detectDuplicates","duplicateAccessors","aData","BufferUtils","toView","getType","getNormalized","equals","duplicateIndices","debug","duplicateAttributes","duplicateInputs","duplicateOutputs","dispose","dedupAccessors","root","textures","listTextures","duplicates","bData","aSize","getSize","bSize","entries","property","Root","dedupImages","materials","skip","dedupMaterials","refs","listAccessors","numMeshes","uniqueMeshes","srcKeyItems","createPrimitiveKey","meshKey","targetMesh","ROOT","dedupMeshes","primKeyItems","DEQUANTIZE_DEFAULTS","pattern","dequantizePrimitive","dequantizeAttribute","test","getComponentSize","DRACO_DEFAULTS","method","encodeSpeed","decodeSpeed","quantizePosition","quantizeNormal","quantizeColor","quantizeTexcoord","quantizeGeneric","quantizationVolume","PRUNE_DEFAULTS","NODE","SKIN","CAMERA","PRIMITIVE","PRIMITIVE_TARGET","ANIMATION","BUFFER","keepLeaves","keepAttributes","prune","graph","disposed","markDisposed","listScenes","nodeTreeShake","prop","listChildren","isUsed","listParentEdges","e","ptype","SCENE","listNodes","treeShake","listSkins","listCameras","indirectTreeShake","required","listRequiredSemantics","unused","listUnusedSemantics","pruneAttributes","anim","channel","listChannels","getTargetNode","samplers","listBuffers","str","t","info","filter","AnimationChannel","listEdges","edge","setAttribute","startsWith","semantics","edges","listChildEdges","textureNames","getChild","Texture","getName","TextureInfo","getTexCoord","match","ExtensionProperty","FLATTEN_DEFAULTS","properties","sceneBounds","getBounds","rootName","bboxMin","toPrecision","bboxMax","instances","glPrimitives","verts","meshIndices","meshAccessors","attr","accessorToTypeLabel","targ","byteLength","modes","MeshPrimitiveModeLabels","mode","primitives","vertices","extensions","listExtensions","slots","ref","alphaMode","getAlphaMode","doubleSided","getDoubleSided","texture","resolution","ImageUtils","compression","dfd","readKTX","dataFormatDescriptor","colorModel","KHR_DF_MODEL_ETC1S","KHR_DF_MODEL_UASTC","uri","getURI","mimeType","gpuSize","getVRAMByteLength","minTime","Infinity","maxTime","getMin","getMax","keyframes","channels","duration","round","NumericTypeLabels","Uint8Array","Int32Array","Int16Array","Int8Array","Number","constructor","INSTANCE_DEFAULTS","pruneUnusedNodes","nodes","unusedNodes","pop","getCamera","getMesh","getSkin","nodeParent","Node","createBatch","batchExtension","buffer","getBuffer","batchTranslation","createAccessor","setType","setBuffer","batchRotation","batchScale","createInstancedMesh","JOIN_PRIMITIVE_DEFAULTS","skipValidation","joinPrimitives","prims","templatePrim","remapList","indicesList","dstVertexCount","dstIndicesCount","_getOrCreateIndices","undefined","createPrimitive","setMode","setMaterial","tplAttribute","AttributeArray","ComponentTypeToTypedArray","dstIndices","setIndices","dstNextIndex","primIndex","indicesArray","primStartIndex","primNextIndex","setScalar","_matrix","JOIN_DEFAULTS","keepMeshes","keepNamed","_joinLevel","groups","children","nodeIndex","getExtension","key","isNamed","primMeshes","primNodes","dstNode","dstMesh","group","joinGroups","values","srcNodes","setMesh","dstMatrix","getMatrix","primNode","removePrimitive","hasSharedAttributes","_deepClonePrimitive","addPrimitive","REORDER_DEFAULTS","reorder","encoder","ready","plan","createLayoutPlan","srcIndices","indicesToAttributes","unique","reorderMesh","indicesToMode","attributesToPrimitives","transform","warn","sortPrimitiveWeights","limit","isFinite","vertexCount","setCount","srcWeights","dstWeights","srcJoints","dstJoints","getVertexArray","setVertexArray","weights","joints","normList","typeList","isNormalizeSafe","templateAttribute","templateArray","componentType","normalized","normalizedComponentType","delta","MathUtils","decodeNormalizedInt","EPSILON","fill","weightsSum","sum","intValue","encodeNormalizedInt","normalizePrimitiveWeights","vertexIndex","prefix","SIGNED_INT","TRANSLATION","ROTATION","SCALE","WEIGHTS","TargetPath","TRS_CHANNELS","QUANTIZE_DEFAULTS","quantizeWeight","normalizeWeights","quantize","nodeTransform","createExtension","KHRMeshQuantization","setRequired","getNodeTransform","bboxes","result","bbox","expandBounds","getPositionQuantizationVolume","transformMeshParents","transformMeshMaterials","quantizePrimitive","bits","ctor","getQuantizationSettings","fromTransform","quantizeAttribute","volume","offset","transformMatrix","animChannels","isAnimated","getTargetPath","isParentNode","setSkin","transformSkin","targetNode","createNode","setTargetNode","nodeMatrix","multiplyMat4","skin","inverseBindMatrices","getInverseBindMatrices","ibm","setInverseBindMatrices","getThicknessFactor","setThicknessFactor","setExtension","signBits","quantBits","storageBits","BYTES_PER_ELEMENT","lo","hi","di","sign","setSparse","getMinNormalized","getMaxNormalized","positions","relativePositions","flatBounds","relMin","relMax","tmpMin","tmpMax","xx","q","x2","xy","y2","xz","z2","yz","wx","wy","wz","sy","s","sz","yy","zz","sx","MESHOPT_DEFAULTS","level","state","pact","_isSettledPact","thenable","METALROUGH_DEFAULTS","UNWELD_DEFAULTS","unweld","srcVertexCount","unweldAttribute","ArrayCtor","getScalar","NORMALS_DEFAULTS","computeNormal","c","A","B","PARTITION_DEFAULTS","animations","createBufferURI","basename","existing","getAngle","dotproduct","dot","acos","slerp","omega","cosom","sinom","scale0","scale1","ax","ay","az","aw","bx","by","bz","bw","sin","vec3.create","vec3.fromValues","mat3.create","RESAMPLE_DEFAULTS","tolerance","optimize","path","interpolation","getInterpolation","lastIndex","tmp","valueNext","valuePrev","writeIndex","timePrev","time","timeNext","keep","sample","angle","eq","PI","vlerp","setInput","setOutput","lerp","v0","v1","SEQUENCE_DEFAULTS","fps","WELD_DEFAULTS","weld","weldPrimitive","numVertices","Accessor","Type","SCALAR","_indexPrimitive","srcPosition","uniqueIndices","attributeTolerance","getAttributeTolerance","kv","posA","posB","weldMap","writeMap","backIters","isBaseMatch","every","compareAttributes","isTargetMatch","dstIndicesArray","srcAttr","swapAttributes","_weldPrimitive","dstAttrArray","dstAttr","done","_a","_b","_semantic","SIMPLIFY_DEFAULTS","ratio","error","lockBorder","simplifyPrimitive","simplifier","positionArray","ComponentType","FLOAT","UNSIGNED_INT","targetCount","simplify","compactMesh","SPARSE_DEFAULTS","getTextureChannelMask","mask","getAttributes","Material","AlphaMode","OPAQUE","TextureChannel","listTextureSlots","_settle","o","prototype","onFulfilled","TextureResizeFilter","TEXTURE_RESIZE_DEFAULTS","LANCZOS3","FORMATS","SUPPORTED_MIME_TYPES","TEXTURE_COMPRESS_DEFAULTS","resizeFilter","formats","quality","effort","lossless","nearLossless","srcMax","dstMax","TANGENTS_DEFAULTS","getNormalTexcoord","normalTextureInfo","getNormalTextureInfo","filterPrimitive","meshName","unlit","UNPARTITION_DEFAULTS","offsetNode","setTranslation","getTranslation","localMatrix","inputEncoding","converted","sRGBToLinear","updatePrimitive","color","KHRDracoMeshCompression","setEncoderOptions","EncoderMethod","EDGEBREAKER","SEQUENTIAL","quantizationBits","POSITION","NORMAL","COLOR","TEX_COORD","GENERIC","joint","listJoints","animated","hasJointParent","hasAnimatedParent","traverse","scenes","EXTMeshGPUInstancing","numBatches","numInstances","meshInstances","modifiedNodes","batch","batchNode","needsTranslation","needsRotation","needsScale","r","getWorldTranslation","getWorldRotation","getWorldScale","listProperties","R","G","results","textureEdge","EXTMeshoptCompression","QUANTIZE","FILTER","specGlossExtension","tex","inputTextures","listExtensionsUsed","ext","extensionName","iorExtension","KHRMaterialsIOR","specExtension","KHRMaterialsSpecular","KHRMaterialsPBRSpecularGlossiness","specGloss","specular","createSpecular","setSpecularFactor","setSpecularColorFactor","getSpecularFactor","getSpecularGlossinessTexture","getBaseColorTexture","getMetallicRoughnessTexture","setBaseColorFactor","getDiffuseFactor","setMetallicFactor","setRoughnessFactor","createIOR","setIOR","diffuseTexture","getDiffuseTexture","setBaseColorTexture","getBaseColorTextureInfo","copy","getDiffuseTextureInfo","sgTexture","sgTextureInfo","getSpecularGlossinessTextureInfo","specularTexture","createTexture","setSpecularTexture","setSpecularColorTexture","getSpecularTextureInfo","getSpecularColorTextureInfo","glossinessFactor","getGlossinessFactor","metalRoughTexture","roughness","setMetallicRoughnessTexture","getMetallicRoughnessTextureInfo","modified","faceNormal","existingURIs","meshIndex","isArray","createBuffer","setURI","primTarget","partitionMeshes","animIndex","partitionAnimations","didSkipMorphTargets","accessorsVisited","srcAccessorCount","samplerTargetPaths","getSampler","dstAccessorCount","sequenceNodes","createAnimation","animBuffer","inputArray","outputArray","VEC3","createAnimationSampler","setInterpolation","AnimationSampler","Interpolation","STEP","createAnimationChannel","setTargetPath","setSampler","addSampler","addChannel","modifiedCount","base","nonZeroCount","sparse","getSparse","generateTangents","attributeIDs","tangentCache","meshPrimitives","texcoordSemantic","texcoord","positionID","uuid","normalID","texcoordID","prevTangent","attributeHash","tangentBuffer","tangentArray","targetFormat","resize","patternRe","formatsRe","slotsRe","Promise","all","textureIndex","textureLabel","slot","srcFormat","format","split","getFormat","dstFormat","srcMimeType","dstMimeType","encoderOptions","instance","toFormat","fit","kernel","withoutEnlargement","toBuffer","srcExtension","mimeTypeToExtension","dstExtension","dstURI","RegExp","dstByteLength","webpExtension","EXTTextureWebP","avifExtension","EXTTextureAVIF","maxWidth","maxHeight","srcWidth","srcHeight","dstWidth","dstHeight","srcPixels","dstPixels","ndarray","lanczos3","lanczos2","message","_setImage","KHRMaterialsUnlit","createUnlit"],"mappings":"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"}